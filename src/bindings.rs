/* automatically generated by rust-bindgen 0.69.4 */

pub const __PRI_8_LENGTH_MODIFIER__: &[u8; 3] = b"hh\0";
pub const __PRI_64_LENGTH_MODIFIER__: &[u8; 3] = b"ll\0";
pub const __SCN_64_LENGTH_MODIFIER__: &[u8; 3] = b"ll\0";
pub const __PRI_MAX_LENGTH_MODIFIER__: &[u8; 2] = b"j\0";
pub const __SCN_MAX_LENGTH_MODIFIER__: &[u8; 2] = b"j\0";
pub const PRId8: &[u8; 4] = b"hhd\0";
pub const PRIi8: &[u8; 4] = b"hhi\0";
pub const PRIo8: &[u8; 4] = b"hho\0";
pub const PRIu8: &[u8; 4] = b"hhu\0";
pub const PRIx8: &[u8; 4] = b"hhx\0";
pub const PRIX8: &[u8; 4] = b"hhX\0";
pub const PRId16: &[u8; 3] = b"hd\0";
pub const PRIi16: &[u8; 3] = b"hi\0";
pub const PRIo16: &[u8; 3] = b"ho\0";
pub const PRIu16: &[u8; 3] = b"hu\0";
pub const PRIx16: &[u8; 3] = b"hx\0";
pub const PRIX16: &[u8; 3] = b"hX\0";
pub const PRId32: &[u8; 2] = b"d\0";
pub const PRIi32: &[u8; 2] = b"i\0";
pub const PRIo32: &[u8; 2] = b"o\0";
pub const PRIu32: &[u8; 2] = b"u\0";
pub const PRIx32: &[u8; 2] = b"x\0";
pub const PRIX32: &[u8; 2] = b"X\0";
pub const PRId64: &[u8; 4] = b"lld\0";
pub const PRIi64: &[u8; 4] = b"lli\0";
pub const PRIo64: &[u8; 4] = b"llo\0";
pub const PRIu64: &[u8; 4] = b"llu\0";
pub const PRIx64: &[u8; 4] = b"llx\0";
pub const PRIX64: &[u8; 4] = b"llX\0";
pub const PRIdLEAST8: &[u8; 4] = b"hhd\0";
pub const PRIiLEAST8: &[u8; 4] = b"hhi\0";
pub const PRIoLEAST8: &[u8; 4] = b"hho\0";
pub const PRIuLEAST8: &[u8; 4] = b"hhu\0";
pub const PRIxLEAST8: &[u8; 4] = b"hhx\0";
pub const PRIXLEAST8: &[u8; 4] = b"hhX\0";
pub const PRIdLEAST16: &[u8; 3] = b"hd\0";
pub const PRIiLEAST16: &[u8; 3] = b"hi\0";
pub const PRIoLEAST16: &[u8; 3] = b"ho\0";
pub const PRIuLEAST16: &[u8; 3] = b"hu\0";
pub const PRIxLEAST16: &[u8; 3] = b"hx\0";
pub const PRIXLEAST16: &[u8; 3] = b"hX\0";
pub const PRIdLEAST32: &[u8; 2] = b"d\0";
pub const PRIiLEAST32: &[u8; 2] = b"i\0";
pub const PRIoLEAST32: &[u8; 2] = b"o\0";
pub const PRIuLEAST32: &[u8; 2] = b"u\0";
pub const PRIxLEAST32: &[u8; 2] = b"x\0";
pub const PRIXLEAST32: &[u8; 2] = b"X\0";
pub const PRIdLEAST64: &[u8; 4] = b"lld\0";
pub const PRIiLEAST64: &[u8; 4] = b"lli\0";
pub const PRIoLEAST64: &[u8; 4] = b"llo\0";
pub const PRIuLEAST64: &[u8; 4] = b"llu\0";
pub const PRIxLEAST64: &[u8; 4] = b"llx\0";
pub const PRIXLEAST64: &[u8; 4] = b"llX\0";
pub const PRIdFAST8: &[u8; 4] = b"hhd\0";
pub const PRIiFAST8: &[u8; 4] = b"hhi\0";
pub const PRIoFAST8: &[u8; 4] = b"hho\0";
pub const PRIuFAST8: &[u8; 4] = b"hhu\0";
pub const PRIxFAST8: &[u8; 4] = b"hhx\0";
pub const PRIXFAST8: &[u8; 4] = b"hhX\0";
pub const PRIdFAST16: &[u8; 3] = b"hd\0";
pub const PRIiFAST16: &[u8; 3] = b"hi\0";
pub const PRIoFAST16: &[u8; 3] = b"ho\0";
pub const PRIuFAST16: &[u8; 3] = b"hu\0";
pub const PRIxFAST16: &[u8; 3] = b"hx\0";
pub const PRIXFAST16: &[u8; 3] = b"hX\0";
pub const PRIdFAST32: &[u8; 2] = b"d\0";
pub const PRIiFAST32: &[u8; 2] = b"i\0";
pub const PRIoFAST32: &[u8; 2] = b"o\0";
pub const PRIuFAST32: &[u8; 2] = b"u\0";
pub const PRIxFAST32: &[u8; 2] = b"x\0";
pub const PRIXFAST32: &[u8; 2] = b"X\0";
pub const PRIdFAST64: &[u8; 4] = b"lld\0";
pub const PRIiFAST64: &[u8; 4] = b"lli\0";
pub const PRIoFAST64: &[u8; 4] = b"llo\0";
pub const PRIuFAST64: &[u8; 4] = b"llu\0";
pub const PRIxFAST64: &[u8; 4] = b"llx\0";
pub const PRIXFAST64: &[u8; 4] = b"llX\0";
pub const PRIdPTR: &[u8; 3] = b"ld\0";
pub const PRIiPTR: &[u8; 3] = b"li\0";
pub const PRIoPTR: &[u8; 3] = b"lo\0";
pub const PRIuPTR: &[u8; 3] = b"lu\0";
pub const PRIxPTR: &[u8; 3] = b"lx\0";
pub const PRIXPTR: &[u8; 3] = b"lX\0";
pub const PRIdMAX: &[u8; 3] = b"jd\0";
pub const PRIiMAX: &[u8; 3] = b"ji\0";
pub const PRIoMAX: &[u8; 3] = b"jo\0";
pub const PRIuMAX: &[u8; 3] = b"ju\0";
pub const PRIxMAX: &[u8; 3] = b"jx\0";
pub const PRIXMAX: &[u8; 3] = b"jX\0";
pub const SCNd8: &[u8; 4] = b"hhd\0";
pub const SCNi8: &[u8; 4] = b"hhi\0";
pub const SCNo8: &[u8; 4] = b"hho\0";
pub const SCNu8: &[u8; 4] = b"hhu\0";
pub const SCNx8: &[u8; 4] = b"hhx\0";
pub const SCNd16: &[u8; 3] = b"hd\0";
pub const SCNi16: &[u8; 3] = b"hi\0";
pub const SCNo16: &[u8; 3] = b"ho\0";
pub const SCNu16: &[u8; 3] = b"hu\0";
pub const SCNx16: &[u8; 3] = b"hx\0";
pub const SCNd32: &[u8; 2] = b"d\0";
pub const SCNi32: &[u8; 2] = b"i\0";
pub const SCNo32: &[u8; 2] = b"o\0";
pub const SCNu32: &[u8; 2] = b"u\0";
pub const SCNx32: &[u8; 2] = b"x\0";
pub const SCNd64: &[u8; 4] = b"lld\0";
pub const SCNi64: &[u8; 4] = b"lli\0";
pub const SCNo64: &[u8; 4] = b"llo\0";
pub const SCNu64: &[u8; 4] = b"llu\0";
pub const SCNx64: &[u8; 4] = b"llx\0";
pub const SCNdLEAST8: &[u8; 4] = b"hhd\0";
pub const SCNiLEAST8: &[u8; 4] = b"hhi\0";
pub const SCNoLEAST8: &[u8; 4] = b"hho\0";
pub const SCNuLEAST8: &[u8; 4] = b"hhu\0";
pub const SCNxLEAST8: &[u8; 4] = b"hhx\0";
pub const SCNdLEAST16: &[u8; 3] = b"hd\0";
pub const SCNiLEAST16: &[u8; 3] = b"hi\0";
pub const SCNoLEAST16: &[u8; 3] = b"ho\0";
pub const SCNuLEAST16: &[u8; 3] = b"hu\0";
pub const SCNxLEAST16: &[u8; 3] = b"hx\0";
pub const SCNdLEAST32: &[u8; 2] = b"d\0";
pub const SCNiLEAST32: &[u8; 2] = b"i\0";
pub const SCNoLEAST32: &[u8; 2] = b"o\0";
pub const SCNuLEAST32: &[u8; 2] = b"u\0";
pub const SCNxLEAST32: &[u8; 2] = b"x\0";
pub const SCNdLEAST64: &[u8; 4] = b"lld\0";
pub const SCNiLEAST64: &[u8; 4] = b"lli\0";
pub const SCNoLEAST64: &[u8; 4] = b"llo\0";
pub const SCNuLEAST64: &[u8; 4] = b"llu\0";
pub const SCNxLEAST64: &[u8; 4] = b"llx\0";
pub const SCNdFAST8: &[u8; 4] = b"hhd\0";
pub const SCNiFAST8: &[u8; 4] = b"hhi\0";
pub const SCNoFAST8: &[u8; 4] = b"hho\0";
pub const SCNuFAST8: &[u8; 4] = b"hhu\0";
pub const SCNxFAST8: &[u8; 4] = b"hhx\0";
pub const SCNdFAST16: &[u8; 3] = b"hd\0";
pub const SCNiFAST16: &[u8; 3] = b"hi\0";
pub const SCNoFAST16: &[u8; 3] = b"ho\0";
pub const SCNuFAST16: &[u8; 3] = b"hu\0";
pub const SCNxFAST16: &[u8; 3] = b"hx\0";
pub const SCNdFAST32: &[u8; 2] = b"d\0";
pub const SCNiFAST32: &[u8; 2] = b"i\0";
pub const SCNoFAST32: &[u8; 2] = b"o\0";
pub const SCNuFAST32: &[u8; 2] = b"u\0";
pub const SCNxFAST32: &[u8; 2] = b"x\0";
pub const SCNdFAST64: &[u8; 4] = b"lld\0";
pub const SCNiFAST64: &[u8; 4] = b"lli\0";
pub const SCNoFAST64: &[u8; 4] = b"llo\0";
pub const SCNuFAST64: &[u8; 4] = b"llu\0";
pub const SCNxFAST64: &[u8; 4] = b"llx\0";
pub const SCNdPTR: &[u8; 3] = b"ld\0";
pub const SCNiPTR: &[u8; 3] = b"li\0";
pub const SCNoPTR: &[u8; 3] = b"lo\0";
pub const SCNuPTR: &[u8; 3] = b"lu\0";
pub const SCNxPTR: &[u8; 3] = b"lx\0";
pub const SCNdMAX: &[u8; 3] = b"jd\0";
pub const SCNiMAX: &[u8; 3] = b"ji\0";
pub const SCNoMAX: &[u8; 3] = b"jo\0";
pub const SCNuMAX: &[u8; 3] = b"ju\0";
pub const SCNxMAX: &[u8; 3] = b"jx\0";
pub const __has_safe_buffers: u32 = 1;
pub const __DARWIN_ONLY_64_BIT_INO_T: u32 = 1;
pub const __DARWIN_ONLY_UNIX_CONFORMANCE: u32 = 1;
pub const __DARWIN_ONLY_VERS_1050: u32 = 1;
pub const __DARWIN_UNIX03: u32 = 1;
pub const __DARWIN_64_BIT_INO_T: u32 = 1;
pub const __DARWIN_VERS_1050: u32 = 1;
pub const __DARWIN_NON_CANCELABLE: u32 = 0;
pub const __DARWIN_SUF_EXTSN: &[u8; 14] = b"$DARWIN_EXTSN\0";
pub const __DARWIN_C_ANSI: u32 = 4096;
pub const __DARWIN_C_FULL: u32 = 900000;
pub const __DARWIN_C_LEVEL: u32 = 900000;
pub const __STDC_WANT_LIB_EXT1__: u32 = 1;
pub const __DARWIN_NO_LONG_LONG: u32 = 0;
pub const _DARWIN_FEATURE_64_BIT_INODE: u32 = 1;
pub const _DARWIN_FEATURE_ONLY_64_BIT_INODE: u32 = 1;
pub const _DARWIN_FEATURE_ONLY_VERS_1050: u32 = 1;
pub const _DARWIN_FEATURE_ONLY_UNIX_CONFORMANCE: u32 = 1;
pub const _DARWIN_FEATURE_UNIX_CONFORMANCE: u32 = 3;
pub const __has_ptrcheck: u32 = 0;
pub const __API_TO_BE_DEPRECATED: u32 = 100000;
pub const __API_TO_BE_DEPRECATED_MACOS: u32 = 100000;
pub const __API_TO_BE_DEPRECATED_IOS: u32 = 100000;
pub const __API_TO_BE_DEPRECATED_MACCATALYST: u32 = 100000;
pub const __API_TO_BE_DEPRECATED_WATCHOS: u32 = 100000;
pub const __API_TO_BE_DEPRECATED_TVOS: u32 = 100000;
pub const __API_TO_BE_DEPRECATED_DRIVERKIT: u32 = 100000;
pub const __API_TO_BE_DEPRECATED_VISIONOS: u32 = 100000;
pub const __MAC_10_0: u32 = 1000;
pub const __MAC_10_1: u32 = 1010;
pub const __MAC_10_2: u32 = 1020;
pub const __MAC_10_3: u32 = 1030;
pub const __MAC_10_4: u32 = 1040;
pub const __MAC_10_5: u32 = 1050;
pub const __MAC_10_6: u32 = 1060;
pub const __MAC_10_7: u32 = 1070;
pub const __MAC_10_8: u32 = 1080;
pub const __MAC_10_9: u32 = 1090;
pub const __MAC_10_10: u32 = 101000;
pub const __MAC_10_10_2: u32 = 101002;
pub const __MAC_10_10_3: u32 = 101003;
pub const __MAC_10_11: u32 = 101100;
pub const __MAC_10_11_2: u32 = 101102;
pub const __MAC_10_11_3: u32 = 101103;
pub const __MAC_10_11_4: u32 = 101104;
pub const __MAC_10_12: u32 = 101200;
pub const __MAC_10_12_1: u32 = 101201;
pub const __MAC_10_12_2: u32 = 101202;
pub const __MAC_10_12_4: u32 = 101204;
pub const __MAC_10_13: u32 = 101300;
pub const __MAC_10_13_1: u32 = 101301;
pub const __MAC_10_13_2: u32 = 101302;
pub const __MAC_10_13_4: u32 = 101304;
pub const __MAC_10_14: u32 = 101400;
pub const __MAC_10_14_1: u32 = 101401;
pub const __MAC_10_14_4: u32 = 101404;
pub const __MAC_10_14_5: u32 = 101405;
pub const __MAC_10_14_6: u32 = 101406;
pub const __MAC_10_15: u32 = 101500;
pub const __MAC_10_15_1: u32 = 101501;
pub const __MAC_10_15_4: u32 = 101504;
pub const __MAC_10_16: u32 = 101600;
pub const __MAC_11_0: u32 = 110000;
pub const __MAC_11_1: u32 = 110100;
pub const __MAC_11_3: u32 = 110300;
pub const __MAC_11_4: u32 = 110400;
pub const __MAC_11_5: u32 = 110500;
pub const __MAC_11_6: u32 = 110600;
pub const __MAC_12_0: u32 = 120000;
pub const __MAC_12_1: u32 = 120100;
pub const __MAC_12_2: u32 = 120200;
pub const __MAC_12_3: u32 = 120300;
pub const __MAC_12_4: u32 = 120400;
pub const __MAC_12_5: u32 = 120500;
pub const __MAC_12_6: u32 = 120600;
pub const __MAC_12_7: u32 = 120700;
pub const __MAC_13_0: u32 = 130000;
pub const __MAC_13_1: u32 = 130100;
pub const __MAC_13_2: u32 = 130200;
pub const __MAC_13_3: u32 = 130300;
pub const __MAC_13_4: u32 = 130400;
pub const __MAC_13_5: u32 = 130500;
pub const __MAC_13_6: u32 = 130600;
pub const __MAC_14_0: u32 = 140000;
pub const __MAC_14_1: u32 = 140100;
pub const __MAC_14_2: u32 = 140200;
pub const __MAC_14_3: u32 = 140300;
pub const __MAC_14_4: u32 = 140400;
pub const __MAC_14_5: u32 = 140500;
pub const __IPHONE_2_0: u32 = 20000;
pub const __IPHONE_2_1: u32 = 20100;
pub const __IPHONE_2_2: u32 = 20200;
pub const __IPHONE_3_0: u32 = 30000;
pub const __IPHONE_3_1: u32 = 30100;
pub const __IPHONE_3_2: u32 = 30200;
pub const __IPHONE_4_0: u32 = 40000;
pub const __IPHONE_4_1: u32 = 40100;
pub const __IPHONE_4_2: u32 = 40200;
pub const __IPHONE_4_3: u32 = 40300;
pub const __IPHONE_5_0: u32 = 50000;
pub const __IPHONE_5_1: u32 = 50100;
pub const __IPHONE_6_0: u32 = 60000;
pub const __IPHONE_6_1: u32 = 60100;
pub const __IPHONE_7_0: u32 = 70000;
pub const __IPHONE_7_1: u32 = 70100;
pub const __IPHONE_8_0: u32 = 80000;
pub const __IPHONE_8_1: u32 = 80100;
pub const __IPHONE_8_2: u32 = 80200;
pub const __IPHONE_8_3: u32 = 80300;
pub const __IPHONE_8_4: u32 = 80400;
pub const __IPHONE_9_0: u32 = 90000;
pub const __IPHONE_9_1: u32 = 90100;
pub const __IPHONE_9_2: u32 = 90200;
pub const __IPHONE_9_3: u32 = 90300;
pub const __IPHONE_10_0: u32 = 100000;
pub const __IPHONE_10_1: u32 = 100100;
pub const __IPHONE_10_2: u32 = 100200;
pub const __IPHONE_10_3: u32 = 100300;
pub const __IPHONE_11_0: u32 = 110000;
pub const __IPHONE_11_1: u32 = 110100;
pub const __IPHONE_11_2: u32 = 110200;
pub const __IPHONE_11_3: u32 = 110300;
pub const __IPHONE_11_4: u32 = 110400;
pub const __IPHONE_12_0: u32 = 120000;
pub const __IPHONE_12_1: u32 = 120100;
pub const __IPHONE_12_2: u32 = 120200;
pub const __IPHONE_12_3: u32 = 120300;
pub const __IPHONE_12_4: u32 = 120400;
pub const __IPHONE_13_0: u32 = 130000;
pub const __IPHONE_13_1: u32 = 130100;
pub const __IPHONE_13_2: u32 = 130200;
pub const __IPHONE_13_3: u32 = 130300;
pub const __IPHONE_13_4: u32 = 130400;
pub const __IPHONE_13_5: u32 = 130500;
pub const __IPHONE_13_6: u32 = 130600;
pub const __IPHONE_13_7: u32 = 130700;
pub const __IPHONE_14_0: u32 = 140000;
pub const __IPHONE_14_1: u32 = 140100;
pub const __IPHONE_14_2: u32 = 140200;
pub const __IPHONE_14_3: u32 = 140300;
pub const __IPHONE_14_5: u32 = 140500;
pub const __IPHONE_14_4: u32 = 140400;
pub const __IPHONE_14_6: u32 = 140600;
pub const __IPHONE_14_7: u32 = 140700;
pub const __IPHONE_14_8: u32 = 140800;
pub const __IPHONE_15_0: u32 = 150000;
pub const __IPHONE_15_1: u32 = 150100;
pub const __IPHONE_15_2: u32 = 150200;
pub const __IPHONE_15_3: u32 = 150300;
pub const __IPHONE_15_4: u32 = 150400;
pub const __IPHONE_15_5: u32 = 150500;
pub const __IPHONE_15_6: u32 = 150600;
pub const __IPHONE_15_7: u32 = 150700;
pub const __IPHONE_15_8: u32 = 150800;
pub const __IPHONE_16_0: u32 = 160000;
pub const __IPHONE_16_1: u32 = 160100;
pub const __IPHONE_16_2: u32 = 160200;
pub const __IPHONE_16_3: u32 = 160300;
pub const __IPHONE_16_4: u32 = 160400;
pub const __IPHONE_16_5: u32 = 160500;
pub const __IPHONE_16_6: u32 = 160600;
pub const __IPHONE_16_7: u32 = 160700;
pub const __IPHONE_17_0: u32 = 170000;
pub const __IPHONE_17_1: u32 = 170100;
pub const __IPHONE_17_2: u32 = 170200;
pub const __IPHONE_17_3: u32 = 170300;
pub const __IPHONE_17_4: u32 = 170400;
pub const __IPHONE_17_5: u32 = 170500;
pub const __WATCHOS_1_0: u32 = 10000;
pub const __WATCHOS_2_0: u32 = 20000;
pub const __WATCHOS_2_1: u32 = 20100;
pub const __WATCHOS_2_2: u32 = 20200;
pub const __WATCHOS_3_0: u32 = 30000;
pub const __WATCHOS_3_1: u32 = 30100;
pub const __WATCHOS_3_1_1: u32 = 30101;
pub const __WATCHOS_3_2: u32 = 30200;
pub const __WATCHOS_4_0: u32 = 40000;
pub const __WATCHOS_4_1: u32 = 40100;
pub const __WATCHOS_4_2: u32 = 40200;
pub const __WATCHOS_4_3: u32 = 40300;
pub const __WATCHOS_5_0: u32 = 50000;
pub const __WATCHOS_5_1: u32 = 50100;
pub const __WATCHOS_5_2: u32 = 50200;
pub const __WATCHOS_5_3: u32 = 50300;
pub const __WATCHOS_6_0: u32 = 60000;
pub const __WATCHOS_6_1: u32 = 60100;
pub const __WATCHOS_6_2: u32 = 60200;
pub const __WATCHOS_7_0: u32 = 70000;
pub const __WATCHOS_7_1: u32 = 70100;
pub const __WATCHOS_7_2: u32 = 70200;
pub const __WATCHOS_7_3: u32 = 70300;
pub const __WATCHOS_7_4: u32 = 70400;
pub const __WATCHOS_7_5: u32 = 70500;
pub const __WATCHOS_7_6: u32 = 70600;
pub const __WATCHOS_8_0: u32 = 80000;
pub const __WATCHOS_8_1: u32 = 80100;
pub const __WATCHOS_8_3: u32 = 80300;
pub const __WATCHOS_8_4: u32 = 80400;
pub const __WATCHOS_8_5: u32 = 80500;
pub const __WATCHOS_8_6: u32 = 80600;
pub const __WATCHOS_8_7: u32 = 80700;
pub const __WATCHOS_8_8: u32 = 80800;
pub const __WATCHOS_9_0: u32 = 90000;
pub const __WATCHOS_9_1: u32 = 90100;
pub const __WATCHOS_9_2: u32 = 90200;
pub const __WATCHOS_9_3: u32 = 90300;
pub const __WATCHOS_9_4: u32 = 90400;
pub const __WATCHOS_9_5: u32 = 90500;
pub const __WATCHOS_9_6: u32 = 90600;
pub const __WATCHOS_10_0: u32 = 100000;
pub const __WATCHOS_10_1: u32 = 100100;
pub const __WATCHOS_10_2: u32 = 100200;
pub const __WATCHOS_10_3: u32 = 100300;
pub const __WATCHOS_10_4: u32 = 100400;
pub const __WATCHOS_10_5: u32 = 100500;
pub const __TVOS_9_0: u32 = 90000;
pub const __TVOS_9_1: u32 = 90100;
pub const __TVOS_9_2: u32 = 90200;
pub const __TVOS_10_0: u32 = 100000;
pub const __TVOS_10_0_1: u32 = 100001;
pub const __TVOS_10_1: u32 = 100100;
pub const __TVOS_10_2: u32 = 100200;
pub const __TVOS_11_0: u32 = 110000;
pub const __TVOS_11_1: u32 = 110100;
pub const __TVOS_11_2: u32 = 110200;
pub const __TVOS_11_3: u32 = 110300;
pub const __TVOS_11_4: u32 = 110400;
pub const __TVOS_12_0: u32 = 120000;
pub const __TVOS_12_1: u32 = 120100;
pub const __TVOS_12_2: u32 = 120200;
pub const __TVOS_12_3: u32 = 120300;
pub const __TVOS_12_4: u32 = 120400;
pub const __TVOS_13_0: u32 = 130000;
pub const __TVOS_13_2: u32 = 130200;
pub const __TVOS_13_3: u32 = 130300;
pub const __TVOS_13_4: u32 = 130400;
pub const __TVOS_14_0: u32 = 140000;
pub const __TVOS_14_1: u32 = 140100;
pub const __TVOS_14_2: u32 = 140200;
pub const __TVOS_14_3: u32 = 140300;
pub const __TVOS_14_5: u32 = 140500;
pub const __TVOS_14_6: u32 = 140600;
pub const __TVOS_14_7: u32 = 140700;
pub const __TVOS_15_0: u32 = 150000;
pub const __TVOS_15_1: u32 = 150100;
pub const __TVOS_15_2: u32 = 150200;
pub const __TVOS_15_3: u32 = 150300;
pub const __TVOS_15_4: u32 = 150400;
pub const __TVOS_15_5: u32 = 150500;
pub const __TVOS_15_6: u32 = 150600;
pub const __TVOS_16_0: u32 = 160000;
pub const __TVOS_16_1: u32 = 160100;
pub const __TVOS_16_2: u32 = 160200;
pub const __TVOS_16_3: u32 = 160300;
pub const __TVOS_16_4: u32 = 160400;
pub const __TVOS_16_5: u32 = 160500;
pub const __TVOS_16_6: u32 = 160600;
pub const __TVOS_17_0: u32 = 170000;
pub const __TVOS_17_1: u32 = 170100;
pub const __TVOS_17_2: u32 = 170200;
pub const __TVOS_17_3: u32 = 170300;
pub const __TVOS_17_4: u32 = 170400;
pub const __TVOS_17_5: u32 = 170500;
pub const __BRIDGEOS_2_0: u32 = 20000;
pub const __BRIDGEOS_3_0: u32 = 30000;
pub const __BRIDGEOS_3_1: u32 = 30100;
pub const __BRIDGEOS_3_4: u32 = 30400;
pub const __BRIDGEOS_4_0: u32 = 40000;
pub const __BRIDGEOS_4_1: u32 = 40100;
pub const __BRIDGEOS_5_0: u32 = 50000;
pub const __BRIDGEOS_5_1: u32 = 50100;
pub const __BRIDGEOS_5_3: u32 = 50300;
pub const __BRIDGEOS_6_0: u32 = 60000;
pub const __BRIDGEOS_6_2: u32 = 60200;
pub const __BRIDGEOS_6_4: u32 = 60400;
pub const __BRIDGEOS_6_5: u32 = 60500;
pub const __BRIDGEOS_6_6: u32 = 60600;
pub const __BRIDGEOS_7_0: u32 = 70000;
pub const __BRIDGEOS_7_1: u32 = 70100;
pub const __BRIDGEOS_7_2: u32 = 70200;
pub const __BRIDGEOS_7_3: u32 = 70300;
pub const __BRIDGEOS_7_4: u32 = 70400;
pub const __BRIDGEOS_7_6: u32 = 70600;
pub const __BRIDGEOS_8_0: u32 = 80000;
pub const __BRIDGEOS_8_1: u32 = 80100;
pub const __BRIDGEOS_8_2: u32 = 80200;
pub const __BRIDGEOS_8_3: u32 = 80300;
pub const __BRIDGEOS_8_4: u32 = 80400;
pub const __BRIDGEOS_8_5: u32 = 80500;
pub const __DRIVERKIT_19_0: u32 = 190000;
pub const __DRIVERKIT_20_0: u32 = 200000;
pub const __DRIVERKIT_21_0: u32 = 210000;
pub const __DRIVERKIT_22_0: u32 = 220000;
pub const __DRIVERKIT_22_4: u32 = 220400;
pub const __DRIVERKIT_22_5: u32 = 220500;
pub const __DRIVERKIT_22_6: u32 = 220600;
pub const __DRIVERKIT_23_0: u32 = 230000;
pub const __DRIVERKIT_23_1: u32 = 230100;
pub const __DRIVERKIT_23_2: u32 = 230200;
pub const __DRIVERKIT_23_3: u32 = 230300;
pub const __DRIVERKIT_23_4: u32 = 230400;
pub const __DRIVERKIT_23_5: u32 = 230500;
pub const __VISIONOS_1_0: u32 = 10000;
pub const __VISIONOS_1_1: u32 = 10100;
pub const __VISIONOS_1_2: u32 = 10200;
pub const MAC_OS_X_VERSION_10_0: u32 = 1000;
pub const MAC_OS_X_VERSION_10_1: u32 = 1010;
pub const MAC_OS_X_VERSION_10_2: u32 = 1020;
pub const MAC_OS_X_VERSION_10_3: u32 = 1030;
pub const MAC_OS_X_VERSION_10_4: u32 = 1040;
pub const MAC_OS_X_VERSION_10_5: u32 = 1050;
pub const MAC_OS_X_VERSION_10_6: u32 = 1060;
pub const MAC_OS_X_VERSION_10_7: u32 = 1070;
pub const MAC_OS_X_VERSION_10_8: u32 = 1080;
pub const MAC_OS_X_VERSION_10_9: u32 = 1090;
pub const MAC_OS_X_VERSION_10_10: u32 = 101000;
pub const MAC_OS_X_VERSION_10_10_2: u32 = 101002;
pub const MAC_OS_X_VERSION_10_10_3: u32 = 101003;
pub const MAC_OS_X_VERSION_10_11: u32 = 101100;
pub const MAC_OS_X_VERSION_10_11_2: u32 = 101102;
pub const MAC_OS_X_VERSION_10_11_3: u32 = 101103;
pub const MAC_OS_X_VERSION_10_11_4: u32 = 101104;
pub const MAC_OS_X_VERSION_10_12: u32 = 101200;
pub const MAC_OS_X_VERSION_10_12_1: u32 = 101201;
pub const MAC_OS_X_VERSION_10_12_2: u32 = 101202;
pub const MAC_OS_X_VERSION_10_12_4: u32 = 101204;
pub const MAC_OS_X_VERSION_10_13: u32 = 101300;
pub const MAC_OS_X_VERSION_10_13_1: u32 = 101301;
pub const MAC_OS_X_VERSION_10_13_2: u32 = 101302;
pub const MAC_OS_X_VERSION_10_13_4: u32 = 101304;
pub const MAC_OS_X_VERSION_10_14: u32 = 101400;
pub const MAC_OS_X_VERSION_10_14_1: u32 = 101401;
pub const MAC_OS_X_VERSION_10_14_4: u32 = 101404;
pub const MAC_OS_X_VERSION_10_14_5: u32 = 101405;
pub const MAC_OS_X_VERSION_10_14_6: u32 = 101406;
pub const MAC_OS_X_VERSION_10_15: u32 = 101500;
pub const MAC_OS_X_VERSION_10_15_1: u32 = 101501;
pub const MAC_OS_X_VERSION_10_15_4: u32 = 101504;
pub const MAC_OS_X_VERSION_10_16: u32 = 101600;
pub const MAC_OS_VERSION_11_0: u32 = 110000;
pub const MAC_OS_VERSION_11_1: u32 = 110100;
pub const MAC_OS_VERSION_11_3: u32 = 110300;
pub const MAC_OS_VERSION_11_4: u32 = 110400;
pub const MAC_OS_VERSION_11_5: u32 = 110500;
pub const MAC_OS_VERSION_11_6: u32 = 110600;
pub const MAC_OS_VERSION_12_0: u32 = 120000;
pub const MAC_OS_VERSION_12_1: u32 = 120100;
pub const MAC_OS_VERSION_12_2: u32 = 120200;
pub const MAC_OS_VERSION_12_3: u32 = 120300;
pub const MAC_OS_VERSION_12_4: u32 = 120400;
pub const MAC_OS_VERSION_12_5: u32 = 120500;
pub const MAC_OS_VERSION_12_6: u32 = 120600;
pub const MAC_OS_VERSION_12_7: u32 = 120700;
pub const MAC_OS_VERSION_13_0: u32 = 130000;
pub const MAC_OS_VERSION_13_1: u32 = 130100;
pub const MAC_OS_VERSION_13_2: u32 = 130200;
pub const MAC_OS_VERSION_13_3: u32 = 130300;
pub const MAC_OS_VERSION_13_4: u32 = 130400;
pub const MAC_OS_VERSION_13_5: u32 = 130500;
pub const MAC_OS_VERSION_13_6: u32 = 130600;
pub const MAC_OS_VERSION_14_0: u32 = 140000;
pub const MAC_OS_VERSION_14_1: u32 = 140100;
pub const MAC_OS_VERSION_14_2: u32 = 140200;
pub const MAC_OS_VERSION_14_3: u32 = 140300;
pub const MAC_OS_VERSION_14_4: u32 = 140400;
pub const MAC_OS_VERSION_14_5: u32 = 140500;
pub const __MAC_OS_X_VERSION_MAX_ALLOWED: u32 = 140500;
pub const __ENABLE_LEGACY_MAC_AVAILABILITY: u32 = 1;
pub const __PTHREAD_SIZE__: u32 = 8176;
pub const __PTHREAD_ATTR_SIZE__: u32 = 56;
pub const __PTHREAD_MUTEXATTR_SIZE__: u32 = 8;
pub const __PTHREAD_MUTEX_SIZE__: u32 = 56;
pub const __PTHREAD_CONDATTR_SIZE__: u32 = 8;
pub const __PTHREAD_COND_SIZE__: u32 = 40;
pub const __PTHREAD_ONCE_SIZE__: u32 = 8;
pub const __PTHREAD_RWLOCK_SIZE__: u32 = 192;
pub const __PTHREAD_RWLOCKATTR_SIZE__: u32 = 16;
pub const __DARWIN_WCHAR_MIN: i32 = -2147483648;
pub const _FORTIFY_SOURCE: u32 = 2;
pub const __WORDSIZE: u32 = 64;
pub const INT8_MAX: u32 = 127;
pub const INT16_MAX: u32 = 32767;
pub const INT32_MAX: u32 = 2147483647;
pub const INT64_MAX: u64 = 9223372036854775807;
pub const INT8_MIN: i32 = -128;
pub const INT16_MIN: i32 = -32768;
pub const INT32_MIN: i32 = -2147483648;
pub const INT64_MIN: i64 = -9223372036854775808;
pub const UINT8_MAX: u32 = 255;
pub const UINT16_MAX: u32 = 65535;
pub const UINT32_MAX: u32 = 4294967295;
pub const UINT64_MAX: i32 = -1;
pub const INT_LEAST8_MIN: i32 = -128;
pub const INT_LEAST16_MIN: i32 = -32768;
pub const INT_LEAST32_MIN: i32 = -2147483648;
pub const INT_LEAST64_MIN: i64 = -9223372036854775808;
pub const INT_LEAST8_MAX: u32 = 127;
pub const INT_LEAST16_MAX: u32 = 32767;
pub const INT_LEAST32_MAX: u32 = 2147483647;
pub const INT_LEAST64_MAX: u64 = 9223372036854775807;
pub const UINT_LEAST8_MAX: u32 = 255;
pub const UINT_LEAST16_MAX: u32 = 65535;
pub const UINT_LEAST32_MAX: u32 = 4294967295;
pub const UINT_LEAST64_MAX: i32 = -1;
pub const INT_FAST8_MIN: i32 = -128;
pub const INT_FAST16_MIN: i32 = -32768;
pub const INT_FAST32_MIN: i32 = -2147483648;
pub const INT_FAST64_MIN: i64 = -9223372036854775808;
pub const INT_FAST8_MAX: u32 = 127;
pub const INT_FAST16_MAX: u32 = 32767;
pub const INT_FAST32_MAX: u32 = 2147483647;
pub const INT_FAST64_MAX: u64 = 9223372036854775807;
pub const UINT_FAST8_MAX: u32 = 255;
pub const UINT_FAST16_MAX: u32 = 65535;
pub const UINT_FAST32_MAX: u32 = 4294967295;
pub const UINT_FAST64_MAX: i32 = -1;
pub const INTPTR_MAX: u64 = 9223372036854775807;
pub const INTPTR_MIN: i64 = -9223372036854775808;
pub const UINTPTR_MAX: i32 = -1;
pub const SIZE_MAX: i32 = -1;
pub const RSIZE_MAX: i32 = -1;
pub const WINT_MIN: i32 = -2147483648;
pub const WINT_MAX: u32 = 2147483647;
pub const SIG_ATOMIC_MIN: i32 = -2147483648;
pub const SIG_ATOMIC_MAX: u32 = 2147483647;
pub const HB_FEATURE_GLOBAL_START: u32 = 0;
pub const HB_UNICODE_MAX: u32 = 1114111;
pub const HB_FONT_NO_VAR_NAMED_INSTANCE: u32 = 4294967295;
pub const HB_BUFFER_REPLACEMENT_CODEPOINT_DEFAULT: u32 = 65533;
pub const HB_UNICODE_COMBINING_CLASS_CCC133: u32 = 133;
pub const HB_UNICODE_MAX_DECOMPOSITION_LEN: u32 = 19;
pub const HB_VERSION_MAJOR: u32 = 9;
pub const HB_VERSION_MINOR: u32 = 0;
pub const HB_VERSION_MICRO: u32 = 0;
pub const HB_VERSION_STRING: &[u8; 6] = b"9.0.0\0";
pub type __int8_t = ::std::os::raw::c_schar;
pub type __uint8_t = ::std::os::raw::c_uchar;
pub type __int16_t = ::std::os::raw::c_short;
pub type __uint16_t = ::std::os::raw::c_ushort;
pub type __int32_t = ::std::os::raw::c_int;
pub type __uint32_t = ::std::os::raw::c_uint;
pub type __int64_t = ::std::os::raw::c_longlong;
pub type __uint64_t = ::std::os::raw::c_ulonglong;
pub type __darwin_intptr_t = ::std::os::raw::c_long;
pub type __darwin_natural_t = ::std::os::raw::c_uint;
pub type __darwin_ct_rune_t = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Copy, Clone)]
pub union __mbstate_t {
    pub __mbstate8: [::std::os::raw::c_char; 128usize],
    pub _mbstateL: ::std::os::raw::c_longlong,
}
#[test]
fn bindgen_test_layout___mbstate_t() {
    const UNINIT: ::std::mem::MaybeUninit<__mbstate_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<__mbstate_t>(),
        128usize,
        concat!("Size of: ", stringify!(__mbstate_t))
    );
    assert_eq!(
        ::std::mem::align_of::<__mbstate_t>(),
        8usize,
        concat!("Alignment of ", stringify!(__mbstate_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__mbstate8) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__mbstate_t),
            "::",
            stringify!(__mbstate8)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._mbstateL) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__mbstate_t),
            "::",
            stringify!(_mbstateL)
        )
    );
}
pub type __darwin_mbstate_t = __mbstate_t;
pub type __darwin_ptrdiff_t = ::std::os::raw::c_long;
pub type __darwin_size_t = ::std::os::raw::c_ulong;
pub type __darwin_va_list = __builtin_va_list;
pub type __darwin_wchar_t = ::std::os::raw::c_int;
pub type __darwin_rune_t = __darwin_wchar_t;
pub type __darwin_wint_t = ::std::os::raw::c_int;
pub type __darwin_clock_t = ::std::os::raw::c_ulong;
pub type __darwin_socklen_t = __uint32_t;
pub type __darwin_ssize_t = ::std::os::raw::c_long;
pub type __darwin_time_t = ::std::os::raw::c_long;
pub type __darwin_blkcnt_t = __int64_t;
pub type __darwin_blksize_t = __int32_t;
pub type __darwin_dev_t = __int32_t;
pub type __darwin_fsblkcnt_t = ::std::os::raw::c_uint;
pub type __darwin_fsfilcnt_t = ::std::os::raw::c_uint;
pub type __darwin_gid_t = __uint32_t;
pub type __darwin_id_t = __uint32_t;
pub type __darwin_ino64_t = __uint64_t;
pub type __darwin_ino_t = __darwin_ino64_t;
pub type __darwin_mach_port_name_t = __darwin_natural_t;
pub type __darwin_mach_port_t = __darwin_mach_port_name_t;
pub type __darwin_mode_t = __uint16_t;
pub type __darwin_off_t = __int64_t;
pub type __darwin_pid_t = __int32_t;
pub type __darwin_sigset_t = __uint32_t;
pub type __darwin_suseconds_t = __int32_t;
pub type __darwin_uid_t = __uint32_t;
pub type __darwin_useconds_t = __uint32_t;
pub type __darwin_uuid_t = [::std::os::raw::c_uchar; 16usize];
pub type __darwin_uuid_string_t = [::std::os::raw::c_char; 37usize];
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __darwin_pthread_handler_rec {
    pub __routine: ::std::option::Option<unsafe extern "C" fn(arg1: *mut ::std::os::raw::c_void)>,
    pub __arg: *mut ::std::os::raw::c_void,
    pub __next: *mut __darwin_pthread_handler_rec,
}
#[test]
fn bindgen_test_layout___darwin_pthread_handler_rec() {
    const UNINIT: ::std::mem::MaybeUninit<__darwin_pthread_handler_rec> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<__darwin_pthread_handler_rec>(),
        24usize,
        concat!("Size of: ", stringify!(__darwin_pthread_handler_rec))
    );
    assert_eq!(
        ::std::mem::align_of::<__darwin_pthread_handler_rec>(),
        8usize,
        concat!("Alignment of ", stringify!(__darwin_pthread_handler_rec))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__routine) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_pthread_handler_rec),
            "::",
            stringify!(__routine)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__arg) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_pthread_handler_rec),
            "::",
            stringify!(__arg)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__next) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_pthread_handler_rec),
            "::",
            stringify!(__next)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _opaque_pthread_attr_t {
    pub __sig: ::std::os::raw::c_long,
    pub __opaque: [::std::os::raw::c_char; 56usize],
}
#[test]
fn bindgen_test_layout__opaque_pthread_attr_t() {
    const UNINIT: ::std::mem::MaybeUninit<_opaque_pthread_attr_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_opaque_pthread_attr_t>(),
        64usize,
        concat!("Size of: ", stringify!(_opaque_pthread_attr_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_opaque_pthread_attr_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_opaque_pthread_attr_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__sig) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_opaque_pthread_attr_t),
            "::",
            stringify!(__sig)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__opaque) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_opaque_pthread_attr_t),
            "::",
            stringify!(__opaque)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _opaque_pthread_cond_t {
    pub __sig: ::std::os::raw::c_long,
    pub __opaque: [::std::os::raw::c_char; 40usize],
}
#[test]
fn bindgen_test_layout__opaque_pthread_cond_t() {
    const UNINIT: ::std::mem::MaybeUninit<_opaque_pthread_cond_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_opaque_pthread_cond_t>(),
        48usize,
        concat!("Size of: ", stringify!(_opaque_pthread_cond_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_opaque_pthread_cond_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_opaque_pthread_cond_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__sig) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_opaque_pthread_cond_t),
            "::",
            stringify!(__sig)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__opaque) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_opaque_pthread_cond_t),
            "::",
            stringify!(__opaque)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _opaque_pthread_condattr_t {
    pub __sig: ::std::os::raw::c_long,
    pub __opaque: [::std::os::raw::c_char; 8usize],
}
#[test]
fn bindgen_test_layout__opaque_pthread_condattr_t() {
    const UNINIT: ::std::mem::MaybeUninit<_opaque_pthread_condattr_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_opaque_pthread_condattr_t>(),
        16usize,
        concat!("Size of: ", stringify!(_opaque_pthread_condattr_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_opaque_pthread_condattr_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_opaque_pthread_condattr_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__sig) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_opaque_pthread_condattr_t),
            "::",
            stringify!(__sig)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__opaque) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_opaque_pthread_condattr_t),
            "::",
            stringify!(__opaque)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _opaque_pthread_mutex_t {
    pub __sig: ::std::os::raw::c_long,
    pub __opaque: [::std::os::raw::c_char; 56usize],
}
#[test]
fn bindgen_test_layout__opaque_pthread_mutex_t() {
    const UNINIT: ::std::mem::MaybeUninit<_opaque_pthread_mutex_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_opaque_pthread_mutex_t>(),
        64usize,
        concat!("Size of: ", stringify!(_opaque_pthread_mutex_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_opaque_pthread_mutex_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_opaque_pthread_mutex_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__sig) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_opaque_pthread_mutex_t),
            "::",
            stringify!(__sig)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__opaque) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_opaque_pthread_mutex_t),
            "::",
            stringify!(__opaque)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _opaque_pthread_mutexattr_t {
    pub __sig: ::std::os::raw::c_long,
    pub __opaque: [::std::os::raw::c_char; 8usize],
}
#[test]
fn bindgen_test_layout__opaque_pthread_mutexattr_t() {
    const UNINIT: ::std::mem::MaybeUninit<_opaque_pthread_mutexattr_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_opaque_pthread_mutexattr_t>(),
        16usize,
        concat!("Size of: ", stringify!(_opaque_pthread_mutexattr_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_opaque_pthread_mutexattr_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_opaque_pthread_mutexattr_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__sig) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_opaque_pthread_mutexattr_t),
            "::",
            stringify!(__sig)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__opaque) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_opaque_pthread_mutexattr_t),
            "::",
            stringify!(__opaque)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _opaque_pthread_once_t {
    pub __sig: ::std::os::raw::c_long,
    pub __opaque: [::std::os::raw::c_char; 8usize],
}
#[test]
fn bindgen_test_layout__opaque_pthread_once_t() {
    const UNINIT: ::std::mem::MaybeUninit<_opaque_pthread_once_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_opaque_pthread_once_t>(),
        16usize,
        concat!("Size of: ", stringify!(_opaque_pthread_once_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_opaque_pthread_once_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_opaque_pthread_once_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__sig) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_opaque_pthread_once_t),
            "::",
            stringify!(__sig)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__opaque) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_opaque_pthread_once_t),
            "::",
            stringify!(__opaque)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _opaque_pthread_rwlock_t {
    pub __sig: ::std::os::raw::c_long,
    pub __opaque: [::std::os::raw::c_char; 192usize],
}
#[test]
fn bindgen_test_layout__opaque_pthread_rwlock_t() {
    const UNINIT: ::std::mem::MaybeUninit<_opaque_pthread_rwlock_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_opaque_pthread_rwlock_t>(),
        200usize,
        concat!("Size of: ", stringify!(_opaque_pthread_rwlock_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_opaque_pthread_rwlock_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_opaque_pthread_rwlock_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__sig) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_opaque_pthread_rwlock_t),
            "::",
            stringify!(__sig)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__opaque) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_opaque_pthread_rwlock_t),
            "::",
            stringify!(__opaque)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _opaque_pthread_rwlockattr_t {
    pub __sig: ::std::os::raw::c_long,
    pub __opaque: [::std::os::raw::c_char; 16usize],
}
#[test]
fn bindgen_test_layout__opaque_pthread_rwlockattr_t() {
    const UNINIT: ::std::mem::MaybeUninit<_opaque_pthread_rwlockattr_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_opaque_pthread_rwlockattr_t>(),
        24usize,
        concat!("Size of: ", stringify!(_opaque_pthread_rwlockattr_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_opaque_pthread_rwlockattr_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_opaque_pthread_rwlockattr_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__sig) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_opaque_pthread_rwlockattr_t),
            "::",
            stringify!(__sig)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__opaque) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_opaque_pthread_rwlockattr_t),
            "::",
            stringify!(__opaque)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _opaque_pthread_t {
    pub __sig: ::std::os::raw::c_long,
    pub __cleanup_stack: *mut __darwin_pthread_handler_rec,
    pub __opaque: [::std::os::raw::c_char; 8176usize],
}
#[test]
fn bindgen_test_layout__opaque_pthread_t() {
    const UNINIT: ::std::mem::MaybeUninit<_opaque_pthread_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_opaque_pthread_t>(),
        8192usize,
        concat!("Size of: ", stringify!(_opaque_pthread_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_opaque_pthread_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_opaque_pthread_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__sig) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_opaque_pthread_t),
            "::",
            stringify!(__sig)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__cleanup_stack) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_opaque_pthread_t),
            "::",
            stringify!(__cleanup_stack)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__opaque) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_opaque_pthread_t),
            "::",
            stringify!(__opaque)
        )
    );
}
pub type __darwin_pthread_attr_t = _opaque_pthread_attr_t;
pub type __darwin_pthread_cond_t = _opaque_pthread_cond_t;
pub type __darwin_pthread_condattr_t = _opaque_pthread_condattr_t;
pub type __darwin_pthread_key_t = ::std::os::raw::c_ulong;
pub type __darwin_pthread_mutex_t = _opaque_pthread_mutex_t;
pub type __darwin_pthread_mutexattr_t = _opaque_pthread_mutexattr_t;
pub type __darwin_pthread_once_t = _opaque_pthread_once_t;
pub type __darwin_pthread_rwlock_t = _opaque_pthread_rwlock_t;
pub type __darwin_pthread_rwlockattr_t = _opaque_pthread_rwlockattr_t;
pub type __darwin_pthread_t = *mut _opaque_pthread_t;
pub type __darwin_nl_item = ::std::os::raw::c_int;
pub type __darwin_wctrans_t = ::std::os::raw::c_int;
pub type __darwin_wctype_t = __uint32_t;
pub type wchar_t = __darwin_wchar_t;
pub type int_least8_t = i8;
pub type int_least16_t = i16;
pub type int_least32_t = i32;
pub type int_least64_t = i64;
pub type uint_least8_t = u8;
pub type uint_least16_t = u16;
pub type uint_least32_t = u32;
pub type uint_least64_t = u64;
pub type int_fast8_t = i8;
pub type int_fast16_t = i16;
pub type int_fast32_t = i32;
pub type int_fast64_t = i64;
pub type uint_fast8_t = u8;
pub type uint_fast16_t = u16;
pub type uint_fast32_t = u32;
pub type uint_fast64_t = u64;
pub type u_int8_t = ::std::os::raw::c_uchar;
pub type u_int16_t = ::std::os::raw::c_ushort;
pub type u_int32_t = ::std::os::raw::c_uint;
pub type u_int64_t = ::std::os::raw::c_ulonglong;
pub type register_t = i64;
pub type user_addr_t = u_int64_t;
pub type user_size_t = u_int64_t;
pub type user_ssize_t = i64;
pub type user_long_t = i64;
pub type user_ulong_t = u_int64_t;
pub type user_time_t = i64;
pub type user_off_t = i64;
pub type syscall_arg_t = u_int64_t;
pub type intmax_t = ::std::os::raw::c_long;
pub type uintmax_t = ::std::os::raw::c_ulong;
extern "C" {
    pub fn imaxabs(j: intmax_t) -> intmax_t;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct imaxdiv_t {
    pub quot: intmax_t,
    pub rem: intmax_t,
}
#[test]
fn bindgen_test_layout_imaxdiv_t() {
    const UNINIT: ::std::mem::MaybeUninit<imaxdiv_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<imaxdiv_t>(),
        16usize,
        concat!("Size of: ", stringify!(imaxdiv_t))
    );
    assert_eq!(
        ::std::mem::align_of::<imaxdiv_t>(),
        8usize,
        concat!("Alignment of ", stringify!(imaxdiv_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).quot) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(imaxdiv_t),
            "::",
            stringify!(quot)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).rem) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(imaxdiv_t),
            "::",
            stringify!(rem)
        )
    );
}
extern "C" {
    pub fn imaxdiv(__numer: intmax_t, __denom: intmax_t) -> imaxdiv_t;
}
extern "C" {
    pub fn strtoimax(
        __nptr: *const ::std::os::raw::c_char,
        __endptr: *mut *mut ::std::os::raw::c_char,
        __base: ::std::os::raw::c_int,
    ) -> intmax_t;
}
extern "C" {
    pub fn strtoumax(
        __nptr: *const ::std::os::raw::c_char,
        __endptr: *mut *mut ::std::os::raw::c_char,
        __base: ::std::os::raw::c_int,
    ) -> uintmax_t;
}
extern "C" {
    pub fn wcstoimax(
        __nptr: *const wchar_t,
        __endptr: *mut *mut wchar_t,
        __base: ::std::os::raw::c_int,
    ) -> intmax_t;
}
extern "C" {
    pub fn wcstoumax(
        __nptr: *const wchar_t,
        __endptr: *mut *mut wchar_t,
        __base: ::std::os::raw::c_int,
    ) -> uintmax_t;
}
#[doc = " hb_bool_t:\n\n Data type for booleans.\n"]
pub type hb_bool_t = ::std::os::raw::c_int;
#[doc = " hb_codepoint_t:\n\n Data type for holding Unicode codepoints. Also\n used to hold glyph IDs.\n"]
pub type hb_codepoint_t = u32;
#[doc = " hb_position_t:\n\n Data type for holding a single coordinate value.\n Contour points and other multi-dimensional data are\n stored as tuples of #hb_position_t's.\n"]
pub type hb_position_t = i32;
#[doc = " hb_mask_t:\n\n Data type for bitmasks.\n"]
pub type hb_mask_t = u32;
#[repr(C)]
#[derive(Copy, Clone)]
pub union _hb_var_int_t {
    pub u32_: u32,
    pub i32_: i32,
    pub u16_: [u16; 2usize],
    pub i16_: [i16; 2usize],
    pub u8_: [u8; 4usize],
    pub i8_: [i8; 4usize],
}
#[test]
fn bindgen_test_layout__hb_var_int_t() {
    const UNINIT: ::std::mem::MaybeUninit<_hb_var_int_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_hb_var_int_t>(),
        4usize,
        concat!("Size of: ", stringify!(_hb_var_int_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_hb_var_int_t>(),
        4usize,
        concat!("Alignment of ", stringify!(_hb_var_int_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).u32_) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_hb_var_int_t),
            "::",
            stringify!(u32_)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).i32_) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_hb_var_int_t),
            "::",
            stringify!(i32_)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).u16_) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_hb_var_int_t),
            "::",
            stringify!(u16_)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).i16_) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_hb_var_int_t),
            "::",
            stringify!(i16_)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).u8_) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_hb_var_int_t),
            "::",
            stringify!(u8_)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).i8_) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_hb_var_int_t),
            "::",
            stringify!(i8_)
        )
    );
}
pub type hb_var_int_t = _hb_var_int_t;
#[repr(C)]
#[derive(Copy, Clone)]
pub union _hb_var_num_t {
    pub f: f32,
    pub u32_: u32,
    pub i32_: i32,
    pub u16_: [u16; 2usize],
    pub i16_: [i16; 2usize],
    pub u8_: [u8; 4usize],
    pub i8_: [i8; 4usize],
}
#[test]
fn bindgen_test_layout__hb_var_num_t() {
    const UNINIT: ::std::mem::MaybeUninit<_hb_var_num_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_hb_var_num_t>(),
        4usize,
        concat!("Size of: ", stringify!(_hb_var_num_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_hb_var_num_t>(),
        4usize,
        concat!("Alignment of ", stringify!(_hb_var_num_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).f) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_hb_var_num_t),
            "::",
            stringify!(f)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).u32_) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_hb_var_num_t),
            "::",
            stringify!(u32_)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).i32_) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_hb_var_num_t),
            "::",
            stringify!(i32_)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).u16_) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_hb_var_num_t),
            "::",
            stringify!(u16_)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).i16_) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_hb_var_num_t),
            "::",
            stringify!(i16_)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).u8_) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_hb_var_num_t),
            "::",
            stringify!(u8_)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).i8_) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_hb_var_num_t),
            "::",
            stringify!(i8_)
        )
    );
}
pub type hb_var_num_t = _hb_var_num_t;
#[doc = " hb_tag_t:\n\n Data type for tag identifiers. Tags are four\n byte integers, each byte representing a character.\n\n Tags are used to identify tables, design-variation axes,\n scripts, languages, font features, and baselines with\n human-readable names.\n"]
pub type hb_tag_t = u32;
extern "C" {
    pub fn hb_tag_from_string(
        str_: *const ::std::os::raw::c_char,
        len: ::std::os::raw::c_int,
    ) -> hb_tag_t;
}
extern "C" {
    pub fn hb_tag_to_string(tag: hb_tag_t, buf: *mut ::std::os::raw::c_char);
}
pub const hb_direction_t_HB_DIRECTION_INVALID: hb_direction_t = 0;
pub const hb_direction_t_HB_DIRECTION_LTR: hb_direction_t = 4;
pub const hb_direction_t_HB_DIRECTION_RTL: hb_direction_t = 5;
pub const hb_direction_t_HB_DIRECTION_TTB: hb_direction_t = 6;
pub const hb_direction_t_HB_DIRECTION_BTT: hb_direction_t = 7;
#[doc = " hb_direction_t:\n @HB_DIRECTION_INVALID: Initial, unset direction.\n @HB_DIRECTION_LTR: Text is set horizontally from left to right.\n @HB_DIRECTION_RTL: Text is set horizontally from right to left.\n @HB_DIRECTION_TTB: Text is set vertically from top to bottom.\n @HB_DIRECTION_BTT: Text is set vertically from bottom to top.\n\n The direction of a text segment or buffer.\n\n A segment can also be tested for horizontal or vertical\n orientation (irrespective of specific direction) with\n HB_DIRECTION_IS_HORIZONTAL() or HB_DIRECTION_IS_VERTICAL().\n"]
pub type hb_direction_t = ::std::os::raw::c_uint;
extern "C" {
    pub fn hb_direction_from_string(
        str_: *const ::std::os::raw::c_char,
        len: ::std::os::raw::c_int,
    ) -> hb_direction_t;
}
extern "C" {
    pub fn hb_direction_to_string(direction: hb_direction_t) -> *const ::std::os::raw::c_char;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct hb_language_impl_t {
    _unused: [u8; 0],
}
#[doc = " hb_language_t:\n\n Data type for languages. Each #hb_language_t corresponds to a BCP 47\n language tag.\n"]
pub type hb_language_t = *const hb_language_impl_t;
extern "C" {
    pub fn hb_language_from_string(
        str_: *const ::std::os::raw::c_char,
        len: ::std::os::raw::c_int,
    ) -> hb_language_t;
}
extern "C" {
    pub fn hb_language_to_string(language: hb_language_t) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn hb_language_get_default() -> hb_language_t;
}
extern "C" {
    pub fn hb_language_matches(language: hb_language_t, specific: hb_language_t) -> hb_bool_t;
}
pub const hb_script_t_HB_SCRIPT_COMMON: hb_script_t = 1517910393;
pub const hb_script_t_HB_SCRIPT_INHERITED: hb_script_t = 1516858984;
pub const hb_script_t_HB_SCRIPT_UNKNOWN: hb_script_t = 1517976186;
pub const hb_script_t_HB_SCRIPT_ARABIC: hb_script_t = 1098015074;
pub const hb_script_t_HB_SCRIPT_ARMENIAN: hb_script_t = 1098018158;
pub const hb_script_t_HB_SCRIPT_BENGALI: hb_script_t = 1113943655;
pub const hb_script_t_HB_SCRIPT_CYRILLIC: hb_script_t = 1132032620;
pub const hb_script_t_HB_SCRIPT_DEVANAGARI: hb_script_t = 1147500129;
pub const hb_script_t_HB_SCRIPT_GEORGIAN: hb_script_t = 1197830002;
pub const hb_script_t_HB_SCRIPT_GREEK: hb_script_t = 1198679403;
pub const hb_script_t_HB_SCRIPT_GUJARATI: hb_script_t = 1198877298;
pub const hb_script_t_HB_SCRIPT_GURMUKHI: hb_script_t = 1198879349;
pub const hb_script_t_HB_SCRIPT_HANGUL: hb_script_t = 1214344807;
pub const hb_script_t_HB_SCRIPT_HAN: hb_script_t = 1214344809;
pub const hb_script_t_HB_SCRIPT_HEBREW: hb_script_t = 1214603890;
pub const hb_script_t_HB_SCRIPT_HIRAGANA: hb_script_t = 1214870113;
pub const hb_script_t_HB_SCRIPT_KANNADA: hb_script_t = 1265525857;
pub const hb_script_t_HB_SCRIPT_KATAKANA: hb_script_t = 1264676449;
pub const hb_script_t_HB_SCRIPT_LAO: hb_script_t = 1281453935;
pub const hb_script_t_HB_SCRIPT_LATIN: hb_script_t = 1281455214;
pub const hb_script_t_HB_SCRIPT_MALAYALAM: hb_script_t = 1298954605;
pub const hb_script_t_HB_SCRIPT_ORIYA: hb_script_t = 1332902241;
pub const hb_script_t_HB_SCRIPT_TAMIL: hb_script_t = 1415671148;
pub const hb_script_t_HB_SCRIPT_TELUGU: hb_script_t = 1415933045;
pub const hb_script_t_HB_SCRIPT_THAI: hb_script_t = 1416126825;
pub const hb_script_t_HB_SCRIPT_TIBETAN: hb_script_t = 1416192628;
pub const hb_script_t_HB_SCRIPT_BOPOMOFO: hb_script_t = 1114599535;
pub const hb_script_t_HB_SCRIPT_BRAILLE: hb_script_t = 1114792297;
pub const hb_script_t_HB_SCRIPT_CANADIAN_SYLLABICS: hb_script_t = 1130458739;
pub const hb_script_t_HB_SCRIPT_CHEROKEE: hb_script_t = 1130915186;
pub const hb_script_t_HB_SCRIPT_ETHIOPIC: hb_script_t = 1165256809;
pub const hb_script_t_HB_SCRIPT_KHMER: hb_script_t = 1265134962;
pub const hb_script_t_HB_SCRIPT_MONGOLIAN: hb_script_t = 1299148391;
pub const hb_script_t_HB_SCRIPT_MYANMAR: hb_script_t = 1299803506;
pub const hb_script_t_HB_SCRIPT_OGHAM: hb_script_t = 1332175213;
pub const hb_script_t_HB_SCRIPT_RUNIC: hb_script_t = 1383427698;
pub const hb_script_t_HB_SCRIPT_SINHALA: hb_script_t = 1399418472;
pub const hb_script_t_HB_SCRIPT_SYRIAC: hb_script_t = 1400468067;
pub const hb_script_t_HB_SCRIPT_THAANA: hb_script_t = 1416126817;
pub const hb_script_t_HB_SCRIPT_YI: hb_script_t = 1500080489;
pub const hb_script_t_HB_SCRIPT_DESERET: hb_script_t = 1148416628;
pub const hb_script_t_HB_SCRIPT_GOTHIC: hb_script_t = 1198486632;
pub const hb_script_t_HB_SCRIPT_OLD_ITALIC: hb_script_t = 1232363884;
pub const hb_script_t_HB_SCRIPT_BUHID: hb_script_t = 1114990692;
pub const hb_script_t_HB_SCRIPT_HANUNOO: hb_script_t = 1214344815;
pub const hb_script_t_HB_SCRIPT_TAGALOG: hb_script_t = 1416064103;
pub const hb_script_t_HB_SCRIPT_TAGBANWA: hb_script_t = 1415669602;
pub const hb_script_t_HB_SCRIPT_CYPRIOT: hb_script_t = 1131442804;
pub const hb_script_t_HB_SCRIPT_LIMBU: hb_script_t = 1281977698;
pub const hb_script_t_HB_SCRIPT_LINEAR_B: hb_script_t = 1281977954;
pub const hb_script_t_HB_SCRIPT_OSMANYA: hb_script_t = 1332964705;
pub const hb_script_t_HB_SCRIPT_SHAVIAN: hb_script_t = 1399349623;
pub const hb_script_t_HB_SCRIPT_TAI_LE: hb_script_t = 1415670885;
pub const hb_script_t_HB_SCRIPT_UGARITIC: hb_script_t = 1432838514;
pub const hb_script_t_HB_SCRIPT_BUGINESE: hb_script_t = 1114990441;
pub const hb_script_t_HB_SCRIPT_COPTIC: hb_script_t = 1131376756;
pub const hb_script_t_HB_SCRIPT_GLAGOLITIC: hb_script_t = 1198285159;
pub const hb_script_t_HB_SCRIPT_KHAROSHTHI: hb_script_t = 1265131890;
pub const hb_script_t_HB_SCRIPT_NEW_TAI_LUE: hb_script_t = 1415670901;
pub const hb_script_t_HB_SCRIPT_OLD_PERSIAN: hb_script_t = 1483761007;
pub const hb_script_t_HB_SCRIPT_SYLOTI_NAGRI: hb_script_t = 1400466543;
pub const hb_script_t_HB_SCRIPT_TIFINAGH: hb_script_t = 1415999079;
pub const hb_script_t_HB_SCRIPT_BALINESE: hb_script_t = 1113681001;
pub const hb_script_t_HB_SCRIPT_CUNEIFORM: hb_script_t = 1483961720;
pub const hb_script_t_HB_SCRIPT_NKO: hb_script_t = 1315663727;
pub const hb_script_t_HB_SCRIPT_PHAGS_PA: hb_script_t = 1349017959;
pub const hb_script_t_HB_SCRIPT_PHOENICIAN: hb_script_t = 1349021304;
pub const hb_script_t_HB_SCRIPT_CARIAN: hb_script_t = 1130459753;
pub const hb_script_t_HB_SCRIPT_CHAM: hb_script_t = 1130914157;
pub const hb_script_t_HB_SCRIPT_KAYAH_LI: hb_script_t = 1264675945;
pub const hb_script_t_HB_SCRIPT_LEPCHA: hb_script_t = 1281716323;
pub const hb_script_t_HB_SCRIPT_LYCIAN: hb_script_t = 1283023721;
pub const hb_script_t_HB_SCRIPT_LYDIAN: hb_script_t = 1283023977;
pub const hb_script_t_HB_SCRIPT_OL_CHIKI: hb_script_t = 1332503403;
pub const hb_script_t_HB_SCRIPT_REJANG: hb_script_t = 1382706791;
pub const hb_script_t_HB_SCRIPT_SAURASHTRA: hb_script_t = 1398895986;
pub const hb_script_t_HB_SCRIPT_SUNDANESE: hb_script_t = 1400204900;
pub const hb_script_t_HB_SCRIPT_VAI: hb_script_t = 1449224553;
pub const hb_script_t_HB_SCRIPT_AVESTAN: hb_script_t = 1098281844;
pub const hb_script_t_HB_SCRIPT_BAMUM: hb_script_t = 1113681269;
pub const hb_script_t_HB_SCRIPT_EGYPTIAN_HIEROGLYPHS: hb_script_t = 1164409200;
pub const hb_script_t_HB_SCRIPT_IMPERIAL_ARAMAIC: hb_script_t = 1098018153;
pub const hb_script_t_HB_SCRIPT_INSCRIPTIONAL_PAHLAVI: hb_script_t = 1349020777;
pub const hb_script_t_HB_SCRIPT_INSCRIPTIONAL_PARTHIAN: hb_script_t = 1349678185;
pub const hb_script_t_HB_SCRIPT_JAVANESE: hb_script_t = 1247901281;
pub const hb_script_t_HB_SCRIPT_KAITHI: hb_script_t = 1265920105;
pub const hb_script_t_HB_SCRIPT_LISU: hb_script_t = 1281979253;
pub const hb_script_t_HB_SCRIPT_MEETEI_MAYEK: hb_script_t = 1299473769;
pub const hb_script_t_HB_SCRIPT_OLD_SOUTH_ARABIAN: hb_script_t = 1398895202;
pub const hb_script_t_HB_SCRIPT_OLD_TURKIC: hb_script_t = 1332898664;
pub const hb_script_t_HB_SCRIPT_SAMARITAN: hb_script_t = 1398893938;
pub const hb_script_t_HB_SCRIPT_TAI_THAM: hb_script_t = 1281453665;
pub const hb_script_t_HB_SCRIPT_TAI_VIET: hb_script_t = 1415673460;
pub const hb_script_t_HB_SCRIPT_BATAK: hb_script_t = 1113683051;
pub const hb_script_t_HB_SCRIPT_BRAHMI: hb_script_t = 1114792296;
pub const hb_script_t_HB_SCRIPT_MANDAIC: hb_script_t = 1298230884;
pub const hb_script_t_HB_SCRIPT_CHAKMA: hb_script_t = 1130457965;
pub const hb_script_t_HB_SCRIPT_MEROITIC_CURSIVE: hb_script_t = 1298494051;
pub const hb_script_t_HB_SCRIPT_MEROITIC_HIEROGLYPHS: hb_script_t = 1298494063;
pub const hb_script_t_HB_SCRIPT_MIAO: hb_script_t = 1349284452;
pub const hb_script_t_HB_SCRIPT_SHARADA: hb_script_t = 1399353956;
pub const hb_script_t_HB_SCRIPT_SORA_SOMPENG: hb_script_t = 1399812705;
pub const hb_script_t_HB_SCRIPT_TAKRI: hb_script_t = 1415670642;
pub const hb_script_t_HB_SCRIPT_BASSA_VAH: hb_script_t = 1113682803;
pub const hb_script_t_HB_SCRIPT_CAUCASIAN_ALBANIAN: hb_script_t = 1097295970;
pub const hb_script_t_HB_SCRIPT_DUPLOYAN: hb_script_t = 1148547180;
pub const hb_script_t_HB_SCRIPT_ELBASAN: hb_script_t = 1164730977;
pub const hb_script_t_HB_SCRIPT_GRANTHA: hb_script_t = 1198678382;
pub const hb_script_t_HB_SCRIPT_KHOJKI: hb_script_t = 1265135466;
pub const hb_script_t_HB_SCRIPT_KHUDAWADI: hb_script_t = 1399418468;
pub const hb_script_t_HB_SCRIPT_LINEAR_A: hb_script_t = 1281977953;
pub const hb_script_t_HB_SCRIPT_MAHAJANI: hb_script_t = 1298229354;
pub const hb_script_t_HB_SCRIPT_MANICHAEAN: hb_script_t = 1298230889;
pub const hb_script_t_HB_SCRIPT_MENDE_KIKAKUI: hb_script_t = 1298493028;
pub const hb_script_t_HB_SCRIPT_MODI: hb_script_t = 1299145833;
pub const hb_script_t_HB_SCRIPT_MRO: hb_script_t = 1299345263;
pub const hb_script_t_HB_SCRIPT_NABATAEAN: hb_script_t = 1315070324;
pub const hb_script_t_HB_SCRIPT_OLD_NORTH_ARABIAN: hb_script_t = 1315009122;
pub const hb_script_t_HB_SCRIPT_OLD_PERMIC: hb_script_t = 1348825709;
pub const hb_script_t_HB_SCRIPT_PAHAWH_HMONG: hb_script_t = 1215131239;
pub const hb_script_t_HB_SCRIPT_PALMYRENE: hb_script_t = 1348562029;
pub const hb_script_t_HB_SCRIPT_PAU_CIN_HAU: hb_script_t = 1348564323;
pub const hb_script_t_HB_SCRIPT_PSALTER_PAHLAVI: hb_script_t = 1349020784;
pub const hb_script_t_HB_SCRIPT_SIDDHAM: hb_script_t = 1399415908;
pub const hb_script_t_HB_SCRIPT_TIRHUTA: hb_script_t = 1416196712;
pub const hb_script_t_HB_SCRIPT_WARANG_CITI: hb_script_t = 1466004065;
pub const hb_script_t_HB_SCRIPT_AHOM: hb_script_t = 1097363309;
pub const hb_script_t_HB_SCRIPT_ANATOLIAN_HIEROGLYPHS: hb_script_t = 1215067511;
pub const hb_script_t_HB_SCRIPT_HATRAN: hb_script_t = 1214346354;
pub const hb_script_t_HB_SCRIPT_MULTANI: hb_script_t = 1299541108;
pub const hb_script_t_HB_SCRIPT_OLD_HUNGARIAN: hb_script_t = 1215655527;
pub const hb_script_t_HB_SCRIPT_SIGNWRITING: hb_script_t = 1399287415;
pub const hb_script_t_HB_SCRIPT_ADLAM: hb_script_t = 1097100397;
pub const hb_script_t_HB_SCRIPT_BHAIKSUKI: hb_script_t = 1114139507;
pub const hb_script_t_HB_SCRIPT_MARCHEN: hb_script_t = 1298231907;
pub const hb_script_t_HB_SCRIPT_OSAGE: hb_script_t = 1332963173;
pub const hb_script_t_HB_SCRIPT_TANGUT: hb_script_t = 1415671399;
pub const hb_script_t_HB_SCRIPT_NEWA: hb_script_t = 1315272545;
pub const hb_script_t_HB_SCRIPT_MASARAM_GONDI: hb_script_t = 1198485101;
pub const hb_script_t_HB_SCRIPT_NUSHU: hb_script_t = 1316186229;
pub const hb_script_t_HB_SCRIPT_SOYOMBO: hb_script_t = 1399814511;
pub const hb_script_t_HB_SCRIPT_ZANABAZAR_SQUARE: hb_script_t = 1516334690;
pub const hb_script_t_HB_SCRIPT_DOGRA: hb_script_t = 1148151666;
pub const hb_script_t_HB_SCRIPT_GUNJALA_GONDI: hb_script_t = 1198485095;
pub const hb_script_t_HB_SCRIPT_HANIFI_ROHINGYA: hb_script_t = 1383032935;
pub const hb_script_t_HB_SCRIPT_MAKASAR: hb_script_t = 1298230113;
pub const hb_script_t_HB_SCRIPT_MEDEFAIDRIN: hb_script_t = 1298490470;
pub const hb_script_t_HB_SCRIPT_OLD_SOGDIAN: hb_script_t = 1399809903;
pub const hb_script_t_HB_SCRIPT_SOGDIAN: hb_script_t = 1399809892;
pub const hb_script_t_HB_SCRIPT_ELYMAIC: hb_script_t = 1164736877;
pub const hb_script_t_HB_SCRIPT_NANDINAGARI: hb_script_t = 1315008100;
pub const hb_script_t_HB_SCRIPT_NYIAKENG_PUACHUE_HMONG: hb_script_t = 1215131248;
pub const hb_script_t_HB_SCRIPT_WANCHO: hb_script_t = 1466132591;
pub const hb_script_t_HB_SCRIPT_CHORASMIAN: hb_script_t = 1130918515;
pub const hb_script_t_HB_SCRIPT_DIVES_AKURU: hb_script_t = 1147756907;
pub const hb_script_t_HB_SCRIPT_KHITAN_SMALL_SCRIPT: hb_script_t = 1265202291;
pub const hb_script_t_HB_SCRIPT_YEZIDI: hb_script_t = 1499822697;
pub const hb_script_t_HB_SCRIPT_CYPRO_MINOAN: hb_script_t = 1131441518;
pub const hb_script_t_HB_SCRIPT_OLD_UYGHUR: hb_script_t = 1333094258;
pub const hb_script_t_HB_SCRIPT_TANGSA: hb_script_t = 1416524641;
pub const hb_script_t_HB_SCRIPT_TOTO: hb_script_t = 1416590447;
pub const hb_script_t_HB_SCRIPT_VITHKUQI: hb_script_t = 1449751656;
pub const hb_script_t_HB_SCRIPT_MATH: hb_script_t = 1517122664;
pub const hb_script_t_HB_SCRIPT_KAWI: hb_script_t = 1264678761;
pub const hb_script_t_HB_SCRIPT_NAG_MUNDARI: hb_script_t = 1315006317;
pub const hb_script_t_HB_SCRIPT_INVALID: hb_script_t = 0;
pub const hb_script_t__HB_SCRIPT_MAX_VALUE: hb_script_t = 2147483647;
pub const hb_script_t__HB_SCRIPT_MAX_VALUE_SIGNED: hb_script_t = 2147483647;
#[doc = " hb_script_t:\n @HB_SCRIPT_COMMON: `Zyyy`\n @HB_SCRIPT_INHERITED: `Zinh`\n @HB_SCRIPT_UNKNOWN: `Zzzz`\n @HB_SCRIPT_ARABIC: `Arab`\n @HB_SCRIPT_ARMENIAN: `Armn`\n @HB_SCRIPT_BENGALI: `Beng`\n @HB_SCRIPT_CYRILLIC: `Cyrl`\n @HB_SCRIPT_DEVANAGARI: `Deva`\n @HB_SCRIPT_GEORGIAN: `Geor`\n @HB_SCRIPT_GREEK: `Grek`\n @HB_SCRIPT_GUJARATI: `Gujr`\n @HB_SCRIPT_GURMUKHI: `Guru`\n @HB_SCRIPT_HANGUL: `Hang`\n @HB_SCRIPT_HAN: `Hani`\n @HB_SCRIPT_HEBREW: `Hebr`\n @HB_SCRIPT_HIRAGANA: `Hira`\n @HB_SCRIPT_KANNADA: `Knda`\n @HB_SCRIPT_KATAKANA: `Kana`\n @HB_SCRIPT_LAO: `Laoo`\n @HB_SCRIPT_LATIN: `Latn`\n @HB_SCRIPT_MALAYALAM: `Mlym`\n @HB_SCRIPT_ORIYA: `Orya`\n @HB_SCRIPT_TAMIL: `Taml`\n @HB_SCRIPT_TELUGU: `Telu`\n @HB_SCRIPT_THAI: `Thai`\n @HB_SCRIPT_TIBETAN: `Tibt`\n @HB_SCRIPT_BOPOMOFO: `Bopo`\n @HB_SCRIPT_BRAILLE: `Brai`\n @HB_SCRIPT_CANADIAN_SYLLABICS: `Cans`\n @HB_SCRIPT_CHEROKEE: `Cher`\n @HB_SCRIPT_ETHIOPIC: `Ethi`\n @HB_SCRIPT_KHMER: `Khmr`\n @HB_SCRIPT_MONGOLIAN: `Mong`\n @HB_SCRIPT_MYANMAR: `Mymr`\n @HB_SCRIPT_OGHAM: `Ogam`\n @HB_SCRIPT_RUNIC: `Runr`\n @HB_SCRIPT_SINHALA: `Sinh`\n @HB_SCRIPT_SYRIAC: `Syrc`\n @HB_SCRIPT_THAANA: `Thaa`\n @HB_SCRIPT_YI: `Yiii`\n @HB_SCRIPT_DESERET: `Dsrt`\n @HB_SCRIPT_GOTHIC: `Goth`\n @HB_SCRIPT_OLD_ITALIC: `Ital`\n @HB_SCRIPT_BUHID: `Buhd`\n @HB_SCRIPT_HANUNOO: `Hano`\n @HB_SCRIPT_TAGALOG: `Tglg`\n @HB_SCRIPT_TAGBANWA: `Tagb`\n @HB_SCRIPT_CYPRIOT: `Cprt`\n @HB_SCRIPT_LIMBU: `Limb`\n @HB_SCRIPT_LINEAR_B: `Linb`\n @HB_SCRIPT_OSMANYA: `Osma`\n @HB_SCRIPT_SHAVIAN: `Shaw`\n @HB_SCRIPT_TAI_LE: `Tale`\n @HB_SCRIPT_UGARITIC: `Ugar`\n @HB_SCRIPT_BUGINESE: `Bugi`\n @HB_SCRIPT_COPTIC: `Copt`\n @HB_SCRIPT_GLAGOLITIC: `Glag`\n @HB_SCRIPT_KHAROSHTHI: `Khar`\n @HB_SCRIPT_NEW_TAI_LUE: `Talu`\n @HB_SCRIPT_OLD_PERSIAN: `Xpeo`\n @HB_SCRIPT_SYLOTI_NAGRI: `Sylo`\n @HB_SCRIPT_TIFINAGH: `Tfng`\n @HB_SCRIPT_BALINESE: `Bali`\n @HB_SCRIPT_CUNEIFORM: `Xsux`\n @HB_SCRIPT_NKO: `Nkoo`\n @HB_SCRIPT_PHAGS_PA: `Phag`\n @HB_SCRIPT_PHOENICIAN: `Phnx`\n @HB_SCRIPT_CARIAN: `Cari`\n @HB_SCRIPT_CHAM: `Cham`\n @HB_SCRIPT_KAYAH_LI: `Kali`\n @HB_SCRIPT_LEPCHA: `Lepc`\n @HB_SCRIPT_LYCIAN: `Lyci`\n @HB_SCRIPT_LYDIAN: `Lydi`\n @HB_SCRIPT_OL_CHIKI: `Olck`\n @HB_SCRIPT_REJANG: `Rjng`\n @HB_SCRIPT_SAURASHTRA: `Saur`\n @HB_SCRIPT_SUNDANESE: `Sund`\n @HB_SCRIPT_VAI: `Vaii`\n @HB_SCRIPT_AVESTAN: `Avst`\n @HB_SCRIPT_BAMUM: `Bamu`\n @HB_SCRIPT_EGYPTIAN_HIEROGLYPHS: `Egyp`\n @HB_SCRIPT_IMPERIAL_ARAMAIC: `Armi`\n @HB_SCRIPT_INSCRIPTIONAL_PAHLAVI: `Phli`\n @HB_SCRIPT_INSCRIPTIONAL_PARTHIAN: `Prti`\n @HB_SCRIPT_JAVANESE: `Java`\n @HB_SCRIPT_KAITHI: `Kthi`\n @HB_SCRIPT_LISU: `Lisu`\n @HB_SCRIPT_MEETEI_MAYEK: `Mtei`\n @HB_SCRIPT_OLD_SOUTH_ARABIAN: `Sarb`\n @HB_SCRIPT_OLD_TURKIC: `Orkh`\n @HB_SCRIPT_SAMARITAN: `Samr`\n @HB_SCRIPT_TAI_THAM: `Lana`\n @HB_SCRIPT_TAI_VIET: `Tavt`\n @HB_SCRIPT_BATAK: `Batk`\n @HB_SCRIPT_BRAHMI: `Brah`\n @HB_SCRIPT_MANDAIC: `Mand`\n @HB_SCRIPT_CHAKMA: `Cakm`\n @HB_SCRIPT_MEROITIC_CURSIVE: `Merc`\n @HB_SCRIPT_MEROITIC_HIEROGLYPHS: `Mero`\n @HB_SCRIPT_MIAO: `Plrd`\n @HB_SCRIPT_SHARADA: `Shrd`\n @HB_SCRIPT_SORA_SOMPENG: `Sora`\n @HB_SCRIPT_TAKRI: `Takr`\n @HB_SCRIPT_BASSA_VAH: `Bass`, Since: 0.9.30\n @HB_SCRIPT_CAUCASIAN_ALBANIAN: `Aghb`, Since: 0.9.30\n @HB_SCRIPT_DUPLOYAN: `Dupl`, Since: 0.9.30\n @HB_SCRIPT_ELBASAN: `Elba`, Since: 0.9.30\n @HB_SCRIPT_GRANTHA: `Gran`, Since: 0.9.30\n @HB_SCRIPT_KHOJKI: `Khoj`, Since: 0.9.30\n @HB_SCRIPT_KHUDAWADI: `Sind`, Since: 0.9.30\n @HB_SCRIPT_LINEAR_A: `Lina`, Since: 0.9.30\n @HB_SCRIPT_MAHAJANI: `Mahj`, Since: 0.9.30\n @HB_SCRIPT_MANICHAEAN: `Mani`, Since: 0.9.30\n @HB_SCRIPT_MENDE_KIKAKUI: `Mend`, Since: 0.9.30\n @HB_SCRIPT_MODI: `Modi`, Since: 0.9.30\n @HB_SCRIPT_MRO: `Mroo`, Since: 0.9.30\n @HB_SCRIPT_NABATAEAN: `Nbat`, Since: 0.9.30\n @HB_SCRIPT_OLD_NORTH_ARABIAN: `Narb`, Since: 0.9.30\n @HB_SCRIPT_OLD_PERMIC: `Perm`, Since: 0.9.30\n @HB_SCRIPT_PAHAWH_HMONG: `Hmng`, Since: 0.9.30\n @HB_SCRIPT_PALMYRENE: `Palm`, Since: 0.9.30\n @HB_SCRIPT_PAU_CIN_HAU: `Pauc`, Since: 0.9.30\n @HB_SCRIPT_PSALTER_PAHLAVI: `Phlp`, Since: 0.9.30\n @HB_SCRIPT_SIDDHAM: `Sidd`, Since: 0.9.30\n @HB_SCRIPT_TIRHUTA: `Tirh`, Since: 0.9.30\n @HB_SCRIPT_WARANG_CITI: `Wara`, Since: 0.9.30\n @HB_SCRIPT_AHOM: `Ahom`, Since: 0.9.30\n @HB_SCRIPT_ANATOLIAN_HIEROGLYPHS: `Hluw`, Since: 0.9.30\n @HB_SCRIPT_HATRAN: `Hatr`, Since: 0.9.30\n @HB_SCRIPT_MULTANI: `Mult`, Since: 0.9.30\n @HB_SCRIPT_OLD_HUNGARIAN: `Hung`, Since: 0.9.30\n @HB_SCRIPT_SIGNWRITING: `Sgnw`, Since: 0.9.30\n @HB_SCRIPT_ADLAM: `Adlm`, Since: 1.3.0\n @HB_SCRIPT_BHAIKSUKI: `Bhks`, Since: 1.3.0\n @HB_SCRIPT_MARCHEN: `Marc`, Since: 1.3.0\n @HB_SCRIPT_OSAGE: `Osge`, Since: 1.3.0\n @HB_SCRIPT_TANGUT: `Tang`, Since: 1.3.0\n @HB_SCRIPT_NEWA: `Newa`, Since: 1.3.0\n @HB_SCRIPT_MASARAM_GONDI: `Gonm`, Since: 1.6.0\n @HB_SCRIPT_NUSHU: `Nshu`, Since: 1.6.0\n @HB_SCRIPT_SOYOMBO: `Soyo`, Since: 1.6.0\n @HB_SCRIPT_ZANABAZAR_SQUARE: `Zanb`, Since: 1.6.0\n @HB_SCRIPT_DOGRA: `Dogr`, Since: 1.8.0\n @HB_SCRIPT_GUNJALA_GONDI: `Gong`, Since: 1.8.0\n @HB_SCRIPT_HANIFI_ROHINGYA: `Rohg`, Since: 1.8.0\n @HB_SCRIPT_MAKASAR: `Maka`, Since: 1.8.0\n @HB_SCRIPT_MEDEFAIDRIN: `Medf`, Since: 1.8.0\n @HB_SCRIPT_OLD_SOGDIAN: `Sogo`, Since: 1.8.0\n @HB_SCRIPT_SOGDIAN: `Sogd`, Since: 1.8.0\n @HB_SCRIPT_ELYMAIC: `Elym`, Since: 2.4.0\n @HB_SCRIPT_NANDINAGARI: `Nand`, Since: 2.4.0\n @HB_SCRIPT_NYIAKENG_PUACHUE_HMONG: `Hmnp`, Since: 2.4.0\n @HB_SCRIPT_WANCHO: `Wcho`, Since: 2.4.0\n @HB_SCRIPT_CHORASMIAN: `Chrs`, Since: 2.6.7\n @HB_SCRIPT_DIVES_AKURU: `Diak`, Since: 2.6.7\n @HB_SCRIPT_KHITAN_SMALL_SCRIPT: `Kits`, Since: 2.6.7\n @HB_SCRIPT_YEZIDI: `Yezi`, Since: 2.6.7\n @HB_SCRIPT_CYPRO_MINOAN: `Cpmn`, Since: 3.0.0\n @HB_SCRIPT_OLD_UYGHUR: `Ougr`, Since: 3.0.0\n @HB_SCRIPT_TANGSA: `Tnsa`, Since: 3.0.0\n @HB_SCRIPT_TOTO: `Toto`, Since: 3.0.0\n @HB_SCRIPT_VITHKUQI: `Vith`, Since: 3.0.0\n @HB_SCRIPT_MATH: `Zmth`, Since: 3.4.0\n @HB_SCRIPT_KAWI: `Kawi`, Since: 5.2.0\n @HB_SCRIPT_NAG_MUNDARI: `Nagm`, Since: 5.2.0\n @HB_SCRIPT_INVALID: No script set\n\n Data type for scripts. Each #hb_script_t's value is an #hb_tag_t corresponding\n to the four-letter values defined by [ISO 15924](https://unicode.org/iso15924/).\n\n See also the Script (sc) property of the Unicode Character Database.\n"]
pub type hb_script_t = ::std::os::raw::c_uint;
extern "C" {
    pub fn hb_script_from_iso15924_tag(tag: hb_tag_t) -> hb_script_t;
}
extern "C" {
    pub fn hb_script_from_string(
        str_: *const ::std::os::raw::c_char,
        len: ::std::os::raw::c_int,
    ) -> hb_script_t;
}
extern "C" {
    pub fn hb_script_to_iso15924_tag(script: hb_script_t) -> hb_tag_t;
}
extern "C" {
    pub fn hb_script_get_horizontal_direction(script: hb_script_t) -> hb_direction_t;
}
#[doc = " hb_user_data_key_t:\n\n Data structure for holding user-data keys.\n"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct hb_user_data_key_t {
    pub unused: ::std::os::raw::c_char,
}
#[test]
fn bindgen_test_layout_hb_user_data_key_t() {
    const UNINIT: ::std::mem::MaybeUninit<hb_user_data_key_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<hb_user_data_key_t>(),
        1usize,
        concat!("Size of: ", stringify!(hb_user_data_key_t))
    );
    assert_eq!(
        ::std::mem::align_of::<hb_user_data_key_t>(),
        1usize,
        concat!("Alignment of ", stringify!(hb_user_data_key_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).unused) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(hb_user_data_key_t),
            "::",
            stringify!(unused)
        )
    );
}
#[doc = " hb_destroy_func_t:\n @user_data: the data to be destroyed\n\n A virtual method for destroy user-data callbacks.\n"]
pub type hb_destroy_func_t =
    ::std::option::Option<unsafe extern "C" fn(user_data: *mut ::std::os::raw::c_void)>;
#[doc = " hb_feature_t:\n @tag: The #hb_tag_t tag of the feature\n @value: The value of the feature. 0 disables the feature, non-zero (usually\n 1) enables the feature.  For features implemented as lookup type 3 (like\n 'salt') the @value is a one based index into the alternates.\n @start: the cluster to start applying this feature setting (inclusive).\n @end: the cluster to end applying this feature setting (exclusive).\n\n The #hb_feature_t is the structure that holds information about requested\n feature application. The feature will be applied with the given value to all\n glyphs which are in clusters between @start (inclusive) and @end (exclusive).\n Setting start to #HB_FEATURE_GLOBAL_START and end to #HB_FEATURE_GLOBAL_END\n specifies that the feature always applies to the entire buffer."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct hb_feature_t {
    pub tag: hb_tag_t,
    pub value: u32,
    pub start: ::std::os::raw::c_uint,
    pub end: ::std::os::raw::c_uint,
}
#[test]
fn bindgen_test_layout_hb_feature_t() {
    const UNINIT: ::std::mem::MaybeUninit<hb_feature_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<hb_feature_t>(),
        16usize,
        concat!("Size of: ", stringify!(hb_feature_t))
    );
    assert_eq!(
        ::std::mem::align_of::<hb_feature_t>(),
        4usize,
        concat!("Alignment of ", stringify!(hb_feature_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tag) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(hb_feature_t),
            "::",
            stringify!(tag)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).value) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(hb_feature_t),
            "::",
            stringify!(value)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).start) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(hb_feature_t),
            "::",
            stringify!(start)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).end) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(hb_feature_t),
            "::",
            stringify!(end)
        )
    );
}
extern "C" {
    pub fn hb_feature_from_string(
        str_: *const ::std::os::raw::c_char,
        len: ::std::os::raw::c_int,
        feature: *mut hb_feature_t,
    ) -> hb_bool_t;
}
extern "C" {
    pub fn hb_feature_to_string(
        feature: *mut hb_feature_t,
        buf: *mut ::std::os::raw::c_char,
        size: ::std::os::raw::c_uint,
    );
}
#[doc = " hb_variation_t:\n @tag: The #hb_tag_t tag of the variation-axis name\n @value: The value of the variation axis\n\n Data type for holding variation data. Registered OpenType\n variation-axis tags are listed in\n [OpenType Axis Tag Registry](https://docs.microsoft.com/en-us/typography/opentype/spec/dvaraxisreg).\n\n Since: 1.4.2"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct hb_variation_t {
    pub tag: hb_tag_t,
    pub value: f32,
}
#[test]
fn bindgen_test_layout_hb_variation_t() {
    const UNINIT: ::std::mem::MaybeUninit<hb_variation_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<hb_variation_t>(),
        8usize,
        concat!("Size of: ", stringify!(hb_variation_t))
    );
    assert_eq!(
        ::std::mem::align_of::<hb_variation_t>(),
        4usize,
        concat!("Alignment of ", stringify!(hb_variation_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tag) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(hb_variation_t),
            "::",
            stringify!(tag)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).value) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(hb_variation_t),
            "::",
            stringify!(value)
        )
    );
}
extern "C" {
    pub fn hb_variation_from_string(
        str_: *const ::std::os::raw::c_char,
        len: ::std::os::raw::c_int,
        variation: *mut hb_variation_t,
    ) -> hb_bool_t;
}
extern "C" {
    pub fn hb_variation_to_string(
        variation: *mut hb_variation_t,
        buf: *mut ::std::os::raw::c_char,
        size: ::std::os::raw::c_uint,
    );
}
#[doc = " hb_color_t:\n\n Data type for holding color values. Colors are eight bits per\n channel RGB plus alpha transparency.\n\n Since: 2.1.0"]
pub type hb_color_t = u32;
extern "C" {
    pub fn hb_color_get_alpha(color: hb_color_t) -> u8;
}
extern "C" {
    pub fn hb_color_get_red(color: hb_color_t) -> u8;
}
extern "C" {
    pub fn hb_color_get_green(color: hb_color_t) -> u8;
}
extern "C" {
    pub fn hb_color_get_blue(color: hb_color_t) -> u8;
}
#[doc = " hb_glyph_extents_t:\n @x_bearing: Distance from the x-origin to the left extremum of the glyph.\n @y_bearing: Distance from the top extremum of the glyph to the y-origin.\n @width: Distance from the left extremum of the glyph to the right extremum.\n @height: Distance from the top extremum of the glyph to the bottom extremum.\n\n Glyph extent values, measured in font units.\n\n Note that @height is negative, in coordinate systems that grow up."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct hb_glyph_extents_t {
    pub x_bearing: hb_position_t,
    pub y_bearing: hb_position_t,
    pub width: hb_position_t,
    pub height: hb_position_t,
}
#[test]
fn bindgen_test_layout_hb_glyph_extents_t() {
    const UNINIT: ::std::mem::MaybeUninit<hb_glyph_extents_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<hb_glyph_extents_t>(),
        16usize,
        concat!("Size of: ", stringify!(hb_glyph_extents_t))
    );
    assert_eq!(
        ::std::mem::align_of::<hb_glyph_extents_t>(),
        4usize,
        concat!("Alignment of ", stringify!(hb_glyph_extents_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).x_bearing) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(hb_glyph_extents_t),
            "::",
            stringify!(x_bearing)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).y_bearing) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(hb_glyph_extents_t),
            "::",
            stringify!(y_bearing)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).width) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(hb_glyph_extents_t),
            "::",
            stringify!(width)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).height) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(hb_glyph_extents_t),
            "::",
            stringify!(height)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct hb_font_t {
    _unused: [u8; 0],
}
pub const hb_memory_mode_t_HB_MEMORY_MODE_DUPLICATE: hb_memory_mode_t = 0;
pub const hb_memory_mode_t_HB_MEMORY_MODE_READONLY: hb_memory_mode_t = 1;
pub const hb_memory_mode_t_HB_MEMORY_MODE_WRITABLE: hb_memory_mode_t = 2;
pub const hb_memory_mode_t_HB_MEMORY_MODE_READONLY_MAY_MAKE_WRITABLE: hb_memory_mode_t = 3;
#[doc = " hb_memory_mode_t:\n @HB_MEMORY_MODE_DUPLICATE: HarfBuzz immediately makes a copy of the data.\n @HB_MEMORY_MODE_READONLY: HarfBuzz client will never modify the data,\n     and HarfBuzz will never modify the data.\n @HB_MEMORY_MODE_WRITABLE: HarfBuzz client made a copy of the data solely\n     for HarfBuzz, so HarfBuzz may modify the data.\n @HB_MEMORY_MODE_READONLY_MAY_MAKE_WRITABLE: See above\n\n Data type holding the memory modes available to\n client programs.\n\n Regarding these various memory-modes:\n\n - In no case shall the HarfBuzz client modify memory\n   that is passed to HarfBuzz in a blob.  If there is\n   any such possibility, @HB_MEMORY_MODE_DUPLICATE should be used\n   such that HarfBuzz makes a copy immediately,\n\n - Use @HB_MEMORY_MODE_READONLY otherwise, unless you really really\n   really know what you are doing,\n\n - @HB_MEMORY_MODE_WRITABLE is appropriate if you really made a\n   copy of data solely for the purpose of passing to\n   HarfBuzz and doing that just once (no reuse!),\n\n - If the font is mmap()ed, it's okay to use\n   @HB_MEMORY_MODE_READONLY_MAY_MAKE_WRITABLE, however, using that mode\n   correctly is very tricky.  Use @HB_MEMORY_MODE_READONLY instead."]
pub type hb_memory_mode_t = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct hb_blob_t {
    _unused: [u8; 0],
}
extern "C" {
    pub fn hb_blob_create(
        data: *const ::std::os::raw::c_char,
        length: ::std::os::raw::c_uint,
        mode: hb_memory_mode_t,
        user_data: *mut ::std::os::raw::c_void,
        destroy: hb_destroy_func_t,
    ) -> *mut hb_blob_t;
}
extern "C" {
    pub fn hb_blob_create_or_fail(
        data: *const ::std::os::raw::c_char,
        length: ::std::os::raw::c_uint,
        mode: hb_memory_mode_t,
        user_data: *mut ::std::os::raw::c_void,
        destroy: hb_destroy_func_t,
    ) -> *mut hb_blob_t;
}
extern "C" {
    pub fn hb_blob_create_from_file(file_name: *const ::std::os::raw::c_char) -> *mut hb_blob_t;
}
extern "C" {
    pub fn hb_blob_create_from_file_or_fail(
        file_name: *const ::std::os::raw::c_char,
    ) -> *mut hb_blob_t;
}
extern "C" {
    pub fn hb_blob_create_sub_blob(
        parent: *mut hb_blob_t,
        offset: ::std::os::raw::c_uint,
        length: ::std::os::raw::c_uint,
    ) -> *mut hb_blob_t;
}
extern "C" {
    pub fn hb_blob_copy_writable_or_fail(blob: *mut hb_blob_t) -> *mut hb_blob_t;
}
extern "C" {
    pub fn hb_blob_get_empty() -> *mut hb_blob_t;
}
extern "C" {
    pub fn hb_blob_reference(blob: *mut hb_blob_t) -> *mut hb_blob_t;
}
extern "C" {
    pub fn hb_blob_destroy(blob: *mut hb_blob_t);
}
extern "C" {
    pub fn hb_blob_set_user_data(
        blob: *mut hb_blob_t,
        key: *mut hb_user_data_key_t,
        data: *mut ::std::os::raw::c_void,
        destroy: hb_destroy_func_t,
        replace: hb_bool_t,
    ) -> hb_bool_t;
}
extern "C" {
    pub fn hb_blob_get_user_data(
        blob: *const hb_blob_t,
        key: *mut hb_user_data_key_t,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn hb_blob_make_immutable(blob: *mut hb_blob_t);
}
extern "C" {
    pub fn hb_blob_is_immutable(blob: *mut hb_blob_t) -> hb_bool_t;
}
extern "C" {
    pub fn hb_blob_get_length(blob: *mut hb_blob_t) -> ::std::os::raw::c_uint;
}
extern "C" {
    pub fn hb_blob_get_data(
        blob: *mut hb_blob_t,
        length: *mut ::std::os::raw::c_uint,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn hb_blob_get_data_writable(
        blob: *mut hb_blob_t,
        length: *mut ::std::os::raw::c_uint,
    ) -> *mut ::std::os::raw::c_char;
}
pub const hb_unicode_general_category_t_HB_UNICODE_GENERAL_CATEGORY_CONTROL:
    hb_unicode_general_category_t = 0;
pub const hb_unicode_general_category_t_HB_UNICODE_GENERAL_CATEGORY_FORMAT:
    hb_unicode_general_category_t = 1;
pub const hb_unicode_general_category_t_HB_UNICODE_GENERAL_CATEGORY_UNASSIGNED:
    hb_unicode_general_category_t = 2;
pub const hb_unicode_general_category_t_HB_UNICODE_GENERAL_CATEGORY_PRIVATE_USE:
    hb_unicode_general_category_t = 3;
pub const hb_unicode_general_category_t_HB_UNICODE_GENERAL_CATEGORY_SURROGATE:
    hb_unicode_general_category_t = 4;
pub const hb_unicode_general_category_t_HB_UNICODE_GENERAL_CATEGORY_LOWERCASE_LETTER:
    hb_unicode_general_category_t = 5;
pub const hb_unicode_general_category_t_HB_UNICODE_GENERAL_CATEGORY_MODIFIER_LETTER:
    hb_unicode_general_category_t = 6;
pub const hb_unicode_general_category_t_HB_UNICODE_GENERAL_CATEGORY_OTHER_LETTER:
    hb_unicode_general_category_t = 7;
pub const hb_unicode_general_category_t_HB_UNICODE_GENERAL_CATEGORY_TITLECASE_LETTER:
    hb_unicode_general_category_t = 8;
pub const hb_unicode_general_category_t_HB_UNICODE_GENERAL_CATEGORY_UPPERCASE_LETTER:
    hb_unicode_general_category_t = 9;
pub const hb_unicode_general_category_t_HB_UNICODE_GENERAL_CATEGORY_SPACING_MARK:
    hb_unicode_general_category_t = 10;
pub const hb_unicode_general_category_t_HB_UNICODE_GENERAL_CATEGORY_ENCLOSING_MARK:
    hb_unicode_general_category_t = 11;
pub const hb_unicode_general_category_t_HB_UNICODE_GENERAL_CATEGORY_NON_SPACING_MARK:
    hb_unicode_general_category_t = 12;
pub const hb_unicode_general_category_t_HB_UNICODE_GENERAL_CATEGORY_DECIMAL_NUMBER:
    hb_unicode_general_category_t = 13;
pub const hb_unicode_general_category_t_HB_UNICODE_GENERAL_CATEGORY_LETTER_NUMBER:
    hb_unicode_general_category_t = 14;
pub const hb_unicode_general_category_t_HB_UNICODE_GENERAL_CATEGORY_OTHER_NUMBER:
    hb_unicode_general_category_t = 15;
pub const hb_unicode_general_category_t_HB_UNICODE_GENERAL_CATEGORY_CONNECT_PUNCTUATION:
    hb_unicode_general_category_t = 16;
pub const hb_unicode_general_category_t_HB_UNICODE_GENERAL_CATEGORY_DASH_PUNCTUATION:
    hb_unicode_general_category_t = 17;
pub const hb_unicode_general_category_t_HB_UNICODE_GENERAL_CATEGORY_CLOSE_PUNCTUATION:
    hb_unicode_general_category_t = 18;
pub const hb_unicode_general_category_t_HB_UNICODE_GENERAL_CATEGORY_FINAL_PUNCTUATION:
    hb_unicode_general_category_t = 19;
pub const hb_unicode_general_category_t_HB_UNICODE_GENERAL_CATEGORY_INITIAL_PUNCTUATION:
    hb_unicode_general_category_t = 20;
pub const hb_unicode_general_category_t_HB_UNICODE_GENERAL_CATEGORY_OTHER_PUNCTUATION:
    hb_unicode_general_category_t = 21;
pub const hb_unicode_general_category_t_HB_UNICODE_GENERAL_CATEGORY_OPEN_PUNCTUATION:
    hb_unicode_general_category_t = 22;
pub const hb_unicode_general_category_t_HB_UNICODE_GENERAL_CATEGORY_CURRENCY_SYMBOL:
    hb_unicode_general_category_t = 23;
pub const hb_unicode_general_category_t_HB_UNICODE_GENERAL_CATEGORY_MODIFIER_SYMBOL:
    hb_unicode_general_category_t = 24;
pub const hb_unicode_general_category_t_HB_UNICODE_GENERAL_CATEGORY_MATH_SYMBOL:
    hb_unicode_general_category_t = 25;
pub const hb_unicode_general_category_t_HB_UNICODE_GENERAL_CATEGORY_OTHER_SYMBOL:
    hb_unicode_general_category_t = 26;
pub const hb_unicode_general_category_t_HB_UNICODE_GENERAL_CATEGORY_LINE_SEPARATOR:
    hb_unicode_general_category_t = 27;
pub const hb_unicode_general_category_t_HB_UNICODE_GENERAL_CATEGORY_PARAGRAPH_SEPARATOR:
    hb_unicode_general_category_t = 28;
pub const hb_unicode_general_category_t_HB_UNICODE_GENERAL_CATEGORY_SPACE_SEPARATOR:
    hb_unicode_general_category_t = 29;
#[doc = " hb_unicode_general_category_t:\n @HB_UNICODE_GENERAL_CATEGORY_CONTROL:              [Cc]\n @HB_UNICODE_GENERAL_CATEGORY_FORMAT:\t\t      [Cf]\n @HB_UNICODE_GENERAL_CATEGORY_UNASSIGNED:\t      [Cn]\n @HB_UNICODE_GENERAL_CATEGORY_PRIVATE_USE:\t      [Co]\n @HB_UNICODE_GENERAL_CATEGORY_SURROGATE:\t      [Cs]\n @HB_UNICODE_GENERAL_CATEGORY_LOWERCASE_LETTER:     [Ll]\n @HB_UNICODE_GENERAL_CATEGORY_MODIFIER_LETTER:      [Lm]\n @HB_UNICODE_GENERAL_CATEGORY_OTHER_LETTER:\t      [Lo]\n @HB_UNICODE_GENERAL_CATEGORY_TITLECASE_LETTER:     [Lt]\n @HB_UNICODE_GENERAL_CATEGORY_UPPERCASE_LETTER:     [Lu]\n @HB_UNICODE_GENERAL_CATEGORY_SPACING_MARK:\t      [Mc]\n @HB_UNICODE_GENERAL_CATEGORY_ENCLOSING_MARK:\t      [Me]\n @HB_UNICODE_GENERAL_CATEGORY_NON_SPACING_MARK:     [Mn]\n @HB_UNICODE_GENERAL_CATEGORY_DECIMAL_NUMBER:\t      [Nd]\n @HB_UNICODE_GENERAL_CATEGORY_LETTER_NUMBER:\t      [Nl]\n @HB_UNICODE_GENERAL_CATEGORY_OTHER_NUMBER:\t      [No]\n @HB_UNICODE_GENERAL_CATEGORY_CONNECT_PUNCTUATION:  [Pc]\n @HB_UNICODE_GENERAL_CATEGORY_DASH_PUNCTUATION:     [Pd]\n @HB_UNICODE_GENERAL_CATEGORY_CLOSE_PUNCTUATION:    [Pe]\n @HB_UNICODE_GENERAL_CATEGORY_FINAL_PUNCTUATION:    [Pf]\n @HB_UNICODE_GENERAL_CATEGORY_INITIAL_PUNCTUATION:  [Pi]\n @HB_UNICODE_GENERAL_CATEGORY_OTHER_PUNCTUATION:    [Po]\n @HB_UNICODE_GENERAL_CATEGORY_OPEN_PUNCTUATION:     [Ps]\n @HB_UNICODE_GENERAL_CATEGORY_CURRENCY_SYMBOL:      [Sc]\n @HB_UNICODE_GENERAL_CATEGORY_MODIFIER_SYMBOL:      [Sk]\n @HB_UNICODE_GENERAL_CATEGORY_MATH_SYMBOL:\t      [Sm]\n @HB_UNICODE_GENERAL_CATEGORY_OTHER_SYMBOL:\t      [So]\n @HB_UNICODE_GENERAL_CATEGORY_LINE_SEPARATOR:\t      [Zl]\n @HB_UNICODE_GENERAL_CATEGORY_PARAGRAPH_SEPARATOR:  [Zp]\n @HB_UNICODE_GENERAL_CATEGORY_SPACE_SEPARATOR:      [Zs]\n\n Data type for the \"General_Category\" (gc) property from\n the Unicode Character Database."]
pub type hb_unicode_general_category_t = ::std::os::raw::c_uint;
pub const hb_unicode_combining_class_t_HB_UNICODE_COMBINING_CLASS_NOT_REORDERED:
    hb_unicode_combining_class_t = 0;
pub const hb_unicode_combining_class_t_HB_UNICODE_COMBINING_CLASS_OVERLAY:
    hb_unicode_combining_class_t = 1;
pub const hb_unicode_combining_class_t_HB_UNICODE_COMBINING_CLASS_NUKTA:
    hb_unicode_combining_class_t = 7;
pub const hb_unicode_combining_class_t_HB_UNICODE_COMBINING_CLASS_KANA_VOICING:
    hb_unicode_combining_class_t = 8;
pub const hb_unicode_combining_class_t_HB_UNICODE_COMBINING_CLASS_VIRAMA:
    hb_unicode_combining_class_t = 9;
pub const hb_unicode_combining_class_t_HB_UNICODE_COMBINING_CLASS_CCC10:
    hb_unicode_combining_class_t = 10;
pub const hb_unicode_combining_class_t_HB_UNICODE_COMBINING_CLASS_CCC11:
    hb_unicode_combining_class_t = 11;
pub const hb_unicode_combining_class_t_HB_UNICODE_COMBINING_CLASS_CCC12:
    hb_unicode_combining_class_t = 12;
pub const hb_unicode_combining_class_t_HB_UNICODE_COMBINING_CLASS_CCC13:
    hb_unicode_combining_class_t = 13;
pub const hb_unicode_combining_class_t_HB_UNICODE_COMBINING_CLASS_CCC14:
    hb_unicode_combining_class_t = 14;
pub const hb_unicode_combining_class_t_HB_UNICODE_COMBINING_CLASS_CCC15:
    hb_unicode_combining_class_t = 15;
pub const hb_unicode_combining_class_t_HB_UNICODE_COMBINING_CLASS_CCC16:
    hb_unicode_combining_class_t = 16;
pub const hb_unicode_combining_class_t_HB_UNICODE_COMBINING_CLASS_CCC17:
    hb_unicode_combining_class_t = 17;
pub const hb_unicode_combining_class_t_HB_UNICODE_COMBINING_CLASS_CCC18:
    hb_unicode_combining_class_t = 18;
pub const hb_unicode_combining_class_t_HB_UNICODE_COMBINING_CLASS_CCC19:
    hb_unicode_combining_class_t = 19;
pub const hb_unicode_combining_class_t_HB_UNICODE_COMBINING_CLASS_CCC20:
    hb_unicode_combining_class_t = 20;
pub const hb_unicode_combining_class_t_HB_UNICODE_COMBINING_CLASS_CCC21:
    hb_unicode_combining_class_t = 21;
pub const hb_unicode_combining_class_t_HB_UNICODE_COMBINING_CLASS_CCC22:
    hb_unicode_combining_class_t = 22;
pub const hb_unicode_combining_class_t_HB_UNICODE_COMBINING_CLASS_CCC23:
    hb_unicode_combining_class_t = 23;
pub const hb_unicode_combining_class_t_HB_UNICODE_COMBINING_CLASS_CCC24:
    hb_unicode_combining_class_t = 24;
pub const hb_unicode_combining_class_t_HB_UNICODE_COMBINING_CLASS_CCC25:
    hb_unicode_combining_class_t = 25;
pub const hb_unicode_combining_class_t_HB_UNICODE_COMBINING_CLASS_CCC26:
    hb_unicode_combining_class_t = 26;
pub const hb_unicode_combining_class_t_HB_UNICODE_COMBINING_CLASS_CCC27:
    hb_unicode_combining_class_t = 27;
pub const hb_unicode_combining_class_t_HB_UNICODE_COMBINING_CLASS_CCC28:
    hb_unicode_combining_class_t = 28;
pub const hb_unicode_combining_class_t_HB_UNICODE_COMBINING_CLASS_CCC29:
    hb_unicode_combining_class_t = 29;
pub const hb_unicode_combining_class_t_HB_UNICODE_COMBINING_CLASS_CCC30:
    hb_unicode_combining_class_t = 30;
pub const hb_unicode_combining_class_t_HB_UNICODE_COMBINING_CLASS_CCC31:
    hb_unicode_combining_class_t = 31;
pub const hb_unicode_combining_class_t_HB_UNICODE_COMBINING_CLASS_CCC32:
    hb_unicode_combining_class_t = 32;
pub const hb_unicode_combining_class_t_HB_UNICODE_COMBINING_CLASS_CCC33:
    hb_unicode_combining_class_t = 33;
pub const hb_unicode_combining_class_t_HB_UNICODE_COMBINING_CLASS_CCC34:
    hb_unicode_combining_class_t = 34;
pub const hb_unicode_combining_class_t_HB_UNICODE_COMBINING_CLASS_CCC35:
    hb_unicode_combining_class_t = 35;
pub const hb_unicode_combining_class_t_HB_UNICODE_COMBINING_CLASS_CCC36:
    hb_unicode_combining_class_t = 36;
pub const hb_unicode_combining_class_t_HB_UNICODE_COMBINING_CLASS_CCC84:
    hb_unicode_combining_class_t = 84;
pub const hb_unicode_combining_class_t_HB_UNICODE_COMBINING_CLASS_CCC91:
    hb_unicode_combining_class_t = 91;
pub const hb_unicode_combining_class_t_HB_UNICODE_COMBINING_CLASS_CCC103:
    hb_unicode_combining_class_t = 103;
pub const hb_unicode_combining_class_t_HB_UNICODE_COMBINING_CLASS_CCC107:
    hb_unicode_combining_class_t = 107;
pub const hb_unicode_combining_class_t_HB_UNICODE_COMBINING_CLASS_CCC118:
    hb_unicode_combining_class_t = 118;
pub const hb_unicode_combining_class_t_HB_UNICODE_COMBINING_CLASS_CCC122:
    hb_unicode_combining_class_t = 122;
pub const hb_unicode_combining_class_t_HB_UNICODE_COMBINING_CLASS_CCC129:
    hb_unicode_combining_class_t = 129;
pub const hb_unicode_combining_class_t_HB_UNICODE_COMBINING_CLASS_CCC130:
    hb_unicode_combining_class_t = 130;
pub const hb_unicode_combining_class_t_HB_UNICODE_COMBINING_CLASS_CCC132:
    hb_unicode_combining_class_t = 132;
pub const hb_unicode_combining_class_t_HB_UNICODE_COMBINING_CLASS_ATTACHED_BELOW_LEFT:
    hb_unicode_combining_class_t = 200;
pub const hb_unicode_combining_class_t_HB_UNICODE_COMBINING_CLASS_ATTACHED_BELOW:
    hb_unicode_combining_class_t = 202;
pub const hb_unicode_combining_class_t_HB_UNICODE_COMBINING_CLASS_ATTACHED_ABOVE:
    hb_unicode_combining_class_t = 214;
pub const hb_unicode_combining_class_t_HB_UNICODE_COMBINING_CLASS_ATTACHED_ABOVE_RIGHT:
    hb_unicode_combining_class_t = 216;
pub const hb_unicode_combining_class_t_HB_UNICODE_COMBINING_CLASS_BELOW_LEFT:
    hb_unicode_combining_class_t = 218;
pub const hb_unicode_combining_class_t_HB_UNICODE_COMBINING_CLASS_BELOW:
    hb_unicode_combining_class_t = 220;
pub const hb_unicode_combining_class_t_HB_UNICODE_COMBINING_CLASS_BELOW_RIGHT:
    hb_unicode_combining_class_t = 222;
pub const hb_unicode_combining_class_t_HB_UNICODE_COMBINING_CLASS_LEFT:
    hb_unicode_combining_class_t = 224;
pub const hb_unicode_combining_class_t_HB_UNICODE_COMBINING_CLASS_RIGHT:
    hb_unicode_combining_class_t = 226;
pub const hb_unicode_combining_class_t_HB_UNICODE_COMBINING_CLASS_ABOVE_LEFT:
    hb_unicode_combining_class_t = 228;
pub const hb_unicode_combining_class_t_HB_UNICODE_COMBINING_CLASS_ABOVE:
    hb_unicode_combining_class_t = 230;
pub const hb_unicode_combining_class_t_HB_UNICODE_COMBINING_CLASS_ABOVE_RIGHT:
    hb_unicode_combining_class_t = 232;
pub const hb_unicode_combining_class_t_HB_UNICODE_COMBINING_CLASS_DOUBLE_BELOW:
    hb_unicode_combining_class_t = 233;
pub const hb_unicode_combining_class_t_HB_UNICODE_COMBINING_CLASS_DOUBLE_ABOVE:
    hb_unicode_combining_class_t = 234;
pub const hb_unicode_combining_class_t_HB_UNICODE_COMBINING_CLASS_IOTA_SUBSCRIPT:
    hb_unicode_combining_class_t = 240;
pub const hb_unicode_combining_class_t_HB_UNICODE_COMBINING_CLASS_INVALID:
    hb_unicode_combining_class_t = 255;
#[doc = " hb_unicode_combining_class_t:\n @HB_UNICODE_COMBINING_CLASS_NOT_REORDERED: Spacing and enclosing marks; also many vowel and consonant signs, even if nonspacing\n @HB_UNICODE_COMBINING_CLASS_OVERLAY: Marks which overlay a base letter or symbol\n @HB_UNICODE_COMBINING_CLASS_NUKTA: Diacritic nukta marks in Brahmi-derived scripts\n @HB_UNICODE_COMBINING_CLASS_KANA_VOICING: Hiragana/Katakana voicing marks\n @HB_UNICODE_COMBINING_CLASS_VIRAMA: Viramas\n @HB_UNICODE_COMBINING_CLASS_CCC10: [Hebrew]\n @HB_UNICODE_COMBINING_CLASS_CCC11: [Hebrew]\n @HB_UNICODE_COMBINING_CLASS_CCC12: [Hebrew]\n @HB_UNICODE_COMBINING_CLASS_CCC13: [Hebrew]\n @HB_UNICODE_COMBINING_CLASS_CCC14: [Hebrew]\n @HB_UNICODE_COMBINING_CLASS_CCC15: [Hebrew]\n @HB_UNICODE_COMBINING_CLASS_CCC16: [Hebrew]\n @HB_UNICODE_COMBINING_CLASS_CCC17: [Hebrew]\n @HB_UNICODE_COMBINING_CLASS_CCC18: [Hebrew]\n @HB_UNICODE_COMBINING_CLASS_CCC19: [Hebrew]\n @HB_UNICODE_COMBINING_CLASS_CCC20: [Hebrew]\n @HB_UNICODE_COMBINING_CLASS_CCC21: [Hebrew]\n @HB_UNICODE_COMBINING_CLASS_CCC22: [Hebrew]\n @HB_UNICODE_COMBINING_CLASS_CCC23: [Hebrew]\n @HB_UNICODE_COMBINING_CLASS_CCC24: [Hebrew]\n @HB_UNICODE_COMBINING_CLASS_CCC25: [Hebrew]\n @HB_UNICODE_COMBINING_CLASS_CCC26: [Hebrew]\n @HB_UNICODE_COMBINING_CLASS_CCC27: [Arabic]\n @HB_UNICODE_COMBINING_CLASS_CCC28: [Arabic]\n @HB_UNICODE_COMBINING_CLASS_CCC29: [Arabic]\n @HB_UNICODE_COMBINING_CLASS_CCC30: [Arabic]\n @HB_UNICODE_COMBINING_CLASS_CCC31: [Arabic]\n @HB_UNICODE_COMBINING_CLASS_CCC32: [Arabic]\n @HB_UNICODE_COMBINING_CLASS_CCC33: [Arabic]\n @HB_UNICODE_COMBINING_CLASS_CCC34: [Arabic]\n @HB_UNICODE_COMBINING_CLASS_CCC35: [Arabic]\n @HB_UNICODE_COMBINING_CLASS_CCC36: [Syriac]\n @HB_UNICODE_COMBINING_CLASS_CCC84: [Telugu]\n @HB_UNICODE_COMBINING_CLASS_CCC91: [Telugu]\n @HB_UNICODE_COMBINING_CLASS_CCC103: [Thai]\n @HB_UNICODE_COMBINING_CLASS_CCC107: [Thai]\n @HB_UNICODE_COMBINING_CLASS_CCC118: [Lao]\n @HB_UNICODE_COMBINING_CLASS_CCC122: [Lao]\n @HB_UNICODE_COMBINING_CLASS_CCC129: [Tibetan]\n @HB_UNICODE_COMBINING_CLASS_CCC130: [Tibetan]\n @HB_UNICODE_COMBINING_CLASS_CCC132: [Tibetan] Since: 7.2.0\n @HB_UNICODE_COMBINING_CLASS_ATTACHED_BELOW_LEFT: Marks attached at the bottom left\n @HB_UNICODE_COMBINING_CLASS_ATTACHED_BELOW: Marks attached directly below\n @HB_UNICODE_COMBINING_CLASS_ATTACHED_ABOVE: Marks attached directly above\n @HB_UNICODE_COMBINING_CLASS_ATTACHED_ABOVE_RIGHT: Marks attached at the top right\n @HB_UNICODE_COMBINING_CLASS_BELOW_LEFT: Distinct marks at the bottom left\n @HB_UNICODE_COMBINING_CLASS_BELOW: Distinct marks directly below\n @HB_UNICODE_COMBINING_CLASS_BELOW_RIGHT: Distinct marks at the bottom right\n @HB_UNICODE_COMBINING_CLASS_LEFT: Distinct marks to the left\n @HB_UNICODE_COMBINING_CLASS_RIGHT: Distinct marks to the right\n @HB_UNICODE_COMBINING_CLASS_ABOVE_LEFT: Distinct marks at the top left\n @HB_UNICODE_COMBINING_CLASS_ABOVE: Distinct marks directly above\n @HB_UNICODE_COMBINING_CLASS_ABOVE_RIGHT: Distinct marks at the top right\n @HB_UNICODE_COMBINING_CLASS_DOUBLE_BELOW: Distinct marks subtending two bases\n @HB_UNICODE_COMBINING_CLASS_DOUBLE_ABOVE: Distinct marks extending above two bases\n @HB_UNICODE_COMBINING_CLASS_IOTA_SUBSCRIPT: Greek iota subscript only\n @HB_UNICODE_COMBINING_CLASS_INVALID: Invalid combining class\n\n Data type for the Canonical_Combining_Class (ccc) property\n from the Unicode Character Database.\n\n <note>Note: newer versions of Unicode may add new values.\n Client programs should be ready to handle any value in the 0..254 range\n being returned from hb_unicode_combining_class().</note>\n"]
pub type hb_unicode_combining_class_t = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct hb_unicode_funcs_t {
    _unused: [u8; 0],
}
extern "C" {
    pub fn hb_unicode_funcs_get_default() -> *mut hb_unicode_funcs_t;
}
extern "C" {
    pub fn hb_unicode_funcs_create(parent: *mut hb_unicode_funcs_t) -> *mut hb_unicode_funcs_t;
}
extern "C" {
    pub fn hb_unicode_funcs_get_empty() -> *mut hb_unicode_funcs_t;
}
extern "C" {
    pub fn hb_unicode_funcs_reference(ufuncs: *mut hb_unicode_funcs_t) -> *mut hb_unicode_funcs_t;
}
extern "C" {
    pub fn hb_unicode_funcs_destroy(ufuncs: *mut hb_unicode_funcs_t);
}
extern "C" {
    pub fn hb_unicode_funcs_set_user_data(
        ufuncs: *mut hb_unicode_funcs_t,
        key: *mut hb_user_data_key_t,
        data: *mut ::std::os::raw::c_void,
        destroy: hb_destroy_func_t,
        replace: hb_bool_t,
    ) -> hb_bool_t;
}
extern "C" {
    pub fn hb_unicode_funcs_get_user_data(
        ufuncs: *const hb_unicode_funcs_t,
        key: *mut hb_user_data_key_t,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn hb_unicode_funcs_make_immutable(ufuncs: *mut hb_unicode_funcs_t);
}
extern "C" {
    pub fn hb_unicode_funcs_is_immutable(ufuncs: *mut hb_unicode_funcs_t) -> hb_bool_t;
}
extern "C" {
    pub fn hb_unicode_funcs_get_parent(ufuncs: *mut hb_unicode_funcs_t) -> *mut hb_unicode_funcs_t;
}
#[doc = " hb_unicode_combining_class_func_t:\n @ufuncs: A Unicode-functions structure\n @unicode: The code point to query\n @user_data: User data pointer passed by the caller\n\n A virtual method for the #hb_unicode_funcs_t structure.\n\n This method should retrieve the Canonical Combining Class (ccc)\n property for a specified Unicode code point.\n\n Return value: The #hb_unicode_combining_class_t of @unicode\n"]
pub type hb_unicode_combining_class_func_t = ::std::option::Option<
    unsafe extern "C" fn(
        ufuncs: *mut hb_unicode_funcs_t,
        unicode: hb_codepoint_t,
        user_data: *mut ::std::os::raw::c_void,
    ) -> hb_unicode_combining_class_t,
>;
#[doc = " hb_unicode_general_category_func_t:\n @ufuncs: A Unicode-functions structure\n @unicode: The code point to query\n @user_data: User data pointer passed by the caller\n\n A virtual method for the #hb_unicode_funcs_t structure.\n\n This method should retrieve the General Category property for\n a specified Unicode code point.\n\n Return value: The #hb_unicode_general_category_t of @unicode\n"]
pub type hb_unicode_general_category_func_t = ::std::option::Option<
    unsafe extern "C" fn(
        ufuncs: *mut hb_unicode_funcs_t,
        unicode: hb_codepoint_t,
        user_data: *mut ::std::os::raw::c_void,
    ) -> hb_unicode_general_category_t,
>;
#[doc = " hb_unicode_mirroring_func_t:\n @ufuncs: A Unicode-functions structure\n @unicode: The code point to query\n @user_data: User data pointer passed by the caller\n\n A virtual method for the #hb_unicode_funcs_t structure.\n\n This method should retrieve the Bi-Directional Mirroring Glyph\n code point for a specified Unicode code point.\n\n <note>Note: If a code point does not have a specified\n Bi-Directional Mirroring Glyph defined, the method should\n return the original code point.</note>\n\n Return value: The #hb_codepoint_t of the Mirroring Glyph for @unicode\n"]
pub type hb_unicode_mirroring_func_t = ::std::option::Option<
    unsafe extern "C" fn(
        ufuncs: *mut hb_unicode_funcs_t,
        unicode: hb_codepoint_t,
        user_data: *mut ::std::os::raw::c_void,
    ) -> hb_codepoint_t,
>;
#[doc = " hb_unicode_script_func_t:\n @ufuncs: A Unicode-functions structure\n @unicode: The code point to query\n @user_data: User data pointer passed by the caller\n\n A virtual method for the #hb_unicode_funcs_t structure.\n\n This method should retrieve the Script property for a\n specified Unicode code point.\n\n Return value: The #hb_script_t of @unicode\n"]
pub type hb_unicode_script_func_t = ::std::option::Option<
    unsafe extern "C" fn(
        ufuncs: *mut hb_unicode_funcs_t,
        unicode: hb_codepoint_t,
        user_data: *mut ::std::os::raw::c_void,
    ) -> hb_script_t,
>;
#[doc = " hb_unicode_compose_func_t:\n @ufuncs: A Unicode-functions structure\n @a: The first code point to compose\n @b: The second code point to compose\n @ab: (out): The composed code point\n @user_data: user data pointer passed by the caller\n\n A virtual method for the #hb_unicode_funcs_t structure.\n\n This method should compose a sequence of two input Unicode code\n points by canonical equivalence, returning the composed code\n point in a #hb_codepoint_t output parameter (if successful).\n The method must return an #hb_bool_t indicating the success\n of the composition.\n\n Return value: `true` is @a,@b composed, `false` otherwise\n"]
pub type hb_unicode_compose_func_t = ::std::option::Option<
    unsafe extern "C" fn(
        ufuncs: *mut hb_unicode_funcs_t,
        a: hb_codepoint_t,
        b: hb_codepoint_t,
        ab: *mut hb_codepoint_t,
        user_data: *mut ::std::os::raw::c_void,
    ) -> hb_bool_t,
>;
#[doc = " hb_unicode_decompose_func_t:\n @ufuncs: A Unicode-functions structure\n @ab: The code point to decompose\n @a: (out): The first decomposed code point\n @b: (out): The second decomposed code point\n @user_data: user data pointer passed by the caller\n\n A virtual method for the #hb_unicode_funcs_t structure.\n\n This method should decompose an input Unicode code point,\n returning the two decomposed code points in #hb_codepoint_t\n output parameters (if successful). The method must return an\n #hb_bool_t indicating the success of the composition.\n\n Return value: `true` if @ab decomposed, `false` otherwise\n"]
pub type hb_unicode_decompose_func_t = ::std::option::Option<
    unsafe extern "C" fn(
        ufuncs: *mut hb_unicode_funcs_t,
        ab: hb_codepoint_t,
        a: *mut hb_codepoint_t,
        b: *mut hb_codepoint_t,
        user_data: *mut ::std::os::raw::c_void,
    ) -> hb_bool_t,
>;
extern "C" {
    #[doc = " hb_unicode_funcs_set_combining_class_func:\n @ufuncs: A Unicode-functions structure\n @func: (closure user_data) (destroy destroy) (scope notified): The callback function to assign\n @user_data: Data to pass to @func\n @destroy: (nullable): The function to call when @user_data is not needed anymore\n\n Sets the implementation function for #hb_unicode_combining_class_func_t.\n\n Since: 0.9.2"]
    pub fn hb_unicode_funcs_set_combining_class_func(
        ufuncs: *mut hb_unicode_funcs_t,
        func: hb_unicode_combining_class_func_t,
        user_data: *mut ::std::os::raw::c_void,
        destroy: hb_destroy_func_t,
    );
}
extern "C" {
    #[doc = " hb_unicode_funcs_set_general_category_func:\n @ufuncs: A Unicode-functions structure\n @func: (closure user_data) (destroy destroy) (scope notified): The callback function to assign\n @user_data: Data to pass to @func\n @destroy: (nullable): The function to call when @user_data is not needed anymore\n\n Sets the implementation function for #hb_unicode_general_category_func_t.\n\n Since: 0.9.2"]
    pub fn hb_unicode_funcs_set_general_category_func(
        ufuncs: *mut hb_unicode_funcs_t,
        func: hb_unicode_general_category_func_t,
        user_data: *mut ::std::os::raw::c_void,
        destroy: hb_destroy_func_t,
    );
}
extern "C" {
    #[doc = " hb_unicode_funcs_set_mirroring_func:\n @ufuncs: A Unicode-functions structure\n @func: (closure user_data) (destroy destroy) (scope notified): The callback function to assign\n @user_data: Data to pass to @func\n @destroy: (nullable): The function to call when @user_data is not needed anymore\n\n Sets the implementation function for #hb_unicode_mirroring_func_t.\n\n Since: 0.9.2"]
    pub fn hb_unicode_funcs_set_mirroring_func(
        ufuncs: *mut hb_unicode_funcs_t,
        func: hb_unicode_mirroring_func_t,
        user_data: *mut ::std::os::raw::c_void,
        destroy: hb_destroy_func_t,
    );
}
extern "C" {
    #[doc = " hb_unicode_funcs_set_script_func:\n @ufuncs: A Unicode-functions structure\n @func: (closure user_data) (destroy destroy) (scope notified): The callback function to assign\n @user_data: Data to pass to @func\n @destroy: (nullable): The function to call when @user_data is not needed anymore\n\n Sets the implementation function for #hb_unicode_script_func_t.\n\n Since: 0.9.2"]
    pub fn hb_unicode_funcs_set_script_func(
        ufuncs: *mut hb_unicode_funcs_t,
        func: hb_unicode_script_func_t,
        user_data: *mut ::std::os::raw::c_void,
        destroy: hb_destroy_func_t,
    );
}
extern "C" {
    #[doc = " hb_unicode_funcs_set_compose_func:\n @ufuncs: A Unicode-functions structure\n @func: (closure user_data) (destroy destroy) (scope notified): The callback function to assign\n @user_data: Data to pass to @func\n @destroy: (nullable): The function to call when @user_data is not needed anymore\n\n Sets the implementation function for #hb_unicode_compose_func_t.\n\n Since: 0.9.2"]
    pub fn hb_unicode_funcs_set_compose_func(
        ufuncs: *mut hb_unicode_funcs_t,
        func: hb_unicode_compose_func_t,
        user_data: *mut ::std::os::raw::c_void,
        destroy: hb_destroy_func_t,
    );
}
extern "C" {
    #[doc = " hb_unicode_funcs_set_decompose_func:\n @ufuncs: A Unicode-functions structure\n @func: (closure user_data) (destroy destroy) (scope notified): The callback function to assign\n @user_data: Data to pass to @func\n @destroy: (nullable): The function to call when @user_data is not needed anymore\n\n Sets the implementation function for #hb_unicode_decompose_func_t.\n\n Since: 0.9.2"]
    pub fn hb_unicode_funcs_set_decompose_func(
        ufuncs: *mut hb_unicode_funcs_t,
        func: hb_unicode_decompose_func_t,
        user_data: *mut ::std::os::raw::c_void,
        destroy: hb_destroy_func_t,
    );
}
extern "C" {
    #[doc = " hb_unicode_combining_class:\n @ufuncs: The Unicode-functions structure\n @unicode: The code point to query\n\n Retrieves the Canonical Combining Class (ccc) property\n of code point @unicode.\n\n Return value: The #hb_unicode_combining_class_t of @unicode\n\n Since: 0.9.2"]
    pub fn hb_unicode_combining_class(
        ufuncs: *mut hb_unicode_funcs_t,
        unicode: hb_codepoint_t,
    ) -> hb_unicode_combining_class_t;
}
extern "C" {
    #[doc = " hb_unicode_general_category:\n @ufuncs: The Unicode-functions structure\n @unicode: The code point to query\n\n Retrieves the General Category (gc) property\n of code point @unicode.\n\n Return value: The #hb_unicode_general_category_t of @unicode\n\n Since: 0.9.2"]
    pub fn hb_unicode_general_category(
        ufuncs: *mut hb_unicode_funcs_t,
        unicode: hb_codepoint_t,
    ) -> hb_unicode_general_category_t;
}
extern "C" {
    #[doc = " hb_unicode_mirroring:\n @ufuncs: The Unicode-functions structure\n @unicode: The code point to query\n\n Retrieves the Bi-directional Mirroring Glyph code\n point defined for code point @unicode.\n\n Return value: The #hb_codepoint_t of the Mirroring Glyph for @unicode\n\n Since: 0.9.2"]
    pub fn hb_unicode_mirroring(
        ufuncs: *mut hb_unicode_funcs_t,
        unicode: hb_codepoint_t,
    ) -> hb_codepoint_t;
}
extern "C" {
    #[doc = " hb_unicode_script:\n @ufuncs: The Unicode-functions structure\n @unicode: The code point to query\n\n Retrieves the #hb_script_t script to which code\n point @unicode belongs.\n\n Return value: The #hb_script_t of @unicode\n\n Since: 0.9.2"]
    pub fn hb_unicode_script(
        ufuncs: *mut hb_unicode_funcs_t,
        unicode: hb_codepoint_t,
    ) -> hb_script_t;
}
extern "C" {
    pub fn hb_unicode_compose(
        ufuncs: *mut hb_unicode_funcs_t,
        a: hb_codepoint_t,
        b: hb_codepoint_t,
        ab: *mut hb_codepoint_t,
    ) -> hb_bool_t;
}
extern "C" {
    pub fn hb_unicode_decompose(
        ufuncs: *mut hb_unicode_funcs_t,
        ab: hb_codepoint_t,
        a: *mut hb_codepoint_t,
        b: *mut hb_codepoint_t,
    ) -> hb_bool_t;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct hb_set_t {
    _unused: [u8; 0],
}
extern "C" {
    pub fn hb_set_create() -> *mut hb_set_t;
}
extern "C" {
    pub fn hb_set_get_empty() -> *mut hb_set_t;
}
extern "C" {
    pub fn hb_set_reference(set: *mut hb_set_t) -> *mut hb_set_t;
}
extern "C" {
    pub fn hb_set_destroy(set: *mut hb_set_t);
}
extern "C" {
    pub fn hb_set_set_user_data(
        set: *mut hb_set_t,
        key: *mut hb_user_data_key_t,
        data: *mut ::std::os::raw::c_void,
        destroy: hb_destroy_func_t,
        replace: hb_bool_t,
    ) -> hb_bool_t;
}
extern "C" {
    pub fn hb_set_get_user_data(
        set: *const hb_set_t,
        key: *mut hb_user_data_key_t,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn hb_set_allocation_successful(set: *const hb_set_t) -> hb_bool_t;
}
extern "C" {
    pub fn hb_set_copy(set: *const hb_set_t) -> *mut hb_set_t;
}
extern "C" {
    pub fn hb_set_clear(set: *mut hb_set_t);
}
extern "C" {
    pub fn hb_set_is_empty(set: *const hb_set_t) -> hb_bool_t;
}
extern "C" {
    pub fn hb_set_invert(set: *mut hb_set_t);
}
extern "C" {
    pub fn hb_set_is_inverted(set: *const hb_set_t) -> hb_bool_t;
}
extern "C" {
    pub fn hb_set_has(set: *const hb_set_t, codepoint: hb_codepoint_t) -> hb_bool_t;
}
extern "C" {
    pub fn hb_set_add(set: *mut hb_set_t, codepoint: hb_codepoint_t);
}
extern "C" {
    pub fn hb_set_add_range(set: *mut hb_set_t, first: hb_codepoint_t, last: hb_codepoint_t);
}
extern "C" {
    pub fn hb_set_add_sorted_array(
        set: *mut hb_set_t,
        sorted_codepoints: *const hb_codepoint_t,
        num_codepoints: ::std::os::raw::c_uint,
    );
}
extern "C" {
    pub fn hb_set_del(set: *mut hb_set_t, codepoint: hb_codepoint_t);
}
extern "C" {
    pub fn hb_set_del_range(set: *mut hb_set_t, first: hb_codepoint_t, last: hb_codepoint_t);
}
extern "C" {
    pub fn hb_set_is_equal(set: *const hb_set_t, other: *const hb_set_t) -> hb_bool_t;
}
extern "C" {
    pub fn hb_set_hash(set: *const hb_set_t) -> ::std::os::raw::c_uint;
}
extern "C" {
    pub fn hb_set_is_subset(set: *const hb_set_t, larger_set: *const hb_set_t) -> hb_bool_t;
}
extern "C" {
    pub fn hb_set_set(set: *mut hb_set_t, other: *const hb_set_t);
}
extern "C" {
    pub fn hb_set_union(set: *mut hb_set_t, other: *const hb_set_t);
}
extern "C" {
    pub fn hb_set_intersect(set: *mut hb_set_t, other: *const hb_set_t);
}
extern "C" {
    pub fn hb_set_subtract(set: *mut hb_set_t, other: *const hb_set_t);
}
extern "C" {
    pub fn hb_set_symmetric_difference(set: *mut hb_set_t, other: *const hb_set_t);
}
extern "C" {
    pub fn hb_set_get_population(set: *const hb_set_t) -> ::std::os::raw::c_uint;
}
extern "C" {
    pub fn hb_set_get_min(set: *const hb_set_t) -> hb_codepoint_t;
}
extern "C" {
    pub fn hb_set_get_max(set: *const hb_set_t) -> hb_codepoint_t;
}
extern "C" {
    pub fn hb_set_next(set: *const hb_set_t, codepoint: *mut hb_codepoint_t) -> hb_bool_t;
}
extern "C" {
    pub fn hb_set_previous(set: *const hb_set_t, codepoint: *mut hb_codepoint_t) -> hb_bool_t;
}
extern "C" {
    pub fn hb_set_next_range(
        set: *const hb_set_t,
        first: *mut hb_codepoint_t,
        last: *mut hb_codepoint_t,
    ) -> hb_bool_t;
}
extern "C" {
    pub fn hb_set_previous_range(
        set: *const hb_set_t,
        first: *mut hb_codepoint_t,
        last: *mut hb_codepoint_t,
    ) -> hb_bool_t;
}
extern "C" {
    pub fn hb_set_next_many(
        set: *const hb_set_t,
        codepoint: hb_codepoint_t,
        out: *mut hb_codepoint_t,
        size: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_uint;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct hb_map_t {
    _unused: [u8; 0],
}
extern "C" {
    pub fn hb_map_create() -> *mut hb_map_t;
}
extern "C" {
    pub fn hb_map_get_empty() -> *mut hb_map_t;
}
extern "C" {
    pub fn hb_map_reference(map: *mut hb_map_t) -> *mut hb_map_t;
}
extern "C" {
    pub fn hb_map_destroy(map: *mut hb_map_t);
}
extern "C" {
    pub fn hb_map_set_user_data(
        map: *mut hb_map_t,
        key: *mut hb_user_data_key_t,
        data: *mut ::std::os::raw::c_void,
        destroy: hb_destroy_func_t,
        replace: hb_bool_t,
    ) -> hb_bool_t;
}
extern "C" {
    pub fn hb_map_get_user_data(
        map: *const hb_map_t,
        key: *mut hb_user_data_key_t,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn hb_map_allocation_successful(map: *const hb_map_t) -> hb_bool_t;
}
extern "C" {
    pub fn hb_map_copy(map: *const hb_map_t) -> *mut hb_map_t;
}
extern "C" {
    pub fn hb_map_clear(map: *mut hb_map_t);
}
extern "C" {
    pub fn hb_map_is_empty(map: *const hb_map_t) -> hb_bool_t;
}
extern "C" {
    pub fn hb_map_get_population(map: *const hb_map_t) -> ::std::os::raw::c_uint;
}
extern "C" {
    pub fn hb_map_is_equal(map: *const hb_map_t, other: *const hb_map_t) -> hb_bool_t;
}
extern "C" {
    pub fn hb_map_hash(map: *const hb_map_t) -> ::std::os::raw::c_uint;
}
extern "C" {
    pub fn hb_map_set(map: *mut hb_map_t, key: hb_codepoint_t, value: hb_codepoint_t);
}
extern "C" {
    pub fn hb_map_get(map: *const hb_map_t, key: hb_codepoint_t) -> hb_codepoint_t;
}
extern "C" {
    pub fn hb_map_del(map: *mut hb_map_t, key: hb_codepoint_t);
}
extern "C" {
    pub fn hb_map_has(map: *const hb_map_t, key: hb_codepoint_t) -> hb_bool_t;
}
extern "C" {
    pub fn hb_map_update(map: *mut hb_map_t, other: *const hb_map_t);
}
extern "C" {
    pub fn hb_map_next(
        map: *const hb_map_t,
        idx: *mut ::std::os::raw::c_int,
        key: *mut hb_codepoint_t,
        value: *mut hb_codepoint_t,
    ) -> hb_bool_t;
}
extern "C" {
    pub fn hb_map_keys(map: *const hb_map_t, keys: *mut hb_set_t);
}
extern "C" {
    pub fn hb_map_values(map: *const hb_map_t, values: *mut hb_set_t);
}
extern "C" {
    pub fn hb_face_count(blob: *mut hb_blob_t) -> ::std::os::raw::c_uint;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct hb_face_t {
    _unused: [u8; 0],
}
extern "C" {
    pub fn hb_face_create(blob: *mut hb_blob_t, index: ::std::os::raw::c_uint) -> *mut hb_face_t;
}
#[doc = " hb_reference_table_func_t:\n @face: an #hb_face_t to reference table for\n @tag: the tag of the table to reference\n @user_data: User data pointer passed by the caller\n\n Callback function for hb_face_create_for_tables().\n\n Return value: (transfer full): A pointer to the @tag table within @face\n\n Since: 0.9.2"]
pub type hb_reference_table_func_t = ::std::option::Option<
    unsafe extern "C" fn(
        face: *mut hb_face_t,
        tag: hb_tag_t,
        user_data: *mut ::std::os::raw::c_void,
    ) -> *mut hb_blob_t,
>;
extern "C" {
    pub fn hb_face_create_for_tables(
        reference_table_func: hb_reference_table_func_t,
        user_data: *mut ::std::os::raw::c_void,
        destroy: hb_destroy_func_t,
    ) -> *mut hb_face_t;
}
extern "C" {
    pub fn hb_face_get_empty() -> *mut hb_face_t;
}
extern "C" {
    pub fn hb_face_reference(face: *mut hb_face_t) -> *mut hb_face_t;
}
extern "C" {
    pub fn hb_face_destroy(face: *mut hb_face_t);
}
extern "C" {
    pub fn hb_face_set_user_data(
        face: *mut hb_face_t,
        key: *mut hb_user_data_key_t,
        data: *mut ::std::os::raw::c_void,
        destroy: hb_destroy_func_t,
        replace: hb_bool_t,
    ) -> hb_bool_t;
}
extern "C" {
    pub fn hb_face_get_user_data(
        face: *const hb_face_t,
        key: *mut hb_user_data_key_t,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn hb_face_make_immutable(face: *mut hb_face_t);
}
extern "C" {
    pub fn hb_face_is_immutable(face: *const hb_face_t) -> hb_bool_t;
}
extern "C" {
    pub fn hb_face_reference_table(face: *const hb_face_t, tag: hb_tag_t) -> *mut hb_blob_t;
}
extern "C" {
    pub fn hb_face_reference_blob(face: *mut hb_face_t) -> *mut hb_blob_t;
}
extern "C" {
    pub fn hb_face_set_index(face: *mut hb_face_t, index: ::std::os::raw::c_uint);
}
extern "C" {
    pub fn hb_face_get_index(face: *const hb_face_t) -> ::std::os::raw::c_uint;
}
extern "C" {
    pub fn hb_face_set_upem(face: *mut hb_face_t, upem: ::std::os::raw::c_uint);
}
extern "C" {
    pub fn hb_face_get_upem(face: *const hb_face_t) -> ::std::os::raw::c_uint;
}
extern "C" {
    pub fn hb_face_set_glyph_count(face: *mut hb_face_t, glyph_count: ::std::os::raw::c_uint);
}
extern "C" {
    pub fn hb_face_get_glyph_count(face: *const hb_face_t) -> ::std::os::raw::c_uint;
}
extern "C" {
    pub fn hb_face_get_table_tags(
        face: *const hb_face_t,
        start_offset: ::std::os::raw::c_uint,
        table_count: *mut ::std::os::raw::c_uint,
        table_tags: *mut hb_tag_t,
    ) -> ::std::os::raw::c_uint;
}
extern "C" {
    pub fn hb_face_collect_unicodes(face: *mut hb_face_t, out: *mut hb_set_t);
}
extern "C" {
    pub fn hb_face_collect_nominal_glyph_mapping(
        face: *mut hb_face_t,
        mapping: *mut hb_map_t,
        unicodes: *mut hb_set_t,
    );
}
extern "C" {
    pub fn hb_face_collect_variation_selectors(face: *mut hb_face_t, out: *mut hb_set_t);
}
extern "C" {
    pub fn hb_face_collect_variation_unicodes(
        face: *mut hb_face_t,
        variation_selector: hb_codepoint_t,
        out: *mut hb_set_t,
    );
}
extern "C" {
    pub fn hb_face_builder_create() -> *mut hb_face_t;
}
extern "C" {
    pub fn hb_face_builder_add_table(
        face: *mut hb_face_t,
        tag: hb_tag_t,
        blob: *mut hb_blob_t,
    ) -> hb_bool_t;
}
extern "C" {
    pub fn hb_face_builder_sort_tables(face: *mut hb_face_t, tags: *const hb_tag_t);
}
#[doc = " hb_draw_state_t\n @path_open: Whether there is an open path\n @path_start_x: X component of the start of current path\n @path_start_y: Y component of the start of current path\n @current_x: X component of current point\n @current_y: Y component of current point\n\n Current drawing state.\n\n Since: 4.0.0"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct hb_draw_state_t {
    pub path_open: hb_bool_t,
    pub path_start_x: f32,
    pub path_start_y: f32,
    pub current_x: f32,
    pub current_y: f32,
    pub reserved1: hb_var_num_t,
    pub reserved2: hb_var_num_t,
    pub reserved3: hb_var_num_t,
    pub reserved4: hb_var_num_t,
    pub reserved5: hb_var_num_t,
    pub reserved6: hb_var_num_t,
    pub reserved7: hb_var_num_t,
}
#[test]
fn bindgen_test_layout_hb_draw_state_t() {
    const UNINIT: ::std::mem::MaybeUninit<hb_draw_state_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<hb_draw_state_t>(),
        48usize,
        concat!("Size of: ", stringify!(hb_draw_state_t))
    );
    assert_eq!(
        ::std::mem::align_of::<hb_draw_state_t>(),
        4usize,
        concat!("Alignment of ", stringify!(hb_draw_state_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).path_open) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(hb_draw_state_t),
            "::",
            stringify!(path_open)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).path_start_x) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(hb_draw_state_t),
            "::",
            stringify!(path_start_x)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).path_start_y) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(hb_draw_state_t),
            "::",
            stringify!(path_start_y)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).current_x) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(hb_draw_state_t),
            "::",
            stringify!(current_x)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).current_y) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(hb_draw_state_t),
            "::",
            stringify!(current_y)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).reserved1) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(hb_draw_state_t),
            "::",
            stringify!(reserved1)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).reserved2) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(hb_draw_state_t),
            "::",
            stringify!(reserved2)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).reserved3) as usize - ptr as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(hb_draw_state_t),
            "::",
            stringify!(reserved3)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).reserved4) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(hb_draw_state_t),
            "::",
            stringify!(reserved4)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).reserved5) as usize - ptr as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(hb_draw_state_t),
            "::",
            stringify!(reserved5)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).reserved6) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(hb_draw_state_t),
            "::",
            stringify!(reserved6)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).reserved7) as usize - ptr as usize },
        44usize,
        concat!(
            "Offset of field: ",
            stringify!(hb_draw_state_t),
            "::",
            stringify!(reserved7)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct hb_draw_funcs_t {
    _unused: [u8; 0],
}
#[doc = " hb_draw_move_to_func_t:\n @dfuncs: draw functions object\n @draw_data: The data accompanying the draw functions in hb_font_draw_glyph()\n @st: current draw state\n @to_x: X component of target point\n @to_y: Y component of target point\n @user_data: User data pointer passed to hb_draw_funcs_set_move_to_func()\n\n A virtual method for the #hb_draw_funcs_t to perform a \"move-to\" draw\n operation.\n\n Since: 4.0.0\n"]
pub type hb_draw_move_to_func_t = ::std::option::Option<
    unsafe extern "C" fn(
        dfuncs: *mut hb_draw_funcs_t,
        draw_data: *mut ::std::os::raw::c_void,
        st: *mut hb_draw_state_t,
        to_x: f32,
        to_y: f32,
        user_data: *mut ::std::os::raw::c_void,
    ),
>;
#[doc = " hb_draw_line_to_func_t:\n @dfuncs: draw functions object\n @draw_data: The data accompanying the draw functions in hb_font_draw_glyph()\n @st: current draw state\n @to_x: X component of target point\n @to_y: Y component of target point\n @user_data: User data pointer passed to hb_draw_funcs_set_line_to_func()\n\n A virtual method for the #hb_draw_funcs_t to perform a \"line-to\" draw\n operation.\n\n Since: 4.0.0\n"]
pub type hb_draw_line_to_func_t = ::std::option::Option<
    unsafe extern "C" fn(
        dfuncs: *mut hb_draw_funcs_t,
        draw_data: *mut ::std::os::raw::c_void,
        st: *mut hb_draw_state_t,
        to_x: f32,
        to_y: f32,
        user_data: *mut ::std::os::raw::c_void,
    ),
>;
#[doc = " hb_draw_quadratic_to_func_t:\n @dfuncs: draw functions object\n @draw_data: The data accompanying the draw functions in hb_font_draw_glyph()\n @st: current draw state\n @control_x: X component of control point\n @control_y: Y component of control point\n @to_x: X component of target point\n @to_y: Y component of target point\n @user_data: User data pointer passed to hb_draw_funcs_set_quadratic_to_func()\n\n A virtual method for the #hb_draw_funcs_t to perform a \"quadratic-to\" draw\n operation.\n\n Since: 4.0.0\n"]
pub type hb_draw_quadratic_to_func_t = ::std::option::Option<
    unsafe extern "C" fn(
        dfuncs: *mut hb_draw_funcs_t,
        draw_data: *mut ::std::os::raw::c_void,
        st: *mut hb_draw_state_t,
        control_x: f32,
        control_y: f32,
        to_x: f32,
        to_y: f32,
        user_data: *mut ::std::os::raw::c_void,
    ),
>;
#[doc = " hb_draw_cubic_to_func_t:\n @dfuncs: draw functions object\n @draw_data: The data accompanying the draw functions in hb_font_draw_glyph()\n @st: current draw state\n @control1_x: X component of first control point\n @control1_y: Y component of first control point\n @control2_x: X component of second control point\n @control2_y: Y component of second control point\n @to_x: X component of target point\n @to_y: Y component of target point\n @user_data: User data pointer passed to hb_draw_funcs_set_cubic_to_func()\n\n A virtual method for the #hb_draw_funcs_t to perform a \"cubic-to\" draw\n operation.\n\n Since: 4.0.0\n"]
pub type hb_draw_cubic_to_func_t = ::std::option::Option<
    unsafe extern "C" fn(
        dfuncs: *mut hb_draw_funcs_t,
        draw_data: *mut ::std::os::raw::c_void,
        st: *mut hb_draw_state_t,
        control1_x: f32,
        control1_y: f32,
        control2_x: f32,
        control2_y: f32,
        to_x: f32,
        to_y: f32,
        user_data: *mut ::std::os::raw::c_void,
    ),
>;
#[doc = " hb_draw_close_path_func_t:\n @dfuncs: draw functions object\n @draw_data: The data accompanying the draw functions in hb_font_draw_glyph()\n @st: current draw state\n @user_data: User data pointer passed to hb_draw_funcs_set_close_path_func()\n\n A virtual method for the #hb_draw_funcs_t to perform a \"close-path\" draw\n operation.\n\n Since: 4.0.0\n"]
pub type hb_draw_close_path_func_t = ::std::option::Option<
    unsafe extern "C" fn(
        dfuncs: *mut hb_draw_funcs_t,
        draw_data: *mut ::std::os::raw::c_void,
        st: *mut hb_draw_state_t,
        user_data: *mut ::std::os::raw::c_void,
    ),
>;
extern "C" {
    #[doc = " hb_draw_funcs_set_move_to_func:\n @dfuncs: draw functions object\n @func: (closure user_data) (destroy destroy) (scope notified): move-to callback\n @user_data: Data to pass to @func\n @destroy: (nullable): The function to call when @user_data is not needed anymore\n\n Sets move-to callback to the draw functions object.\n\n Since: 4.0.0"]
    pub fn hb_draw_funcs_set_move_to_func(
        dfuncs: *mut hb_draw_funcs_t,
        func: hb_draw_move_to_func_t,
        user_data: *mut ::std::os::raw::c_void,
        destroy: hb_destroy_func_t,
    );
}
extern "C" {
    #[doc = " hb_draw_funcs_set_line_to_func:\n @dfuncs: draw functions object\n @func: (closure user_data) (destroy destroy) (scope notified): line-to callback\n @user_data: Data to pass to @func\n @destroy: (nullable): The function to call when @user_data is not needed anymore\n\n Sets line-to callback to the draw functions object.\n\n Since: 4.0.0"]
    pub fn hb_draw_funcs_set_line_to_func(
        dfuncs: *mut hb_draw_funcs_t,
        func: hb_draw_line_to_func_t,
        user_data: *mut ::std::os::raw::c_void,
        destroy: hb_destroy_func_t,
    );
}
extern "C" {
    #[doc = " hb_draw_funcs_set_quadratic_to_func:\n @dfuncs: draw functions object\n @func: (closure user_data) (destroy destroy) (scope notified): quadratic-to callback\n @user_data: Data to pass to @func\n @destroy: (nullable): The function to call when @user_data is not needed anymore\n\n Sets quadratic-to callback to the draw functions object.\n\n Since: 4.0.0"]
    pub fn hb_draw_funcs_set_quadratic_to_func(
        dfuncs: *mut hb_draw_funcs_t,
        func: hb_draw_quadratic_to_func_t,
        user_data: *mut ::std::os::raw::c_void,
        destroy: hb_destroy_func_t,
    );
}
extern "C" {
    #[doc = " hb_draw_funcs_set_cubic_to_func:\n @dfuncs: draw functions\n @func: (closure user_data) (destroy destroy) (scope notified): cubic-to callback\n @user_data: Data to pass to @func\n @destroy: (nullable): The function to call when @user_data is not needed anymore\n\n Sets cubic-to callback to the draw functions object.\n\n Since: 4.0.0"]
    pub fn hb_draw_funcs_set_cubic_to_func(
        dfuncs: *mut hb_draw_funcs_t,
        func: hb_draw_cubic_to_func_t,
        user_data: *mut ::std::os::raw::c_void,
        destroy: hb_destroy_func_t,
    );
}
extern "C" {
    #[doc = " hb_draw_funcs_set_close_path_func:\n @dfuncs: draw functions object\n @func: (closure user_data) (destroy destroy) (scope notified): close-path callback\n @user_data: Data to pass to @func\n @destroy: (nullable): The function to call when @user_data is not needed anymore\n\n Sets close-path callback to the draw functions object.\n\n Since: 4.0.0"]
    pub fn hb_draw_funcs_set_close_path_func(
        dfuncs: *mut hb_draw_funcs_t,
        func: hb_draw_close_path_func_t,
        user_data: *mut ::std::os::raw::c_void,
        destroy: hb_destroy_func_t,
    );
}
extern "C" {
    pub fn hb_draw_funcs_create() -> *mut hb_draw_funcs_t;
}
extern "C" {
    pub fn hb_draw_funcs_get_empty() -> *mut hb_draw_funcs_t;
}
extern "C" {
    pub fn hb_draw_funcs_reference(dfuncs: *mut hb_draw_funcs_t) -> *mut hb_draw_funcs_t;
}
extern "C" {
    pub fn hb_draw_funcs_destroy(dfuncs: *mut hb_draw_funcs_t);
}
extern "C" {
    pub fn hb_draw_funcs_set_user_data(
        dfuncs: *mut hb_draw_funcs_t,
        key: *mut hb_user_data_key_t,
        data: *mut ::std::os::raw::c_void,
        destroy: hb_destroy_func_t,
        replace: hb_bool_t,
    ) -> hb_bool_t;
}
extern "C" {
    pub fn hb_draw_funcs_get_user_data(
        dfuncs: *const hb_draw_funcs_t,
        key: *mut hb_user_data_key_t,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn hb_draw_funcs_make_immutable(dfuncs: *mut hb_draw_funcs_t);
}
extern "C" {
    pub fn hb_draw_funcs_is_immutable(dfuncs: *mut hb_draw_funcs_t) -> hb_bool_t;
}
extern "C" {
    pub fn hb_draw_move_to(
        dfuncs: *mut hb_draw_funcs_t,
        draw_data: *mut ::std::os::raw::c_void,
        st: *mut hb_draw_state_t,
        to_x: f32,
        to_y: f32,
    );
}
extern "C" {
    pub fn hb_draw_line_to(
        dfuncs: *mut hb_draw_funcs_t,
        draw_data: *mut ::std::os::raw::c_void,
        st: *mut hb_draw_state_t,
        to_x: f32,
        to_y: f32,
    );
}
extern "C" {
    pub fn hb_draw_quadratic_to(
        dfuncs: *mut hb_draw_funcs_t,
        draw_data: *mut ::std::os::raw::c_void,
        st: *mut hb_draw_state_t,
        control_x: f32,
        control_y: f32,
        to_x: f32,
        to_y: f32,
    );
}
extern "C" {
    pub fn hb_draw_cubic_to(
        dfuncs: *mut hb_draw_funcs_t,
        draw_data: *mut ::std::os::raw::c_void,
        st: *mut hb_draw_state_t,
        control1_x: f32,
        control1_y: f32,
        control2_x: f32,
        control2_y: f32,
        to_x: f32,
        to_y: f32,
    );
}
extern "C" {
    pub fn hb_draw_close_path(
        dfuncs: *mut hb_draw_funcs_t,
        draw_data: *mut ::std::os::raw::c_void,
        st: *mut hb_draw_state_t,
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct hb_paint_funcs_t {
    _unused: [u8; 0],
}
extern "C" {
    pub fn hb_paint_funcs_create() -> *mut hb_paint_funcs_t;
}
extern "C" {
    pub fn hb_paint_funcs_get_empty() -> *mut hb_paint_funcs_t;
}
extern "C" {
    pub fn hb_paint_funcs_reference(funcs: *mut hb_paint_funcs_t) -> *mut hb_paint_funcs_t;
}
extern "C" {
    pub fn hb_paint_funcs_destroy(funcs: *mut hb_paint_funcs_t);
}
extern "C" {
    pub fn hb_paint_funcs_set_user_data(
        funcs: *mut hb_paint_funcs_t,
        key: *mut hb_user_data_key_t,
        data: *mut ::std::os::raw::c_void,
        destroy: hb_destroy_func_t,
        replace: hb_bool_t,
    ) -> hb_bool_t;
}
extern "C" {
    pub fn hb_paint_funcs_get_user_data(
        funcs: *const hb_paint_funcs_t,
        key: *mut hb_user_data_key_t,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn hb_paint_funcs_make_immutable(funcs: *mut hb_paint_funcs_t);
}
extern "C" {
    pub fn hb_paint_funcs_is_immutable(funcs: *mut hb_paint_funcs_t) -> hb_bool_t;
}
#[doc = " hb_paint_push_transform_func_t:\n @funcs: paint functions object\n @paint_data: The data accompanying the paint functions in hb_font_paint_glyph()\n @xx: xx component of the transform matrix\n @yx: yx component of the transform matrix\n @xy: xy component of the transform matrix\n @yy: yy component of the transform matrix\n @dx: dx component of the transform matrix\n @dy: dy component of the transform matrix\n @user_data: User data pointer passed to hb_paint_funcs_set_push_transform_func()\n\n A virtual method for the #hb_paint_funcs_t to apply\n a transform to subsequent paint calls.\n\n This transform is applied after the current transform,\n and remains in effect until a matching call to\n the #hb_paint_funcs_pop_transform_func_t vfunc.\n\n Since: 7.0.0"]
pub type hb_paint_push_transform_func_t = ::std::option::Option<
    unsafe extern "C" fn(
        funcs: *mut hb_paint_funcs_t,
        paint_data: *mut ::std::os::raw::c_void,
        xx: f32,
        yx: f32,
        xy: f32,
        yy: f32,
        dx: f32,
        dy: f32,
        user_data: *mut ::std::os::raw::c_void,
    ),
>;
#[doc = " hb_paint_pop_transform_func_t:\n @funcs: paint functions object\n @paint_data: The data accompanying the paint functions in hb_font_paint_glyph()\n @user_data: User data pointer passed to hb_paint_funcs_set_pop_transform_func()\n\n A virtual method for the #hb_paint_funcs_t to undo\n the effect of a prior call to the #hb_paint_funcs_push_transform_func_t\n vfunc.\n\n Since: 7.0.0"]
pub type hb_paint_pop_transform_func_t = ::std::option::Option<
    unsafe extern "C" fn(
        funcs: *mut hb_paint_funcs_t,
        paint_data: *mut ::std::os::raw::c_void,
        user_data: *mut ::std::os::raw::c_void,
    ),
>;
#[doc = " hb_paint_color_glyph_func_t:\n @funcs: paint functions object\n @paint_data: The data accompanying the paint functions in hb_font_paint_glyph()\n @glyph: the glyph ID\n @font: the font\n @user_data: User data pointer passed to hb_paint_funcs_set_color_glyph_func()\n\n A virtual method for the #hb_paint_funcs_t to render a color glyph by glyph index.\n\n Return value: %true if the glyph was painted, %false otherwise.\n\n Since: 8.2.0"]
pub type hb_paint_color_glyph_func_t = ::std::option::Option<
    unsafe extern "C" fn(
        funcs: *mut hb_paint_funcs_t,
        paint_data: *mut ::std::os::raw::c_void,
        glyph: hb_codepoint_t,
        font: *mut hb_font_t,
        user_data: *mut ::std::os::raw::c_void,
    ) -> hb_bool_t,
>;
#[doc = " hb_paint_push_clip_glyph_func_t:\n @funcs: paint functions object\n @paint_data: The data accompanying the paint functions in hb_font_paint_glyph()\n @glyph: the glyph ID\n @font: the font\n @user_data: User data pointer passed to hb_paint_funcs_set_push_clip_glyph_func()\n\n A virtual method for the #hb_paint_funcs_t to clip\n subsequent paint calls to the outline of a glyph.\n\n The coordinates of the glyph outline are interpreted according\n to the current transform.\n\n This clip is applied in addition to the current clip,\n and remains in effect until a matching call to\n the #hb_paint_funcs_pop_clip_func_t vfunc.\n\n Since: 7.0.0"]
pub type hb_paint_push_clip_glyph_func_t = ::std::option::Option<
    unsafe extern "C" fn(
        funcs: *mut hb_paint_funcs_t,
        paint_data: *mut ::std::os::raw::c_void,
        glyph: hb_codepoint_t,
        font: *mut hb_font_t,
        user_data: *mut ::std::os::raw::c_void,
    ),
>;
#[doc = " hb_paint_push_clip_rectangle_func_t:\n @funcs: paint functions object\n @paint_data: The data accompanying the paint functions in hb_font_paint_glyph()\n @xmin: min X for the rectangle\n @ymin: min Y for the rectangle\n @xmax: max X for the rectangle\n @ymax: max Y for the rectangle\n @user_data: User data pointer passed to hb_paint_funcs_set_push_clip_rectangle_func()\n\n A virtual method for the #hb_paint_funcs_t to clip\n subsequent paint calls to a rectangle.\n\n The coordinates of the rectangle are interpreted according\n to the current transform.\n\n This clip is applied in addition to the current clip,\n and remains in effect until a matching call to\n the #hb_paint_funcs_pop_clip_func_t vfunc.\n\n Since: 7.0.0"]
pub type hb_paint_push_clip_rectangle_func_t = ::std::option::Option<
    unsafe extern "C" fn(
        funcs: *mut hb_paint_funcs_t,
        paint_data: *mut ::std::os::raw::c_void,
        xmin: f32,
        ymin: f32,
        xmax: f32,
        ymax: f32,
        user_data: *mut ::std::os::raw::c_void,
    ),
>;
#[doc = " hb_paint_pop_clip_func_t:\n @funcs: paint functions object\n @paint_data: The data accompanying the paint functions in hb_font_paint_glyph()\n @user_data: User data pointer passed to hb_paint_funcs_set_pop_clip_func()\n\n A virtual method for the #hb_paint_funcs_t to undo\n the effect of a prior call to the #hb_paint_funcs_push_clip_glyph_func_t\n or #hb_paint_funcs_push_clip_rectangle_func_t vfuncs.\n\n Since: 7.0.0"]
pub type hb_paint_pop_clip_func_t = ::std::option::Option<
    unsafe extern "C" fn(
        funcs: *mut hb_paint_funcs_t,
        paint_data: *mut ::std::os::raw::c_void,
        user_data: *mut ::std::os::raw::c_void,
    ),
>;
#[doc = " hb_paint_color_func_t:\n @funcs: paint functions object\n @paint_data: The data accompanying the paint functions in hb_font_paint_glyph()\n @is_foreground: whether the color is the foreground\n @color: The color to use, unpremultiplied\n @user_data: User data pointer passed to hb_paint_funcs_set_color_func()\n\n A virtual method for the #hb_paint_funcs_t to paint a\n color everywhere within the current clip.\n\n Since: 7.0.0"]
pub type hb_paint_color_func_t = ::std::option::Option<
    unsafe extern "C" fn(
        funcs: *mut hb_paint_funcs_t,
        paint_data: *mut ::std::os::raw::c_void,
        is_foreground: hb_bool_t,
        color: hb_color_t,
        user_data: *mut ::std::os::raw::c_void,
    ),
>;
#[doc = " hb_paint_image_func_t:\n @funcs: paint functions object\n @paint_data: The data accompanying the paint functions in hb_font_paint_glyph()\n @image: the image data\n @width: width of the raster image in pixels, or 0\n @height: height of the raster image in pixels, or 0\n @format: the image format as a tag\n @slant: the synthetic slant ratio to be applied to the image during rendering\n @extents: (nullable): glyph extents for desired rendering\n @user_data: User data pointer passed to hb_paint_funcs_set_image_func()\n\n A virtual method for the #hb_paint_funcs_t to paint a glyph image.\n\n This method is called for glyphs with image blobs in the CBDT,\n sbix or SVG tables. The @format identifies the kind of data that\n is contained in @image. Possible values include #HB_PAINT_IMAGE_FORMAT_PNG,\n #HB_PAINT_IMAGE_FORMAT_SVG and #HB_PAINT_IMAGE_FORMAT_BGRA.\n\n The image dimensions and glyph extents are provided if available,\n and should be used to size and position the image.\n\n Return value: Whether the operation was successful.\n\n Since: 7.0.0"]
pub type hb_paint_image_func_t = ::std::option::Option<
    unsafe extern "C" fn(
        funcs: *mut hb_paint_funcs_t,
        paint_data: *mut ::std::os::raw::c_void,
        image: *mut hb_blob_t,
        width: ::std::os::raw::c_uint,
        height: ::std::os::raw::c_uint,
        format: hb_tag_t,
        slant: f32,
        extents: *mut hb_glyph_extents_t,
        user_data: *mut ::std::os::raw::c_void,
    ) -> hb_bool_t,
>;
#[doc = " hb_color_stop_t:\n @offset: the offset of the color stop\n @is_foreground: whether the color is the foreground\n @color: the color, unpremultiplied\n\n Information about a color stop on a color line.\n\n Color lines typically have offsets ranging between 0 and 1,\n but that is not required.\n\n Note: despite @color being unpremultiplied here, interpolation in\n gradients shall happen in premultiplied space. See the OpenType spec\n [COLR](https://learn.microsoft.com/en-us/typography/opentype/spec/colr)\n section for details.\n\n Since: 7.0.0"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct hb_color_stop_t {
    pub offset: f32,
    pub is_foreground: hb_bool_t,
    pub color: hb_color_t,
}
#[test]
fn bindgen_test_layout_hb_color_stop_t() {
    const UNINIT: ::std::mem::MaybeUninit<hb_color_stop_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<hb_color_stop_t>(),
        12usize,
        concat!("Size of: ", stringify!(hb_color_stop_t))
    );
    assert_eq!(
        ::std::mem::align_of::<hb_color_stop_t>(),
        4usize,
        concat!("Alignment of ", stringify!(hb_color_stop_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).offset) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(hb_color_stop_t),
            "::",
            stringify!(offset)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).is_foreground) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(hb_color_stop_t),
            "::",
            stringify!(is_foreground)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).color) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(hb_color_stop_t),
            "::",
            stringify!(color)
        )
    );
}
pub const hb_paint_extend_t_HB_PAINT_EXTEND_PAD: hb_paint_extend_t = 0;
pub const hb_paint_extend_t_HB_PAINT_EXTEND_REPEAT: hb_paint_extend_t = 1;
pub const hb_paint_extend_t_HB_PAINT_EXTEND_REFLECT: hb_paint_extend_t = 2;
#[doc = " hb_paint_extend_t:\n @HB_PAINT_EXTEND_PAD: Outside the defined interval,\n   the color of the closest color stop is used.\n @HB_PAINT_EXTEND_REPEAT: The color line is repeated over\n   repeated multiples of the defined interval\n @HB_PAINT_EXTEND_REFLECT: The color line is repeated over\n      repeated intervals, as for the repeat mode.\n      However, in each repeated interval, the ordering of\n      color stops is the reverse of the adjacent interval.\n\n The values of this enumeration determine how color values\n outside the minimum and maximum defined offset on a #hb_color_line_t\n are determined.\n\n See the OpenType spec [COLR](https://learn.microsoft.com/en-us/typography/opentype/spec/colr)\n section for details.\n\n Since: 7.0.0"]
pub type hb_paint_extend_t = ::std::os::raw::c_uint;
#[doc = " hb_color_line_get_color_stops_func_t:\n @color_line: a #hb_color_line_t object\n @color_line_data: the data accompanying @color_line\n @start: the index of the first color stop to return\n @count: (inout) (optional): Input = the maximum number of feature tags to return;\n     Output = the actual number of feature tags returned (may be zero)\n @color_stops: (out) (array length=count) (optional): Array of #hb_color_stop_t to populate\n @user_data: the data accompanying this method\n\n A virtual method for the #hb_color_line_t to fetch color stops.\n\n Return value: the total number of color stops in @color_line\n\n Since: 7.0.0"]
pub type hb_color_line_get_color_stops_func_t = ::std::option::Option<
    unsafe extern "C" fn(
        color_line: *mut hb_color_line_t,
        color_line_data: *mut ::std::os::raw::c_void,
        start: ::std::os::raw::c_uint,
        count: *mut ::std::os::raw::c_uint,
        color_stops: *mut hb_color_stop_t,
        user_data: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_uint,
>;
#[doc = " hb_color_line_get_extend_func_t:\n @color_line: a #hb_color_line_t object\n @color_line_data: the data accompanying @color_line\n @user_data: the data accompanying this method\n\n A virtual method for the @hb_color_line_t to fetches the extend mode.\n\n Return value: the extend mode of @color_line\n\n Since: 7.0.0"]
pub type hb_color_line_get_extend_func_t = ::std::option::Option<
    unsafe extern "C" fn(
        color_line: *mut hb_color_line_t,
        color_line_data: *mut ::std::os::raw::c_void,
        user_data: *mut ::std::os::raw::c_void,
    ) -> hb_paint_extend_t,
>;
#[doc = " hb_color_line_t:\n\n A struct containing color information for a gradient.\n\n Since: 7.0.0"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct hb_color_line_t {
    pub data: *mut ::std::os::raw::c_void,
    pub get_color_stops: hb_color_line_get_color_stops_func_t,
    pub get_color_stops_user_data: *mut ::std::os::raw::c_void,
    pub get_extend: hb_color_line_get_extend_func_t,
    pub get_extend_user_data: *mut ::std::os::raw::c_void,
    pub reserved0: *mut ::std::os::raw::c_void,
    pub reserved1: *mut ::std::os::raw::c_void,
    pub reserved2: *mut ::std::os::raw::c_void,
    pub reserved3: *mut ::std::os::raw::c_void,
    pub reserved5: *mut ::std::os::raw::c_void,
    pub reserved6: *mut ::std::os::raw::c_void,
    pub reserved7: *mut ::std::os::raw::c_void,
    pub reserved8: *mut ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout_hb_color_line_t() {
    const UNINIT: ::std::mem::MaybeUninit<hb_color_line_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<hb_color_line_t>(),
        104usize,
        concat!("Size of: ", stringify!(hb_color_line_t))
    );
    assert_eq!(
        ::std::mem::align_of::<hb_color_line_t>(),
        8usize,
        concat!("Alignment of ", stringify!(hb_color_line_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).data) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(hb_color_line_t),
            "::",
            stringify!(data)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).get_color_stops) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(hb_color_line_t),
            "::",
            stringify!(get_color_stops)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).get_color_stops_user_data) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(hb_color_line_t),
            "::",
            stringify!(get_color_stops_user_data)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).get_extend) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(hb_color_line_t),
            "::",
            stringify!(get_extend)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).get_extend_user_data) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(hb_color_line_t),
            "::",
            stringify!(get_extend_user_data)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).reserved0) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(hb_color_line_t),
            "::",
            stringify!(reserved0)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).reserved1) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(hb_color_line_t),
            "::",
            stringify!(reserved1)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).reserved2) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(hb_color_line_t),
            "::",
            stringify!(reserved2)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).reserved3) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(hb_color_line_t),
            "::",
            stringify!(reserved3)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).reserved5) as usize - ptr as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(hb_color_line_t),
            "::",
            stringify!(reserved5)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).reserved6) as usize - ptr as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(hb_color_line_t),
            "::",
            stringify!(reserved6)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).reserved7) as usize - ptr as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(hb_color_line_t),
            "::",
            stringify!(reserved7)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).reserved8) as usize - ptr as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(hb_color_line_t),
            "::",
            stringify!(reserved8)
        )
    );
}
extern "C" {
    pub fn hb_color_line_get_color_stops(
        color_line: *mut hb_color_line_t,
        start: ::std::os::raw::c_uint,
        count: *mut ::std::os::raw::c_uint,
        color_stops: *mut hb_color_stop_t,
    ) -> ::std::os::raw::c_uint;
}
extern "C" {
    pub fn hb_color_line_get_extend(color_line: *mut hb_color_line_t) -> hb_paint_extend_t;
}
#[doc = " hb_paint_linear_gradient_func_t:\n @funcs: paint functions object\n @paint_data: The data accompanying the paint functions in hb_font_paint_glyph()\n @color_line: Color information for the gradient\n @x0: X coordinate of the first point\n @y0: Y coordinate of the first point\n @x1: X coordinate of the second point\n @y1: Y coordinate of the second point\n @x2: X coordinate of the third point\n @y2: Y coordinate of the third point\n @user_data: User data pointer passed to hb_paint_funcs_set_linear_gradient_func()\n\n A virtual method for the #hb_paint_funcs_t to paint a linear\n gradient everywhere within the current clip.\n\n The @color_line object contains information about the colors of the gradients.\n It is only valid for the duration of the callback, you cannot keep it around.\n\n The coordinates of the points are interpreted according\n to the current transform.\n\n See the OpenType spec [COLR](https://learn.microsoft.com/en-us/typography/opentype/spec/colr)\n section for details on how the points define the direction\n of the gradient, and how to interpret the @color_line.\n\n Since: 7.0.0"]
pub type hb_paint_linear_gradient_func_t = ::std::option::Option<
    unsafe extern "C" fn(
        funcs: *mut hb_paint_funcs_t,
        paint_data: *mut ::std::os::raw::c_void,
        color_line: *mut hb_color_line_t,
        x0: f32,
        y0: f32,
        x1: f32,
        y1: f32,
        x2: f32,
        y2: f32,
        user_data: *mut ::std::os::raw::c_void,
    ),
>;
#[doc = " hb_paint_radial_gradient_func_t:\n @funcs: paint functions object\n @paint_data: The data accompanying the paint functions in hb_font_paint_glyph()\n @color_line: Color information for the gradient\n @x0: X coordinate of the first circle's center\n @y0: Y coordinate of the first circle's center\n @r0: radius of the first circle\n @x1: X coordinate of the second circle's center\n @y1: Y coordinate of the second circle's center\n @r1: radius of the second circle\n @user_data: User data pointer passed to hb_paint_funcs_set_radial_gradient_func()\n\n A virtual method for the #hb_paint_funcs_t to paint a radial\n gradient everywhere within the current clip.\n\n The @color_line object contains information about the colors of the gradients.\n It is only valid for the duration of the callback, you cannot keep it around.\n\n The coordinates of the points are interpreted according\n to the current transform.\n\n See the OpenType spec [COLR](https://learn.microsoft.com/en-us/typography/opentype/spec/colr)\n section for details on how the points define the direction\n of the gradient, and how to interpret the @color_line.\n\n Since: 7.0.0"]
pub type hb_paint_radial_gradient_func_t = ::std::option::Option<
    unsafe extern "C" fn(
        funcs: *mut hb_paint_funcs_t,
        paint_data: *mut ::std::os::raw::c_void,
        color_line: *mut hb_color_line_t,
        x0: f32,
        y0: f32,
        r0: f32,
        x1: f32,
        y1: f32,
        r1: f32,
        user_data: *mut ::std::os::raw::c_void,
    ),
>;
#[doc = " hb_paint_sweep_gradient_func_t:\n @funcs: paint functions object\n @paint_data: The data accompanying the paint functions in hb_font_paint_glyph()\n @color_line: Color information for the gradient\n @x0: X coordinate of the circle's center\n @y0: Y coordinate of the circle's center\n @start_angle: the start angle, in radians\n @end_angle: the end angle, in radians\n @user_data: User data pointer passed to hb_paint_funcs_set_sweep_gradient_func()\n\n A virtual method for the #hb_paint_funcs_t to paint a sweep\n gradient everywhere within the current clip.\n\n The @color_line object contains information about the colors of the gradients.\n It is only valid for the duration of the callback, you cannot keep it around.\n\n The coordinates of the points are interpreted according\n to the current transform.\n\n See the OpenType spec [COLR](https://learn.microsoft.com/en-us/typography/opentype/spec/colr)\n section for details on how the points define the direction\n of the gradient, and how to interpret the @color_line.\n\n Since: 7.0.0"]
pub type hb_paint_sweep_gradient_func_t = ::std::option::Option<
    unsafe extern "C" fn(
        funcs: *mut hb_paint_funcs_t,
        paint_data: *mut ::std::os::raw::c_void,
        color_line: *mut hb_color_line_t,
        x0: f32,
        y0: f32,
        start_angle: f32,
        end_angle: f32,
        user_data: *mut ::std::os::raw::c_void,
    ),
>;
pub const hb_paint_composite_mode_t_HB_PAINT_COMPOSITE_MODE_CLEAR: hb_paint_composite_mode_t = 0;
pub const hb_paint_composite_mode_t_HB_PAINT_COMPOSITE_MODE_SRC: hb_paint_composite_mode_t = 1;
pub const hb_paint_composite_mode_t_HB_PAINT_COMPOSITE_MODE_DEST: hb_paint_composite_mode_t = 2;
pub const hb_paint_composite_mode_t_HB_PAINT_COMPOSITE_MODE_SRC_OVER: hb_paint_composite_mode_t = 3;
pub const hb_paint_composite_mode_t_HB_PAINT_COMPOSITE_MODE_DEST_OVER: hb_paint_composite_mode_t =
    4;
pub const hb_paint_composite_mode_t_HB_PAINT_COMPOSITE_MODE_SRC_IN: hb_paint_composite_mode_t = 5;
pub const hb_paint_composite_mode_t_HB_PAINT_COMPOSITE_MODE_DEST_IN: hb_paint_composite_mode_t = 6;
pub const hb_paint_composite_mode_t_HB_PAINT_COMPOSITE_MODE_SRC_OUT: hb_paint_composite_mode_t = 7;
pub const hb_paint_composite_mode_t_HB_PAINT_COMPOSITE_MODE_DEST_OUT: hb_paint_composite_mode_t = 8;
pub const hb_paint_composite_mode_t_HB_PAINT_COMPOSITE_MODE_SRC_ATOP: hb_paint_composite_mode_t = 9;
pub const hb_paint_composite_mode_t_HB_PAINT_COMPOSITE_MODE_DEST_ATOP: hb_paint_composite_mode_t =
    10;
pub const hb_paint_composite_mode_t_HB_PAINT_COMPOSITE_MODE_XOR: hb_paint_composite_mode_t = 11;
pub const hb_paint_composite_mode_t_HB_PAINT_COMPOSITE_MODE_PLUS: hb_paint_composite_mode_t = 12;
pub const hb_paint_composite_mode_t_HB_PAINT_COMPOSITE_MODE_SCREEN: hb_paint_composite_mode_t = 13;
pub const hb_paint_composite_mode_t_HB_PAINT_COMPOSITE_MODE_OVERLAY: hb_paint_composite_mode_t = 14;
pub const hb_paint_composite_mode_t_HB_PAINT_COMPOSITE_MODE_DARKEN: hb_paint_composite_mode_t = 15;
pub const hb_paint_composite_mode_t_HB_PAINT_COMPOSITE_MODE_LIGHTEN: hb_paint_composite_mode_t = 16;
pub const hb_paint_composite_mode_t_HB_PAINT_COMPOSITE_MODE_COLOR_DODGE: hb_paint_composite_mode_t =
    17;
pub const hb_paint_composite_mode_t_HB_PAINT_COMPOSITE_MODE_COLOR_BURN: hb_paint_composite_mode_t =
    18;
pub const hb_paint_composite_mode_t_HB_PAINT_COMPOSITE_MODE_HARD_LIGHT: hb_paint_composite_mode_t =
    19;
pub const hb_paint_composite_mode_t_HB_PAINT_COMPOSITE_MODE_SOFT_LIGHT: hb_paint_composite_mode_t =
    20;
pub const hb_paint_composite_mode_t_HB_PAINT_COMPOSITE_MODE_DIFFERENCE: hb_paint_composite_mode_t =
    21;
pub const hb_paint_composite_mode_t_HB_PAINT_COMPOSITE_MODE_EXCLUSION: hb_paint_composite_mode_t =
    22;
pub const hb_paint_composite_mode_t_HB_PAINT_COMPOSITE_MODE_MULTIPLY: hb_paint_composite_mode_t =
    23;
pub const hb_paint_composite_mode_t_HB_PAINT_COMPOSITE_MODE_HSL_HUE: hb_paint_composite_mode_t = 24;
pub const hb_paint_composite_mode_t_HB_PAINT_COMPOSITE_MODE_HSL_SATURATION:
    hb_paint_composite_mode_t = 25;
pub const hb_paint_composite_mode_t_HB_PAINT_COMPOSITE_MODE_HSL_COLOR: hb_paint_composite_mode_t =
    26;
pub const hb_paint_composite_mode_t_HB_PAINT_COMPOSITE_MODE_HSL_LUMINOSITY:
    hb_paint_composite_mode_t = 27;
#[doc = " hb_paint_composite_mode_t:\n @HB_PAINT_COMPOSITE_MODE_CLEAR: clear destination layer (bounded)\n @HB_PAINT_COMPOSITE_MODE_SRC: replace destination layer (bounded)\n @HB_PAINT_COMPOSITE_MODE_SRC_OVER: draw source layer on top of destination layer\n (bounded)\n @HB_PAINT_COMPOSITE_MODE_SRC_IN: draw source where there was destination content\n (unbounded)\n @HB_PAINT_COMPOSITE_MODE_SRC_OUT: draw source where there was no destination\n content (unbounded)\n @HB_PAINT_COMPOSITE_MODE_SRC_ATOP: draw source on top of destination content and\n only there\n @HB_PAINT_COMPOSITE_MODE_DEST: ignore the source\n @HB_PAINT_COMPOSITE_MODE_DEST_OVER: draw destination on top of source\n @HB_PAINT_COMPOSITE_MODE_DEST_IN: leave destination only where there was\n source content (unbounded)\n @HB_PAINT_COMPOSITE_MODE_DEST_OUT: leave destination only where there was no\n source content\n @HB_PAINT_COMPOSITE_MODE_DEST_ATOP: leave destination on top of source content\n and only there (unbounded)\n @HB_PAINT_COMPOSITE_MODE_XOR: source and destination are shown where there is only\n one of them\n @HB_PAINT_COMPOSITE_MODE_PLUS: source and destination layers are accumulated\n @HB_PAINT_COMPOSITE_MODE_MULTIPLY: source and destination layers are multiplied.\n This causes the result to be at least as dark as the darker inputs.\n @HB_PAINT_COMPOSITE_MODE_SCREEN: source and destination are complemented and\n multiplied. This causes the result to be at least as light as the lighter\n inputs.\n @HB_PAINT_COMPOSITE_MODE_OVERLAY: multiplies or screens, depending on the\n lightness of the destination color.\n @HB_PAINT_COMPOSITE_MODE_DARKEN: replaces the destination with the source if it\n is darker, otherwise keeps the source.\n @HB_PAINT_COMPOSITE_MODE_LIGHTEN: replaces the destination with the source if it\n is lighter, otherwise keeps the source.\n @HB_PAINT_COMPOSITE_MODE_COLOR_DODGE: brightens the destination color to reflect\n the source color.\n @HB_PAINT_COMPOSITE_MODE_COLOR_BURN: darkens the destination color to reflect\n the source color.\n @HB_PAINT_COMPOSITE_MODE_HARD_LIGHT: Multiplies or screens, dependent on source\n color.\n @HB_PAINT_COMPOSITE_MODE_SOFT_LIGHT: Darkens or lightens, dependent on source\n color.\n @HB_PAINT_COMPOSITE_MODE_DIFFERENCE: Takes the difference of the source and\n destination color.\n @HB_PAINT_COMPOSITE_MODE_EXCLUSION: Produces an effect similar to difference, but\n with lower contrast.\n @HB_PAINT_COMPOSITE_MODE_HSL_HUE: Creates a color with the hue of the source\n and the saturation and luminosity of the target.\n @HB_PAINT_COMPOSITE_MODE_HSL_SATURATION: Creates a color with the saturation\n of the source and the hue and luminosity of the target. Painting with\n this mode onto a gray area produces no change.\n @HB_PAINT_COMPOSITE_MODE_HSL_COLOR: Creates a color with the hue and saturation\n of the source and the luminosity of the target. This preserves the gray\n levels of the target and is useful for coloring monochrome images or\n tinting color images.\n @HB_PAINT_COMPOSITE_MODE_HSL_LUMINOSITY: Creates a color with the luminosity of\n the source and the hue and saturation of the target. This produces an\n inverse effect to @HB_PAINT_COMPOSITE_MODE_HSL_COLOR.\n\n The values of this enumeration describe the compositing modes\n that can be used when combining temporary redirected drawing\n with the backdrop.\n\n See the OpenType spec [COLR](https://learn.microsoft.com/en-us/typography/opentype/spec/colr)\n section for details.\n\n Since: 7.0.0"]
pub type hb_paint_composite_mode_t = ::std::os::raw::c_uint;
#[doc = " hb_paint_push_group_func_t:\n @funcs: paint functions object\n @paint_data: The data accompanying the paint functions in hb_font_paint_glyph()\n @user_data: User data pointer passed to hb_paint_funcs_set_push_group_func()\n\n A virtual method for the #hb_paint_funcs_t to use\n an intermediate surface for subsequent paint calls.\n\n The drawing will be redirected to an intermediate surface\n until a matching call to the #hb_paint_funcs_pop_group_func_t\n vfunc.\n\n Since: 7.0.0"]
pub type hb_paint_push_group_func_t = ::std::option::Option<
    unsafe extern "C" fn(
        funcs: *mut hb_paint_funcs_t,
        paint_data: *mut ::std::os::raw::c_void,
        user_data: *mut ::std::os::raw::c_void,
    ),
>;
#[doc = " hb_paint_pop_group_func_t:\n @funcs: paint functions object\n @paint_data: The data accompanying the paint functions in hb_font_paint_glyph()\n @mode: the compositing mode to use\n @user_data: User data pointer passed to hb_paint_funcs_set_pop_group_func()\n\n A virtual method for the #hb_paint_funcs_t to undo\n the effect of a prior call to the #hb_paint_funcs_push_group_func_t\n vfunc.\n\n This call stops the redirection to the intermediate surface,\n and then composites it on the previous surface, using the\n compositing mode passed to this call.\n\n Since: 7.0.0"]
pub type hb_paint_pop_group_func_t = ::std::option::Option<
    unsafe extern "C" fn(
        funcs: *mut hb_paint_funcs_t,
        paint_data: *mut ::std::os::raw::c_void,
        mode: hb_paint_composite_mode_t,
        user_data: *mut ::std::os::raw::c_void,
    ),
>;
#[doc = " hb_paint_custom_palette_color_func_t:\n @funcs: paint functions object\n @paint_data: The data accompanying the paint functions in hb_font_paint_glyph()\n @color_index: the color index\n @color: (out): fetched color\n @user_data: User data pointer passed to hb_paint_funcs_set_pop_group_func()\n\n A virtual method for the #hb_paint_funcs_t to fetch a color from the custom\n color palette.\n\n Custom palette colors override the colors from the fonts selected color\n palette. It is not necessary to override all palette entries; for entries\n that should be taken from the font palette, return `false`.\n\n This function might get called multiple times, but the custom palette is\n expected to remain unchanged for duration of a hb_font_paint_glyph() call.\n\n Return value: `true` if found, `false` otherwise\n\n Since: 7.0.0"]
pub type hb_paint_custom_palette_color_func_t = ::std::option::Option<
    unsafe extern "C" fn(
        funcs: *mut hb_paint_funcs_t,
        paint_data: *mut ::std::os::raw::c_void,
        color_index: ::std::os::raw::c_uint,
        color: *mut hb_color_t,
        user_data: *mut ::std::os::raw::c_void,
    ) -> hb_bool_t,
>;
extern "C" {
    #[doc = " hb_paint_funcs_set_push_transform_func:\n @funcs: A paint functions struct\n @func: (closure user_data) (destroy destroy) (scope notified): The push-transform callback\n @user_data: Data to pass to @func\n @destroy: (nullable): Function to call when @user_data is no longer needed\n\n Sets the push-transform callback on the paint functions struct.\n\n Since: 7.0.0"]
    pub fn hb_paint_funcs_set_push_transform_func(
        funcs: *mut hb_paint_funcs_t,
        func: hb_paint_push_transform_func_t,
        user_data: *mut ::std::os::raw::c_void,
        destroy: hb_destroy_func_t,
    );
}
extern "C" {
    #[doc = " hb_paint_funcs_set_pop_transform_func:\n @funcs: A paint functions struct\n @func: (closure user_data) (destroy destroy) (scope notified): The pop-transform callback\n @user_data: Data to pass to @func\n @destroy: (nullable): Function to call when @user_data is no longer needed\n\n Sets the pop-transform callback on the paint functions struct.\n\n Since: 7.0.0"]
    pub fn hb_paint_funcs_set_pop_transform_func(
        funcs: *mut hb_paint_funcs_t,
        func: hb_paint_pop_transform_func_t,
        user_data: *mut ::std::os::raw::c_void,
        destroy: hb_destroy_func_t,
    );
}
extern "C" {
    #[doc = " hb_paint_funcs_set_color_glyph_func:\n @funcs: A paint functions struct\n @func: (closure user_data) (destroy destroy) (scope notified): The color-glyph callback\n @user_data: Data to pass to @func\n @destroy: (nullable): Function to call when @user_data is no longer needed\n\n Sets the color-glyph callback on the paint functions struct.\n\n Since: 8.2.0"]
    pub fn hb_paint_funcs_set_color_glyph_func(
        funcs: *mut hb_paint_funcs_t,
        func: hb_paint_color_glyph_func_t,
        user_data: *mut ::std::os::raw::c_void,
        destroy: hb_destroy_func_t,
    );
}
extern "C" {
    #[doc = " hb_paint_funcs_set_push_clip_glyph_func:\n @funcs: A paint functions struct\n @func: (closure user_data) (destroy destroy) (scope notified): The push-clip-glyph callback\n @user_data: Data to pass to @func\n @destroy: (nullable): Function to call when @user_data is no longer needed\n\n Sets the push-clip-glyph callback on the paint functions struct.\n\n Since: 7.0.0"]
    pub fn hb_paint_funcs_set_push_clip_glyph_func(
        funcs: *mut hb_paint_funcs_t,
        func: hb_paint_push_clip_glyph_func_t,
        user_data: *mut ::std::os::raw::c_void,
        destroy: hb_destroy_func_t,
    );
}
extern "C" {
    #[doc = " hb_paint_funcs_set_push_clip_rectangle_func:\n @funcs: A paint functions struct\n @func: (closure user_data) (destroy destroy) (scope notified): The push-clip-rectangle callback\n @user_data: Data to pass to @func\n @destroy: (nullable): Function to call when @user_data is no longer needed\n\n Sets the push-clip-rect callback on the paint functions struct.\n\n Since: 7.0.0"]
    pub fn hb_paint_funcs_set_push_clip_rectangle_func(
        funcs: *mut hb_paint_funcs_t,
        func: hb_paint_push_clip_rectangle_func_t,
        user_data: *mut ::std::os::raw::c_void,
        destroy: hb_destroy_func_t,
    );
}
extern "C" {
    #[doc = " hb_paint_funcs_set_pop_clip_func:\n @funcs: A paint functions struct\n @func: (closure user_data) (destroy destroy) (scope notified): The pop-clip callback\n @user_data: Data to pass to @func\n @destroy: (nullable): Function to call when @user_data is no longer needed\n\n Sets the pop-clip callback on the paint functions struct.\n\n Since: 7.0.0"]
    pub fn hb_paint_funcs_set_pop_clip_func(
        funcs: *mut hb_paint_funcs_t,
        func: hb_paint_pop_clip_func_t,
        user_data: *mut ::std::os::raw::c_void,
        destroy: hb_destroy_func_t,
    );
}
extern "C" {
    #[doc = " hb_paint_funcs_set_color_func:\n @funcs: A paint functions struct\n @func: (closure user_data) (destroy destroy) (scope notified): The paint-color callback\n @user_data: Data to pass to @func\n @destroy: (nullable): Function to call when @user_data is no longer needed\n\n Sets the paint-color callback on the paint functions struct.\n\n Since: 7.0.0"]
    pub fn hb_paint_funcs_set_color_func(
        funcs: *mut hb_paint_funcs_t,
        func: hb_paint_color_func_t,
        user_data: *mut ::std::os::raw::c_void,
        destroy: hb_destroy_func_t,
    );
}
extern "C" {
    #[doc = " hb_paint_funcs_set_image_func:\n @funcs: A paint functions struct\n @func: (closure user_data) (destroy destroy) (scope notified): The paint-image callback\n @user_data: Data to pass to @func\n @destroy: (nullable): Function to call when @user_data is no longer needed\n\n Sets the paint-image callback on the paint functions struct.\n\n Since: 7.0.0"]
    pub fn hb_paint_funcs_set_image_func(
        funcs: *mut hb_paint_funcs_t,
        func: hb_paint_image_func_t,
        user_data: *mut ::std::os::raw::c_void,
        destroy: hb_destroy_func_t,
    );
}
extern "C" {
    #[doc = " hb_paint_funcs_set_linear_gradient_func:\n @funcs: A paint functions struct\n @func: (closure user_data) (destroy destroy) (scope notified): The linear-gradient callback\n @user_data: Data to pass to @func\n @destroy: (nullable): Function to call when @user_data is no longer needed\n\n Sets the linear-gradient callback on the paint functions struct.\n\n Since: 7.0.0"]
    pub fn hb_paint_funcs_set_linear_gradient_func(
        funcs: *mut hb_paint_funcs_t,
        func: hb_paint_linear_gradient_func_t,
        user_data: *mut ::std::os::raw::c_void,
        destroy: hb_destroy_func_t,
    );
}
extern "C" {
    #[doc = " hb_paint_funcs_set_radial_gradient_func:\n @funcs: A paint functions struct\n @func: (closure user_data) (destroy destroy) (scope notified): The radial-gradient callback\n @user_data: Data to pass to @func\n @destroy: (nullable): Function to call when @user_data is no longer needed\n\n Sets the radial-gradient callback on the paint functions struct.\n\n Since: 7.0.0"]
    pub fn hb_paint_funcs_set_radial_gradient_func(
        funcs: *mut hb_paint_funcs_t,
        func: hb_paint_radial_gradient_func_t,
        user_data: *mut ::std::os::raw::c_void,
        destroy: hb_destroy_func_t,
    );
}
extern "C" {
    #[doc = " hb_paint_funcs_set_sweep_gradient_func:\n @funcs: A paint functions struct\n @func: (closure user_data) (destroy destroy) (scope notified): The sweep-gradient callback\n @user_data: Data to pass to @func\n @destroy: (nullable): Function to call when @user_data is no longer needed\n\n Sets the sweep-gradient callback on the paint functions struct.\n\n Since: 7.0.0"]
    pub fn hb_paint_funcs_set_sweep_gradient_func(
        funcs: *mut hb_paint_funcs_t,
        func: hb_paint_sweep_gradient_func_t,
        user_data: *mut ::std::os::raw::c_void,
        destroy: hb_destroy_func_t,
    );
}
extern "C" {
    #[doc = " hb_paint_funcs_set_push_group_func:\n @funcs: A paint functions struct\n @func: (closure user_data) (destroy destroy) (scope notified): The push-group callback\n @user_data: Data to pass to @func\n @destroy: (nullable): Function to call when @user_data is no longer needed\n\n Sets the push-group callback on the paint functions struct.\n\n Since: 7.0.0"]
    pub fn hb_paint_funcs_set_push_group_func(
        funcs: *mut hb_paint_funcs_t,
        func: hb_paint_push_group_func_t,
        user_data: *mut ::std::os::raw::c_void,
        destroy: hb_destroy_func_t,
    );
}
extern "C" {
    #[doc = " hb_paint_funcs_set_pop_group_func:\n @funcs: A paint functions struct\n @func: (closure user_data) (destroy destroy) (scope notified): The pop-group callback\n @user_data: Data to pass to @func\n @destroy: (nullable): Function to call when @user_data is no longer needed\n\n Sets the pop-group callback on the paint functions struct.\n\n Since: 7.0.0"]
    pub fn hb_paint_funcs_set_pop_group_func(
        funcs: *mut hb_paint_funcs_t,
        func: hb_paint_pop_group_func_t,
        user_data: *mut ::std::os::raw::c_void,
        destroy: hb_destroy_func_t,
    );
}
extern "C" {
    #[doc = " hb_paint_funcs_set_custom_palette_color_func:\n @funcs: A paint functions struct\n @func: (closure user_data) (destroy destroy) (scope notified): The custom-palette-color callback\n @user_data: Data to pass to @func\n @destroy: (nullable): Function to call when @user_data is no longer needed\n\n Sets the custom-palette-color callback on the paint functions struct.\n\n Since: 7.0.0"]
    pub fn hb_paint_funcs_set_custom_palette_color_func(
        funcs: *mut hb_paint_funcs_t,
        func: hb_paint_custom_palette_color_func_t,
        user_data: *mut ::std::os::raw::c_void,
        destroy: hb_destroy_func_t,
    );
}
extern "C" {
    pub fn hb_paint_push_transform(
        funcs: *mut hb_paint_funcs_t,
        paint_data: *mut ::std::os::raw::c_void,
        xx: f32,
        yx: f32,
        xy: f32,
        yy: f32,
        dx: f32,
        dy: f32,
    );
}
extern "C" {
    pub fn hb_paint_pop_transform(
        funcs: *mut hb_paint_funcs_t,
        paint_data: *mut ::std::os::raw::c_void,
    );
}
extern "C" {
    pub fn hb_paint_color_glyph(
        funcs: *mut hb_paint_funcs_t,
        paint_data: *mut ::std::os::raw::c_void,
        glyph: hb_codepoint_t,
        font: *mut hb_font_t,
    ) -> hb_bool_t;
}
extern "C" {
    pub fn hb_paint_push_clip_glyph(
        funcs: *mut hb_paint_funcs_t,
        paint_data: *mut ::std::os::raw::c_void,
        glyph: hb_codepoint_t,
        font: *mut hb_font_t,
    );
}
extern "C" {
    pub fn hb_paint_push_clip_rectangle(
        funcs: *mut hb_paint_funcs_t,
        paint_data: *mut ::std::os::raw::c_void,
        xmin: f32,
        ymin: f32,
        xmax: f32,
        ymax: f32,
    );
}
extern "C" {
    pub fn hb_paint_pop_clip(funcs: *mut hb_paint_funcs_t, paint_data: *mut ::std::os::raw::c_void);
}
extern "C" {
    pub fn hb_paint_color(
        funcs: *mut hb_paint_funcs_t,
        paint_data: *mut ::std::os::raw::c_void,
        is_foreground: hb_bool_t,
        color: hb_color_t,
    );
}
extern "C" {
    pub fn hb_paint_image(
        funcs: *mut hb_paint_funcs_t,
        paint_data: *mut ::std::os::raw::c_void,
        image: *mut hb_blob_t,
        width: ::std::os::raw::c_uint,
        height: ::std::os::raw::c_uint,
        format: hb_tag_t,
        slant: f32,
        extents: *mut hb_glyph_extents_t,
    );
}
extern "C" {
    pub fn hb_paint_linear_gradient(
        funcs: *mut hb_paint_funcs_t,
        paint_data: *mut ::std::os::raw::c_void,
        color_line: *mut hb_color_line_t,
        x0: f32,
        y0: f32,
        x1: f32,
        y1: f32,
        x2: f32,
        y2: f32,
    );
}
extern "C" {
    pub fn hb_paint_radial_gradient(
        funcs: *mut hb_paint_funcs_t,
        paint_data: *mut ::std::os::raw::c_void,
        color_line: *mut hb_color_line_t,
        x0: f32,
        y0: f32,
        r0: f32,
        x1: f32,
        y1: f32,
        r1: f32,
    );
}
extern "C" {
    pub fn hb_paint_sweep_gradient(
        funcs: *mut hb_paint_funcs_t,
        paint_data: *mut ::std::os::raw::c_void,
        color_line: *mut hb_color_line_t,
        x0: f32,
        y0: f32,
        start_angle: f32,
        end_angle: f32,
    );
}
extern "C" {
    pub fn hb_paint_push_group(
        funcs: *mut hb_paint_funcs_t,
        paint_data: *mut ::std::os::raw::c_void,
    );
}
extern "C" {
    pub fn hb_paint_pop_group(
        funcs: *mut hb_paint_funcs_t,
        paint_data: *mut ::std::os::raw::c_void,
        mode: hb_paint_composite_mode_t,
    );
}
extern "C" {
    pub fn hb_paint_custom_palette_color(
        funcs: *mut hb_paint_funcs_t,
        paint_data: *mut ::std::os::raw::c_void,
        color_index: ::std::os::raw::c_uint,
        color: *mut hb_color_t,
    ) -> hb_bool_t;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct hb_font_funcs_t {
    _unused: [u8; 0],
}
extern "C" {
    pub fn hb_font_funcs_create() -> *mut hb_font_funcs_t;
}
extern "C" {
    pub fn hb_font_funcs_get_empty() -> *mut hb_font_funcs_t;
}
extern "C" {
    pub fn hb_font_funcs_reference(ffuncs: *mut hb_font_funcs_t) -> *mut hb_font_funcs_t;
}
extern "C" {
    pub fn hb_font_funcs_destroy(ffuncs: *mut hb_font_funcs_t);
}
extern "C" {
    pub fn hb_font_funcs_set_user_data(
        ffuncs: *mut hb_font_funcs_t,
        key: *mut hb_user_data_key_t,
        data: *mut ::std::os::raw::c_void,
        destroy: hb_destroy_func_t,
        replace: hb_bool_t,
    ) -> hb_bool_t;
}
extern "C" {
    pub fn hb_font_funcs_get_user_data(
        ffuncs: *const hb_font_funcs_t,
        key: *mut hb_user_data_key_t,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn hb_font_funcs_make_immutable(ffuncs: *mut hb_font_funcs_t);
}
extern "C" {
    pub fn hb_font_funcs_is_immutable(ffuncs: *mut hb_font_funcs_t) -> hb_bool_t;
}
#[doc = " hb_font_extents_t:\n @ascender: The height of typographic ascenders.\n @descender: The depth of typographic descenders.\n @line_gap: The suggested line-spacing gap.\n\n Font-wide extent values, measured in font units.\n\n Note that typically @ascender is positive and @descender\n negative, in coordinate systems that grow up."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct hb_font_extents_t {
    pub ascender: hb_position_t,
    pub descender: hb_position_t,
    pub line_gap: hb_position_t,
    pub reserved9: hb_position_t,
    pub reserved8: hb_position_t,
    pub reserved7: hb_position_t,
    pub reserved6: hb_position_t,
    pub reserved5: hb_position_t,
    pub reserved4: hb_position_t,
    pub reserved3: hb_position_t,
    pub reserved2: hb_position_t,
    pub reserved1: hb_position_t,
}
#[test]
fn bindgen_test_layout_hb_font_extents_t() {
    const UNINIT: ::std::mem::MaybeUninit<hb_font_extents_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<hb_font_extents_t>(),
        48usize,
        concat!("Size of: ", stringify!(hb_font_extents_t))
    );
    assert_eq!(
        ::std::mem::align_of::<hb_font_extents_t>(),
        4usize,
        concat!("Alignment of ", stringify!(hb_font_extents_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ascender) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(hb_font_extents_t),
            "::",
            stringify!(ascender)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).descender) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(hb_font_extents_t),
            "::",
            stringify!(descender)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).line_gap) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(hb_font_extents_t),
            "::",
            stringify!(line_gap)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).reserved9) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(hb_font_extents_t),
            "::",
            stringify!(reserved9)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).reserved8) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(hb_font_extents_t),
            "::",
            stringify!(reserved8)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).reserved7) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(hb_font_extents_t),
            "::",
            stringify!(reserved7)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).reserved6) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(hb_font_extents_t),
            "::",
            stringify!(reserved6)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).reserved5) as usize - ptr as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(hb_font_extents_t),
            "::",
            stringify!(reserved5)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).reserved4) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(hb_font_extents_t),
            "::",
            stringify!(reserved4)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).reserved3) as usize - ptr as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(hb_font_extents_t),
            "::",
            stringify!(reserved3)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).reserved2) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(hb_font_extents_t),
            "::",
            stringify!(reserved2)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).reserved1) as usize - ptr as usize },
        44usize,
        concat!(
            "Offset of field: ",
            stringify!(hb_font_extents_t),
            "::",
            stringify!(reserved1)
        )
    );
}
#[doc = " hb_font_get_font_extents_func_t:\n @font: #hb_font_t to work upon\n @font_data: @font user data pointer\n @extents: (out): The font extents retrieved\n @user_data: User data pointer passed by the caller\n\n This method should retrieve the extents for a font.\n"]
pub type hb_font_get_font_extents_func_t = ::std::option::Option<
    unsafe extern "C" fn(
        font: *mut hb_font_t,
        font_data: *mut ::std::os::raw::c_void,
        extents: *mut hb_font_extents_t,
        user_data: *mut ::std::os::raw::c_void,
    ) -> hb_bool_t,
>;
#[doc = " hb_font_get_font_h_extents_func_t:\n\n A virtual method for the #hb_font_funcs_t of an #hb_font_t object.\n\n This method should retrieve the extents for a font, for horizontal-direction\n text segments. Extents must be returned in an #hb_glyph_extents output\n parameter.\n"]
pub type hb_font_get_font_h_extents_func_t = hb_font_get_font_extents_func_t;
#[doc = " hb_font_get_font_v_extents_func_t:\n\n A virtual method for the #hb_font_funcs_t of an #hb_font_t object.\n\n This method should retrieve the extents for a font, for vertical-direction\n text segments. Extents must be returned in an #hb_glyph_extents output\n parameter.\n"]
pub type hb_font_get_font_v_extents_func_t = hb_font_get_font_extents_func_t;
#[doc = " hb_font_get_nominal_glyph_func_t:\n @font: #hb_font_t to work upon\n @font_data: @font user data pointer\n @unicode: The Unicode code point to query\n @glyph: (out): The glyph ID retrieved\n @user_data: User data pointer passed by the caller\n\n A virtual method for the #hb_font_funcs_t of an #hb_font_t object.\n\n This method should retrieve the nominal glyph ID for a specified Unicode code\n point. Glyph IDs must be returned in a #hb_codepoint_t output parameter.\n\n Return value: `true` if data found, `false` otherwise\n"]
pub type hb_font_get_nominal_glyph_func_t = ::std::option::Option<
    unsafe extern "C" fn(
        font: *mut hb_font_t,
        font_data: *mut ::std::os::raw::c_void,
        unicode: hb_codepoint_t,
        glyph: *mut hb_codepoint_t,
        user_data: *mut ::std::os::raw::c_void,
    ) -> hb_bool_t,
>;
#[doc = " hb_font_get_variation_glyph_func_t:\n @font: #hb_font_t to work upon\n @font_data: @font user data pointer\n @unicode: The Unicode code point to query\n @variation_selector: The  variation-selector code point to query\n @glyph: (out): The glyph ID retrieved\n @user_data: User data pointer passed by the caller\n\n A virtual method for the #hb_font_funcs_t of an #hb_font_t object.\n\n This method should retrieve the glyph ID for a specified Unicode code point\n followed by a specified Variation Selector code point. Glyph IDs must be\n returned in a #hb_codepoint_t output parameter.\n\n Return value: `true` if data found, `false` otherwise\n"]
pub type hb_font_get_variation_glyph_func_t = ::std::option::Option<
    unsafe extern "C" fn(
        font: *mut hb_font_t,
        font_data: *mut ::std::os::raw::c_void,
        unicode: hb_codepoint_t,
        variation_selector: hb_codepoint_t,
        glyph: *mut hb_codepoint_t,
        user_data: *mut ::std::os::raw::c_void,
    ) -> hb_bool_t,
>;
#[doc = " hb_font_get_nominal_glyphs_func_t:\n @font: #hb_font_t to work upon\n @font_data: @font user data pointer\n @count: number of code points to query\n @first_unicode: The first Unicode code point to query\n @unicode_stride: The stride between successive code points\n @first_glyph: (out): The first glyph ID retrieved\n @glyph_stride: The stride between successive glyph IDs\n @user_data: User data pointer passed by the caller\n\n A virtual method for the #hb_font_funcs_t of an #hb_font_t object.\n\n This method should retrieve the nominal glyph IDs for a sequence of\n Unicode code points. Glyph IDs must be returned in a #hb_codepoint_t\n output parameter.\n\n Return value: the number of code points processed\n"]
pub type hb_font_get_nominal_glyphs_func_t = ::std::option::Option<
    unsafe extern "C" fn(
        font: *mut hb_font_t,
        font_data: *mut ::std::os::raw::c_void,
        count: ::std::os::raw::c_uint,
        first_unicode: *const hb_codepoint_t,
        unicode_stride: ::std::os::raw::c_uint,
        first_glyph: *mut hb_codepoint_t,
        glyph_stride: ::std::os::raw::c_uint,
        user_data: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_uint,
>;
#[doc = " hb_font_get_glyph_advance_func_t:\n @font: #hb_font_t to work upon\n @font_data: @font user data pointer\n @glyph: The glyph ID to query\n @user_data: User data pointer passed by the caller\n\n A virtual method for the #hb_font_funcs_t of an #hb_font_t object.\n\n This method should retrieve the advance for a specified glyph. The\n method must return an #hb_position_t.\n\n Return value: The advance of @glyph within @font\n"]
pub type hb_font_get_glyph_advance_func_t = ::std::option::Option<
    unsafe extern "C" fn(
        font: *mut hb_font_t,
        font_data: *mut ::std::os::raw::c_void,
        glyph: hb_codepoint_t,
        user_data: *mut ::std::os::raw::c_void,
    ) -> hb_position_t,
>;
#[doc = " hb_font_get_glyph_h_advance_func_t:\n\n A virtual method for the #hb_font_funcs_t of an #hb_font_t object.\n\n This method should retrieve the advance for a specified glyph, in\n horizontal-direction text segments. Advances must be returned in\n an #hb_position_t output parameter.\n"]
pub type hb_font_get_glyph_h_advance_func_t = hb_font_get_glyph_advance_func_t;
#[doc = " hb_font_get_glyph_v_advance_func_t:\n\n A virtual method for the #hb_font_funcs_t of an #hb_font_t object.\n\n This method should retrieve the advance for a specified glyph, in\n vertical-direction text segments. Advances must be returned in\n an #hb_position_t output parameter.\n"]
pub type hb_font_get_glyph_v_advance_func_t = hb_font_get_glyph_advance_func_t;
#[doc = " hb_font_get_glyph_advances_func_t:\n @font: #hb_font_t to work upon\n @font_data: @font user data pointer\n @count: The number of glyph IDs in the sequence queried\n @first_glyph: The first glyph ID to query\n @glyph_stride: The stride between successive glyph IDs\n @first_advance: (out): The first advance retrieved\n @advance_stride: The stride between successive advances\n @user_data: User data pointer passed by the caller\n\n A virtual method for the #hb_font_funcs_t of an #hb_font_t object.\n\n This method should retrieve the advances for a sequence of glyphs.\n"]
pub type hb_font_get_glyph_advances_func_t = ::std::option::Option<
    unsafe extern "C" fn(
        font: *mut hb_font_t,
        font_data: *mut ::std::os::raw::c_void,
        count: ::std::os::raw::c_uint,
        first_glyph: *const hb_codepoint_t,
        glyph_stride: ::std::os::raw::c_uint,
        first_advance: *mut hb_position_t,
        advance_stride: ::std::os::raw::c_uint,
        user_data: *mut ::std::os::raw::c_void,
    ),
>;
#[doc = " hb_font_get_glyph_h_advances_func_t:\n\n A virtual method for the #hb_font_funcs_t of an #hb_font_t object.\n\n This method should retrieve the advances for a sequence of glyphs, in\n horizontal-direction text segments.\n"]
pub type hb_font_get_glyph_h_advances_func_t = hb_font_get_glyph_advances_func_t;
#[doc = " hb_font_get_glyph_v_advances_func_t:\n\n A virtual method for the #hb_font_funcs_t of an #hb_font_t object.\n\n This method should retrieve the advances for a sequence of glyphs, in\n vertical-direction text segments.\n"]
pub type hb_font_get_glyph_v_advances_func_t = hb_font_get_glyph_advances_func_t;
#[doc = " hb_font_get_glyph_origin_func_t:\n @font: #hb_font_t to work upon\n @font_data: @font user data pointer\n @glyph: The glyph ID to query\n @x: (out): The X coordinate of the origin\n @y: (out): The Y coordinate of the origin\n @user_data: User data pointer passed by the caller\n\n A virtual method for the #hb_font_funcs_t of an #hb_font_t object.\n\n This method should retrieve the (X,Y) coordinates (in font units) of the\n origin for a glyph. Each coordinate must be returned in an #hb_position_t\n output parameter.\n\n Return value: `true` if data found, `false` otherwise\n"]
pub type hb_font_get_glyph_origin_func_t = ::std::option::Option<
    unsafe extern "C" fn(
        font: *mut hb_font_t,
        font_data: *mut ::std::os::raw::c_void,
        glyph: hb_codepoint_t,
        x: *mut hb_position_t,
        y: *mut hb_position_t,
        user_data: *mut ::std::os::raw::c_void,
    ) -> hb_bool_t,
>;
#[doc = " hb_font_get_glyph_h_origin_func_t:\n\n A virtual method for the #hb_font_funcs_t of an #hb_font_t object.\n\n This method should retrieve the (X,Y) coordinates (in font units) of the\n origin for a glyph, for horizontal-direction text segments. Each\n coordinate must be returned in an #hb_position_t output parameter.\n"]
pub type hb_font_get_glyph_h_origin_func_t = hb_font_get_glyph_origin_func_t;
#[doc = " hb_font_get_glyph_v_origin_func_t:\n\n A virtual method for the #hb_font_funcs_t of an #hb_font_t object.\n\n This method should retrieve the (X,Y) coordinates (in font units) of the\n origin for a glyph, for vertical-direction text segments. Each coordinate\n must be returned in an #hb_position_t output parameter.\n"]
pub type hb_font_get_glyph_v_origin_func_t = hb_font_get_glyph_origin_func_t;
#[doc = " hb_font_get_glyph_kerning_func_t:\n @font: #hb_font_t to work upon\n @font_data: @font user data pointer\n @first_glyph: The glyph ID of the first glyph in the glyph pair\n @second_glyph: The glyph ID of the second glyph in the glyph pair\n @user_data: User data pointer passed by the caller\n\n This method should retrieve the kerning-adjustment value for a glyph-pair in\n the specified font, for horizontal text segments.\n"]
pub type hb_font_get_glyph_kerning_func_t = ::std::option::Option<
    unsafe extern "C" fn(
        font: *mut hb_font_t,
        font_data: *mut ::std::os::raw::c_void,
        first_glyph: hb_codepoint_t,
        second_glyph: hb_codepoint_t,
        user_data: *mut ::std::os::raw::c_void,
    ) -> hb_position_t,
>;
#[doc = " hb_font_get_glyph_h_kerning_func_t:\n\n A virtual method for the #hb_font_funcs_t of an #hb_font_t object.\n\n This method should retrieve the kerning-adjustment value for a glyph-pair in\n the specified font, for horizontal text segments.\n"]
pub type hb_font_get_glyph_h_kerning_func_t = hb_font_get_glyph_kerning_func_t;
#[doc = " hb_font_get_glyph_extents_func_t:\n @font: #hb_font_t to work upon\n @font_data: @font user data pointer\n @glyph: The glyph ID to query\n @extents: (out): The #hb_glyph_extents_t retrieved\n @user_data: User data pointer passed by the caller\n\n A virtual method for the #hb_font_funcs_t of an #hb_font_t object.\n\n This method should retrieve the extents for a specified glyph. Extents must be\n returned in an #hb_glyph_extents output parameter.\n\n Return value: `true` if data found, `false` otherwise\n"]
pub type hb_font_get_glyph_extents_func_t = ::std::option::Option<
    unsafe extern "C" fn(
        font: *mut hb_font_t,
        font_data: *mut ::std::os::raw::c_void,
        glyph: hb_codepoint_t,
        extents: *mut hb_glyph_extents_t,
        user_data: *mut ::std::os::raw::c_void,
    ) -> hb_bool_t,
>;
#[doc = " hb_font_get_glyph_contour_point_func_t:\n @font: #hb_font_t to work upon\n @font_data: @font user data pointer\n @glyph: The glyph ID to query\n @point_index: The contour-point index to query\n @x: (out): The X value retrieved for the contour point\n @y: (out): The Y value retrieved for the contour point\n @user_data: User data pointer passed by the caller\n\n A virtual method for the #hb_font_funcs_t of an #hb_font_t object.\n\n This method should retrieve the (X,Y) coordinates (in font units) for a\n specified contour point in a glyph. Each coordinate must be returned as\n an #hb_position_t output parameter.\n\n Return value: `true` if data found, `false` otherwise\n"]
pub type hb_font_get_glyph_contour_point_func_t = ::std::option::Option<
    unsafe extern "C" fn(
        font: *mut hb_font_t,
        font_data: *mut ::std::os::raw::c_void,
        glyph: hb_codepoint_t,
        point_index: ::std::os::raw::c_uint,
        x: *mut hb_position_t,
        y: *mut hb_position_t,
        user_data: *mut ::std::os::raw::c_void,
    ) -> hb_bool_t,
>;
#[doc = " hb_font_get_glyph_name_func_t:\n @font: #hb_font_t to work upon\n @font_data: @font user data pointer\n @glyph: The glyph ID to query\n @name: (out) (array length=size): Name string retrieved for the glyph ID\n @size: Length of the glyph-name string retrieved\n @user_data: User data pointer passed by the caller\n\n A virtual method for the #hb_font_funcs_t of an #hb_font_t object.\n\n This method should retrieve the glyph name that corresponds to a\n glyph ID. The name should be returned in a string output parameter.\n\n Return value: `true` if data found, `false` otherwise\n"]
pub type hb_font_get_glyph_name_func_t = ::std::option::Option<
    unsafe extern "C" fn(
        font: *mut hb_font_t,
        font_data: *mut ::std::os::raw::c_void,
        glyph: hb_codepoint_t,
        name: *mut ::std::os::raw::c_char,
        size: ::std::os::raw::c_uint,
        user_data: *mut ::std::os::raw::c_void,
    ) -> hb_bool_t,
>;
#[doc = " hb_font_get_glyph_from_name_func_t:\n @font: #hb_font_t to work upon\n @font_data: @font user data pointer\n @name: (array length=len): The name string to query\n @len: The length of the name queried\n @glyph: (out): The glyph ID retrieved\n @user_data: User data pointer passed by the caller\n\n A virtual method for the #hb_font_funcs_t of an #hb_font_t object.\n\n This method should retrieve the glyph ID that corresponds to a glyph-name\n string.\n\n Return value: `true` if data found, `false` otherwise\n"]
pub type hb_font_get_glyph_from_name_func_t = ::std::option::Option<
    unsafe extern "C" fn(
        font: *mut hb_font_t,
        font_data: *mut ::std::os::raw::c_void,
        name: *const ::std::os::raw::c_char,
        len: ::std::os::raw::c_int,
        glyph: *mut hb_codepoint_t,
        user_data: *mut ::std::os::raw::c_void,
    ) -> hb_bool_t,
>;
#[doc = " hb_font_draw_glyph_func_t:\n @font: #hb_font_t to work upon\n @font_data: @font user data pointer\n @glyph: The glyph ID to query\n @draw_funcs: The draw functions to send the shape data to\n @draw_data: The data accompanying the draw functions\n @user_data: User data pointer passed by the caller\n\n A virtual method for the #hb_font_funcs_t of an #hb_font_t object.\n\n Since: 7.0.0\n"]
pub type hb_font_draw_glyph_func_t = ::std::option::Option<
    unsafe extern "C" fn(
        font: *mut hb_font_t,
        font_data: *mut ::std::os::raw::c_void,
        glyph: hb_codepoint_t,
        draw_funcs: *mut hb_draw_funcs_t,
        draw_data: *mut ::std::os::raw::c_void,
        user_data: *mut ::std::os::raw::c_void,
    ),
>;
#[doc = " hb_font_paint_glyph_func_t:\n @font: #hb_font_t to work upon\n @font_data: @font user data pointer\n @glyph: The glyph ID to query\n @paint_funcs: The paint functions to use\n @paint_data: The data accompanying the paint functions\n @palette_index: The color palette to use\n @foreground: The foreground color\n @user_data: User data pointer passed by the caller\n\n A virtual method for the #hb_font_funcs_t of an #hb_font_t object.\n\n Since: 7.0.0"]
pub type hb_font_paint_glyph_func_t = ::std::option::Option<
    unsafe extern "C" fn(
        font: *mut hb_font_t,
        font_data: *mut ::std::os::raw::c_void,
        glyph: hb_codepoint_t,
        paint_funcs: *mut hb_paint_funcs_t,
        paint_data: *mut ::std::os::raw::c_void,
        palette_index: ::std::os::raw::c_uint,
        foreground: hb_color_t,
        user_data: *mut ::std::os::raw::c_void,
    ),
>;
extern "C" {
    #[doc = " hb_font_funcs_set_font_h_extents_func:\n @ffuncs: A font-function structure\n @func: (closure user_data) (destroy destroy) (scope notified): The callback function to assign\n @user_data: Data to pass to @func\n @destroy: (nullable): The function to call when @user_data is not needed anymore\n\n Sets the implementation function for #hb_font_get_font_h_extents_func_t.\n\n Since: 1.1.2"]
    pub fn hb_font_funcs_set_font_h_extents_func(
        ffuncs: *mut hb_font_funcs_t,
        func: hb_font_get_font_h_extents_func_t,
        user_data: *mut ::std::os::raw::c_void,
        destroy: hb_destroy_func_t,
    );
}
extern "C" {
    #[doc = " hb_font_funcs_set_font_v_extents_func:\n @ffuncs: A font-function structure\n @func: (closure user_data) (destroy destroy) (scope notified): The callback function to assign\n @user_data: Data to pass to @func\n @destroy: (nullable): The function to call when @user_data is not needed anymore\n\n Sets the implementation function for #hb_font_get_font_v_extents_func_t.\n\n Since: 1.1.2"]
    pub fn hb_font_funcs_set_font_v_extents_func(
        ffuncs: *mut hb_font_funcs_t,
        func: hb_font_get_font_v_extents_func_t,
        user_data: *mut ::std::os::raw::c_void,
        destroy: hb_destroy_func_t,
    );
}
extern "C" {
    #[doc = " hb_font_funcs_set_nominal_glyph_func:\n @ffuncs: A font-function structure\n @func: (closure user_data) (destroy destroy) (scope notified): The callback function to assign\n @user_data: Data to pass to @func\n @destroy: (nullable): The function to call when @user_data is not needed anymore\n\n Sets the implementation function for #hb_font_get_nominal_glyph_func_t.\n\n Since: 1.2.3"]
    pub fn hb_font_funcs_set_nominal_glyph_func(
        ffuncs: *mut hb_font_funcs_t,
        func: hb_font_get_nominal_glyph_func_t,
        user_data: *mut ::std::os::raw::c_void,
        destroy: hb_destroy_func_t,
    );
}
extern "C" {
    #[doc = " hb_font_funcs_set_nominal_glyphs_func:\n @ffuncs: A font-function structure\n @func: (closure user_data) (destroy destroy) (scope notified): The callback function to assign\n @user_data: Data to pass to @func\n @destroy: (nullable): The function to call when @user_data is not needed anymore\n\n Sets the implementation function for #hb_font_get_nominal_glyphs_func_t.\n\n Since: 2.0.0"]
    pub fn hb_font_funcs_set_nominal_glyphs_func(
        ffuncs: *mut hb_font_funcs_t,
        func: hb_font_get_nominal_glyphs_func_t,
        user_data: *mut ::std::os::raw::c_void,
        destroy: hb_destroy_func_t,
    );
}
extern "C" {
    #[doc = " hb_font_funcs_set_variation_glyph_func:\n @ffuncs: A font-function structure\n @func: (closure user_data) (destroy destroy) (scope notified): The callback function to assign\n @user_data: Data to pass to @func\n @destroy: (nullable): The function to call when @user_data is not needed anymore\n\n Sets the implementation function for #hb_font_get_variation_glyph_func_t.\n\n Since: 1.2.3"]
    pub fn hb_font_funcs_set_variation_glyph_func(
        ffuncs: *mut hb_font_funcs_t,
        func: hb_font_get_variation_glyph_func_t,
        user_data: *mut ::std::os::raw::c_void,
        destroy: hb_destroy_func_t,
    );
}
extern "C" {
    #[doc = " hb_font_funcs_set_glyph_h_advance_func:\n @ffuncs: A font-function structure\n @func: (closure user_data) (destroy destroy) (scope notified): The callback function to assign\n @user_data: Data to pass to @func\n @destroy: (nullable): The function to call when @user_data is not needed anymore\n\n Sets the implementation function for #hb_font_get_glyph_h_advance_func_t.\n\n Since: 0.9.2"]
    pub fn hb_font_funcs_set_glyph_h_advance_func(
        ffuncs: *mut hb_font_funcs_t,
        func: hb_font_get_glyph_h_advance_func_t,
        user_data: *mut ::std::os::raw::c_void,
        destroy: hb_destroy_func_t,
    );
}
extern "C" {
    #[doc = " hb_font_funcs_set_glyph_v_advance_func:\n @ffuncs: A font-function structure\n @func: (closure user_data) (destroy destroy) (scope notified): The callback function to assign\n @user_data: Data to pass to @func\n @destroy: (nullable): The function to call when @user_data is not needed anymore\n\n Sets the implementation function for #hb_font_get_glyph_v_advance_func_t.\n\n Since: 0.9.2"]
    pub fn hb_font_funcs_set_glyph_v_advance_func(
        ffuncs: *mut hb_font_funcs_t,
        func: hb_font_get_glyph_v_advance_func_t,
        user_data: *mut ::std::os::raw::c_void,
        destroy: hb_destroy_func_t,
    );
}
extern "C" {
    #[doc = " hb_font_funcs_set_glyph_h_advances_func:\n @ffuncs: A font-function structure\n @func: (closure user_data) (destroy destroy) (scope notified): The callback function to assign\n @user_data: Data to pass to @func\n @destroy: (nullable): The function to call when @user_data is not needed anymore\n\n Sets the implementation function for #hb_font_get_glyph_h_advances_func_t.\n\n Since: 1.8.6"]
    pub fn hb_font_funcs_set_glyph_h_advances_func(
        ffuncs: *mut hb_font_funcs_t,
        func: hb_font_get_glyph_h_advances_func_t,
        user_data: *mut ::std::os::raw::c_void,
        destroy: hb_destroy_func_t,
    );
}
extern "C" {
    #[doc = " hb_font_funcs_set_glyph_v_advances_func:\n @ffuncs: A font-function structure\n @func: (closure user_data) (destroy destroy) (scope notified): The callback function to assign\n @user_data: Data to pass to @func\n @destroy: (nullable): The function to call when @user_data is not needed anymore\n\n Sets the implementation function for #hb_font_get_glyph_v_advances_func_t.\n\n Since: 1.8.6"]
    pub fn hb_font_funcs_set_glyph_v_advances_func(
        ffuncs: *mut hb_font_funcs_t,
        func: hb_font_get_glyph_v_advances_func_t,
        user_data: *mut ::std::os::raw::c_void,
        destroy: hb_destroy_func_t,
    );
}
extern "C" {
    #[doc = " hb_font_funcs_set_glyph_h_origin_func:\n @ffuncs: A font-function structure\n @func: (closure user_data) (destroy destroy) (scope notified): The callback function to assign\n @user_data: Data to pass to @func\n @destroy: (nullable): The function to call when @user_data is not needed anymore\n\n Sets the implementation function for #hb_font_get_glyph_h_origin_func_t.\n\n Since: 0.9.2"]
    pub fn hb_font_funcs_set_glyph_h_origin_func(
        ffuncs: *mut hb_font_funcs_t,
        func: hb_font_get_glyph_h_origin_func_t,
        user_data: *mut ::std::os::raw::c_void,
        destroy: hb_destroy_func_t,
    );
}
extern "C" {
    #[doc = " hb_font_funcs_set_glyph_v_origin_func:\n @ffuncs: A font-function structure\n @func: (closure user_data) (destroy destroy) (scope notified): The callback function to assign\n @user_data: Data to pass to @func\n @destroy: (nullable): The function to call when @user_data is not needed anymore\n\n Sets the implementation function for #hb_font_get_glyph_v_origin_func_t.\n\n Since: 0.9.2"]
    pub fn hb_font_funcs_set_glyph_v_origin_func(
        ffuncs: *mut hb_font_funcs_t,
        func: hb_font_get_glyph_v_origin_func_t,
        user_data: *mut ::std::os::raw::c_void,
        destroy: hb_destroy_func_t,
    );
}
extern "C" {
    #[doc = " hb_font_funcs_set_glyph_h_kerning_func:\n @ffuncs: A font-function structure\n @func: (closure user_data) (destroy destroy) (scope notified): The callback function to assign\n @user_data: Data to pass to @func\n @destroy: (nullable): The function to call when @user_data is not needed anymore\n\n Sets the implementation function for #hb_font_get_glyph_h_kerning_func_t.\n\n Since: 0.9.2"]
    pub fn hb_font_funcs_set_glyph_h_kerning_func(
        ffuncs: *mut hb_font_funcs_t,
        func: hb_font_get_glyph_h_kerning_func_t,
        user_data: *mut ::std::os::raw::c_void,
        destroy: hb_destroy_func_t,
    );
}
extern "C" {
    #[doc = " hb_font_funcs_set_glyph_extents_func:\n @ffuncs: A font-function structure\n @func: (closure user_data) (destroy destroy) (scope notified): The callback function to assign\n @user_data: Data to pass to @func\n @destroy: (nullable): The function to call when @user_data is not needed anymore\n\n Sets the implementation function for #hb_font_get_glyph_extents_func_t.\n\n Since: 0.9.2"]
    pub fn hb_font_funcs_set_glyph_extents_func(
        ffuncs: *mut hb_font_funcs_t,
        func: hb_font_get_glyph_extents_func_t,
        user_data: *mut ::std::os::raw::c_void,
        destroy: hb_destroy_func_t,
    );
}
extern "C" {
    #[doc = " hb_font_funcs_set_glyph_contour_point_func:\n @ffuncs: A font-function structure\n @func: (closure user_data) (destroy destroy) (scope notified): The callback function to assign\n @user_data: Data to pass to @func\n @destroy: (nullable): The function to call when @user_data is not needed anymore\n\n Sets the implementation function for #hb_font_get_glyph_contour_point_func_t.\n\n Since: 0.9.2"]
    pub fn hb_font_funcs_set_glyph_contour_point_func(
        ffuncs: *mut hb_font_funcs_t,
        func: hb_font_get_glyph_contour_point_func_t,
        user_data: *mut ::std::os::raw::c_void,
        destroy: hb_destroy_func_t,
    );
}
extern "C" {
    #[doc = " hb_font_funcs_set_glyph_name_func:\n @ffuncs: A font-function structure\n @func: (closure user_data) (destroy destroy) (scope notified): The callback function to assign\n @user_data: Data to pass to @func\n @destroy: (nullable): The function to call when @user_data is not needed anymore\n\n Sets the implementation function for #hb_font_get_glyph_name_func_t.\n\n Since: 0.9.2"]
    pub fn hb_font_funcs_set_glyph_name_func(
        ffuncs: *mut hb_font_funcs_t,
        func: hb_font_get_glyph_name_func_t,
        user_data: *mut ::std::os::raw::c_void,
        destroy: hb_destroy_func_t,
    );
}
extern "C" {
    #[doc = " hb_font_funcs_set_glyph_from_name_func:\n @ffuncs: A font-function structure\n @func: (closure user_data) (destroy destroy) (scope notified): The callback function to assign\n @user_data: Data to pass to @func\n @destroy: (nullable): The function to call when @user_data is not needed anymore\n\n Sets the implementation function for #hb_font_get_glyph_from_name_func_t.\n\n Since: 0.9.2"]
    pub fn hb_font_funcs_set_glyph_from_name_func(
        ffuncs: *mut hb_font_funcs_t,
        func: hb_font_get_glyph_from_name_func_t,
        user_data: *mut ::std::os::raw::c_void,
        destroy: hb_destroy_func_t,
    );
}
extern "C" {
    #[doc = " hb_font_funcs_set_draw_glyph_func:\n @ffuncs: A font-function structure\n @func: (closure user_data) (destroy destroy) (scope notified): The callback function to assign\n @user_data: Data to pass to @func\n @destroy: (nullable): The function to call when @user_data is not needed anymore\n\n Sets the implementation function for #hb_font_draw_glyph_func_t.\n\n Since: 7.0.0"]
    pub fn hb_font_funcs_set_draw_glyph_func(
        ffuncs: *mut hb_font_funcs_t,
        func: hb_font_draw_glyph_func_t,
        user_data: *mut ::std::os::raw::c_void,
        destroy: hb_destroy_func_t,
    );
}
extern "C" {
    #[doc = " hb_font_funcs_set_paint_glyph_func:\n @ffuncs: A font-function structure\n @func: (closure user_data) (destroy destroy) (scope notified): The callback function to assign\n @user_data: Data to pass to @func\n @destroy: (nullable): The function to call when @user_data is no longer needed\n\n Sets the implementation function for #hb_font_paint_glyph_func_t.\n\n Since: 7.0.0"]
    pub fn hb_font_funcs_set_paint_glyph_func(
        ffuncs: *mut hb_font_funcs_t,
        func: hb_font_paint_glyph_func_t,
        user_data: *mut ::std::os::raw::c_void,
        destroy: hb_destroy_func_t,
    );
}
extern "C" {
    pub fn hb_font_get_h_extents(
        font: *mut hb_font_t,
        extents: *mut hb_font_extents_t,
    ) -> hb_bool_t;
}
extern "C" {
    pub fn hb_font_get_v_extents(
        font: *mut hb_font_t,
        extents: *mut hb_font_extents_t,
    ) -> hb_bool_t;
}
extern "C" {
    pub fn hb_font_get_nominal_glyph(
        font: *mut hb_font_t,
        unicode: hb_codepoint_t,
        glyph: *mut hb_codepoint_t,
    ) -> hb_bool_t;
}
extern "C" {
    pub fn hb_font_get_variation_glyph(
        font: *mut hb_font_t,
        unicode: hb_codepoint_t,
        variation_selector: hb_codepoint_t,
        glyph: *mut hb_codepoint_t,
    ) -> hb_bool_t;
}
extern "C" {
    pub fn hb_font_get_nominal_glyphs(
        font: *mut hb_font_t,
        count: ::std::os::raw::c_uint,
        first_unicode: *const hb_codepoint_t,
        unicode_stride: ::std::os::raw::c_uint,
        first_glyph: *mut hb_codepoint_t,
        glyph_stride: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_uint;
}
extern "C" {
    pub fn hb_font_get_glyph_h_advance(
        font: *mut hb_font_t,
        glyph: hb_codepoint_t,
    ) -> hb_position_t;
}
extern "C" {
    pub fn hb_font_get_glyph_v_advance(
        font: *mut hb_font_t,
        glyph: hb_codepoint_t,
    ) -> hb_position_t;
}
extern "C" {
    pub fn hb_font_get_glyph_h_advances(
        font: *mut hb_font_t,
        count: ::std::os::raw::c_uint,
        first_glyph: *const hb_codepoint_t,
        glyph_stride: ::std::os::raw::c_uint,
        first_advance: *mut hb_position_t,
        advance_stride: ::std::os::raw::c_uint,
    );
}
extern "C" {
    pub fn hb_font_get_glyph_v_advances(
        font: *mut hb_font_t,
        count: ::std::os::raw::c_uint,
        first_glyph: *const hb_codepoint_t,
        glyph_stride: ::std::os::raw::c_uint,
        first_advance: *mut hb_position_t,
        advance_stride: ::std::os::raw::c_uint,
    );
}
extern "C" {
    pub fn hb_font_get_glyph_h_origin(
        font: *mut hb_font_t,
        glyph: hb_codepoint_t,
        x: *mut hb_position_t,
        y: *mut hb_position_t,
    ) -> hb_bool_t;
}
extern "C" {
    pub fn hb_font_get_glyph_v_origin(
        font: *mut hb_font_t,
        glyph: hb_codepoint_t,
        x: *mut hb_position_t,
        y: *mut hb_position_t,
    ) -> hb_bool_t;
}
extern "C" {
    pub fn hb_font_get_glyph_h_kerning(
        font: *mut hb_font_t,
        left_glyph: hb_codepoint_t,
        right_glyph: hb_codepoint_t,
    ) -> hb_position_t;
}
extern "C" {
    pub fn hb_font_get_glyph_extents(
        font: *mut hb_font_t,
        glyph: hb_codepoint_t,
        extents: *mut hb_glyph_extents_t,
    ) -> hb_bool_t;
}
extern "C" {
    pub fn hb_font_get_glyph_contour_point(
        font: *mut hb_font_t,
        glyph: hb_codepoint_t,
        point_index: ::std::os::raw::c_uint,
        x: *mut hb_position_t,
        y: *mut hb_position_t,
    ) -> hb_bool_t;
}
extern "C" {
    pub fn hb_font_get_glyph_name(
        font: *mut hb_font_t,
        glyph: hb_codepoint_t,
        name: *mut ::std::os::raw::c_char,
        size: ::std::os::raw::c_uint,
    ) -> hb_bool_t;
}
extern "C" {
    pub fn hb_font_get_glyph_from_name(
        font: *mut hb_font_t,
        name: *const ::std::os::raw::c_char,
        len: ::std::os::raw::c_int,
        glyph: *mut hb_codepoint_t,
    ) -> hb_bool_t;
}
extern "C" {
    pub fn hb_font_draw_glyph(
        font: *mut hb_font_t,
        glyph: hb_codepoint_t,
        dfuncs: *mut hb_draw_funcs_t,
        draw_data: *mut ::std::os::raw::c_void,
    );
}
extern "C" {
    pub fn hb_font_paint_glyph(
        font: *mut hb_font_t,
        glyph: hb_codepoint_t,
        pfuncs: *mut hb_paint_funcs_t,
        paint_data: *mut ::std::os::raw::c_void,
        palette_index: ::std::os::raw::c_uint,
        foreground: hb_color_t,
    );
}
extern "C" {
    pub fn hb_font_get_glyph(
        font: *mut hb_font_t,
        unicode: hb_codepoint_t,
        variation_selector: hb_codepoint_t,
        glyph: *mut hb_codepoint_t,
    ) -> hb_bool_t;
}
extern "C" {
    pub fn hb_font_get_extents_for_direction(
        font: *mut hb_font_t,
        direction: hb_direction_t,
        extents: *mut hb_font_extents_t,
    );
}
extern "C" {
    pub fn hb_font_get_glyph_advance_for_direction(
        font: *mut hb_font_t,
        glyph: hb_codepoint_t,
        direction: hb_direction_t,
        x: *mut hb_position_t,
        y: *mut hb_position_t,
    );
}
extern "C" {
    pub fn hb_font_get_glyph_advances_for_direction(
        font: *mut hb_font_t,
        direction: hb_direction_t,
        count: ::std::os::raw::c_uint,
        first_glyph: *const hb_codepoint_t,
        glyph_stride: ::std::os::raw::c_uint,
        first_advance: *mut hb_position_t,
        advance_stride: ::std::os::raw::c_uint,
    );
}
extern "C" {
    pub fn hb_font_get_glyph_origin_for_direction(
        font: *mut hb_font_t,
        glyph: hb_codepoint_t,
        direction: hb_direction_t,
        x: *mut hb_position_t,
        y: *mut hb_position_t,
    );
}
extern "C" {
    pub fn hb_font_add_glyph_origin_for_direction(
        font: *mut hb_font_t,
        glyph: hb_codepoint_t,
        direction: hb_direction_t,
        x: *mut hb_position_t,
        y: *mut hb_position_t,
    );
}
extern "C" {
    pub fn hb_font_subtract_glyph_origin_for_direction(
        font: *mut hb_font_t,
        glyph: hb_codepoint_t,
        direction: hb_direction_t,
        x: *mut hb_position_t,
        y: *mut hb_position_t,
    );
}
extern "C" {
    pub fn hb_font_get_glyph_kerning_for_direction(
        font: *mut hb_font_t,
        first_glyph: hb_codepoint_t,
        second_glyph: hb_codepoint_t,
        direction: hb_direction_t,
        x: *mut hb_position_t,
        y: *mut hb_position_t,
    );
}
extern "C" {
    pub fn hb_font_get_glyph_extents_for_origin(
        font: *mut hb_font_t,
        glyph: hb_codepoint_t,
        direction: hb_direction_t,
        extents: *mut hb_glyph_extents_t,
    ) -> hb_bool_t;
}
extern "C" {
    pub fn hb_font_get_glyph_contour_point_for_origin(
        font: *mut hb_font_t,
        glyph: hb_codepoint_t,
        point_index: ::std::os::raw::c_uint,
        direction: hb_direction_t,
        x: *mut hb_position_t,
        y: *mut hb_position_t,
    ) -> hb_bool_t;
}
extern "C" {
    pub fn hb_font_glyph_to_string(
        font: *mut hb_font_t,
        glyph: hb_codepoint_t,
        s: *mut ::std::os::raw::c_char,
        size: ::std::os::raw::c_uint,
    );
}
extern "C" {
    pub fn hb_font_glyph_from_string(
        font: *mut hb_font_t,
        s: *const ::std::os::raw::c_char,
        len: ::std::os::raw::c_int,
        glyph: *mut hb_codepoint_t,
    ) -> hb_bool_t;
}
extern "C" {
    pub fn hb_font_create(face: *mut hb_face_t) -> *mut hb_font_t;
}
extern "C" {
    pub fn hb_font_create_sub_font(parent: *mut hb_font_t) -> *mut hb_font_t;
}
extern "C" {
    pub fn hb_font_get_empty() -> *mut hb_font_t;
}
extern "C" {
    pub fn hb_font_reference(font: *mut hb_font_t) -> *mut hb_font_t;
}
extern "C" {
    pub fn hb_font_destroy(font: *mut hb_font_t);
}
extern "C" {
    pub fn hb_font_set_user_data(
        font: *mut hb_font_t,
        key: *mut hb_user_data_key_t,
        data: *mut ::std::os::raw::c_void,
        destroy: hb_destroy_func_t,
        replace: hb_bool_t,
    ) -> hb_bool_t;
}
extern "C" {
    pub fn hb_font_get_user_data(
        font: *const hb_font_t,
        key: *mut hb_user_data_key_t,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn hb_font_make_immutable(font: *mut hb_font_t);
}
extern "C" {
    pub fn hb_font_is_immutable(font: *mut hb_font_t) -> hb_bool_t;
}
extern "C" {
    pub fn hb_font_get_serial(font: *mut hb_font_t) -> ::std::os::raw::c_uint;
}
extern "C" {
    pub fn hb_font_changed(font: *mut hb_font_t);
}
extern "C" {
    pub fn hb_font_set_parent(font: *mut hb_font_t, parent: *mut hb_font_t);
}
extern "C" {
    pub fn hb_font_get_parent(font: *mut hb_font_t) -> *mut hb_font_t;
}
extern "C" {
    pub fn hb_font_set_face(font: *mut hb_font_t, face: *mut hb_face_t);
}
extern "C" {
    pub fn hb_font_get_face(font: *mut hb_font_t) -> *mut hb_face_t;
}
extern "C" {
    pub fn hb_font_set_funcs(
        font: *mut hb_font_t,
        klass: *mut hb_font_funcs_t,
        font_data: *mut ::std::os::raw::c_void,
        destroy: hb_destroy_func_t,
    );
}
extern "C" {
    pub fn hb_font_set_funcs_data(
        font: *mut hb_font_t,
        font_data: *mut ::std::os::raw::c_void,
        destroy: hb_destroy_func_t,
    );
}
extern "C" {
    pub fn hb_font_set_scale(
        font: *mut hb_font_t,
        x_scale: ::std::os::raw::c_int,
        y_scale: ::std::os::raw::c_int,
    );
}
extern "C" {
    pub fn hb_font_get_scale(
        font: *mut hb_font_t,
        x_scale: *mut ::std::os::raw::c_int,
        y_scale: *mut ::std::os::raw::c_int,
    );
}
extern "C" {
    pub fn hb_font_set_ppem(
        font: *mut hb_font_t,
        x_ppem: ::std::os::raw::c_uint,
        y_ppem: ::std::os::raw::c_uint,
    );
}
extern "C" {
    pub fn hb_font_get_ppem(
        font: *mut hb_font_t,
        x_ppem: *mut ::std::os::raw::c_uint,
        y_ppem: *mut ::std::os::raw::c_uint,
    );
}
extern "C" {
    pub fn hb_font_set_ptem(font: *mut hb_font_t, ptem: f32);
}
extern "C" {
    pub fn hb_font_get_ptem(font: *mut hb_font_t) -> f32;
}
extern "C" {
    pub fn hb_font_set_synthetic_bold(
        font: *mut hb_font_t,
        x_embolden: f32,
        y_embolden: f32,
        in_place: hb_bool_t,
    );
}
extern "C" {
    pub fn hb_font_get_synthetic_bold(
        font: *mut hb_font_t,
        x_embolden: *mut f32,
        y_embolden: *mut f32,
        in_place: *mut hb_bool_t,
    );
}
extern "C" {
    pub fn hb_font_set_synthetic_slant(font: *mut hb_font_t, slant: f32);
}
extern "C" {
    pub fn hb_font_get_synthetic_slant(font: *mut hb_font_t) -> f32;
}
extern "C" {
    pub fn hb_font_set_variations(
        font: *mut hb_font_t,
        variations: *const hb_variation_t,
        variations_length: ::std::os::raw::c_uint,
    );
}
extern "C" {
    pub fn hb_font_set_variation(font: *mut hb_font_t, tag: hb_tag_t, value: f32);
}
extern "C" {
    pub fn hb_font_set_var_coords_design(
        font: *mut hb_font_t,
        coords: *const f32,
        coords_length: ::std::os::raw::c_uint,
    );
}
extern "C" {
    pub fn hb_font_get_var_coords_design(
        font: *mut hb_font_t,
        length: *mut ::std::os::raw::c_uint,
    ) -> *const f32;
}
extern "C" {
    pub fn hb_font_set_var_coords_normalized(
        font: *mut hb_font_t,
        coords: *const ::std::os::raw::c_int,
        coords_length: ::std::os::raw::c_uint,
    );
}
extern "C" {
    pub fn hb_font_get_var_coords_normalized(
        font: *mut hb_font_t,
        length: *mut ::std::os::raw::c_uint,
    ) -> *const ::std::os::raw::c_int;
}
extern "C" {
    pub fn hb_font_set_var_named_instance(
        font: *mut hb_font_t,
        instance_index: ::std::os::raw::c_uint,
    );
}
extern "C" {
    pub fn hb_font_get_var_named_instance(font: *mut hb_font_t) -> ::std::os::raw::c_uint;
}
#[doc = " hb_glyph_info_t:\n @codepoint: either a Unicode code point (before shaping) or a glyph index\n             (after shaping).\n @cluster: the index of the character in the original text that corresponds\n           to this #hb_glyph_info_t, or whatever the client passes to\n           hb_buffer_add(). More than one #hb_glyph_info_t can have the same\n           @cluster value, if they resulted from the same character (e.g. one\n           to many glyph substitution), and when more than one character gets\n           merged in the same glyph (e.g. many to one glyph substitution) the\n           #hb_glyph_info_t will have the smallest cluster value of them.\n           By default some characters are merged into the same cluster\n           (e.g. combining marks have the same cluster as their bases)\n           even if they are separate glyphs, hb_buffer_set_cluster_level()\n           allow selecting more fine-grained cluster handling.\n\n The #hb_glyph_info_t is the structure that holds information about the\n glyphs and their relation to input text."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct hb_glyph_info_t {
    pub codepoint: hb_codepoint_t,
    pub mask: hb_mask_t,
    pub cluster: u32,
    pub var1: hb_var_int_t,
    pub var2: hb_var_int_t,
}
#[test]
fn bindgen_test_layout_hb_glyph_info_t() {
    const UNINIT: ::std::mem::MaybeUninit<hb_glyph_info_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<hb_glyph_info_t>(),
        20usize,
        concat!("Size of: ", stringify!(hb_glyph_info_t))
    );
    assert_eq!(
        ::std::mem::align_of::<hb_glyph_info_t>(),
        4usize,
        concat!("Alignment of ", stringify!(hb_glyph_info_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).codepoint) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(hb_glyph_info_t),
            "::",
            stringify!(codepoint)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).mask) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(hb_glyph_info_t),
            "::",
            stringify!(mask)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).cluster) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(hb_glyph_info_t),
            "::",
            stringify!(cluster)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).var1) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(hb_glyph_info_t),
            "::",
            stringify!(var1)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).var2) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(hb_glyph_info_t),
            "::",
            stringify!(var2)
        )
    );
}
pub const hb_glyph_flags_t_HB_GLYPH_FLAG_UNSAFE_TO_BREAK: hb_glyph_flags_t = 1;
pub const hb_glyph_flags_t_HB_GLYPH_FLAG_UNSAFE_TO_CONCAT: hb_glyph_flags_t = 2;
pub const hb_glyph_flags_t_HB_GLYPH_FLAG_SAFE_TO_INSERT_TATWEEL: hb_glyph_flags_t = 4;
pub const hb_glyph_flags_t_HB_GLYPH_FLAG_DEFINED: hb_glyph_flags_t = 7;
#[doc = " hb_glyph_flags_t:\n @HB_GLYPH_FLAG_UNSAFE_TO_BREAK: Indicates that if input text is broken at the\n \t\t\t\t   beginning of the cluster this glyph is part of,\n \t\t\t\t   then both sides need to be re-shaped, as the\n \t\t\t\t   result might be different.\n \t\t\t\t   On the flip side, it means that when this\n \t\t\t\t   flag is not present, then it is safe to break\n \t\t\t\t   the glyph-run at the beginning of this\n \t\t\t\t   cluster, and the two sides will represent the\n \t\t\t\t   exact same result one would get if breaking\n \t\t\t\t   input text at the beginning of this cluster\n \t\t\t\t   and shaping the two sides separately.\n \t\t\t\t   This can be used to optimize paragraph\n \t\t\t\t   layout, by avoiding re-shaping of each line\n \t\t\t\t   after line-breaking.\n @HB_GLYPH_FLAG_UNSAFE_TO_CONCAT: Indicates that if input text is changed on one\n \t\t\t\t   side of the beginning of the cluster this glyph\n \t\t\t\t   is part of, then the shaping results for the\n \t\t\t\t   other side might change.\n \t\t\t\t   Note that the absence of this flag will NOT by\n \t\t\t\t   itself mean that it IS safe to concat text.\n \t\t\t\t   Only two pieces of text both of which clear of\n \t\t\t\t   this flag can be concatenated safely.\n \t\t\t\t   This can be used to optimize paragraph\n \t\t\t\t   layout, by avoiding re-shaping of each line\n \t\t\t\t   after line-breaking, by limiting the\n \t\t\t\t   reshaping to a small piece around the\n \t\t\t\t   breaking position only, even if the breaking\n \t\t\t\t   position carries the\n \t\t\t\t   #HB_GLYPH_FLAG_UNSAFE_TO_BREAK or when\n \t\t\t\t   hyphenation or other text transformation\n \t\t\t\t   happens at line-break position, in the following\n \t\t\t\t   way:\n \t\t\t\t   1. Iterate back from the line-break position\n \t\t\t\t   until the first cluster start position that is\n \t\t\t\t   NOT unsafe-to-concat, 2. shape the segment from\n \t\t\t\t   there till the end of line, 3. check whether the\n \t\t\t\t   resulting glyph-run also is clear of the\n \t\t\t\t   unsafe-to-concat at its start-of-text position;\n \t\t\t\t   if it is, just splice it into place and the line\n \t\t\t\t   is shaped; If not, move on to a position further\n \t\t\t\t   back that is clear of unsafe-to-concat and retry\n \t\t\t\t   from there, and repeat.\n \t\t\t\t   At the start of next line a similar algorithm can\n \t\t\t\t   be implemented. That is: 1. Iterate forward from\n \t\t\t\t   the line-break position until the first cluster\n \t\t\t\t   start position that is NOT unsafe-to-concat, 2.\n \t\t\t\t   shape the segment from beginning of the line to\n \t\t\t\t   that position, 3. check whether the resulting\n \t\t\t\t   glyph-run also is clear of the unsafe-to-concat\n \t\t\t\t   at its end-of-text position; if it is, just splice\n \t\t\t\t   it into place and the beginning is shaped; If not,\n \t\t\t\t   move on to a position further forward that is clear\n \t\t\t\t   of unsafe-to-concat and retry up to there, and repeat.\n \t\t\t\t   A slight complication will arise in the\n \t\t\t\t   implementation of the algorithm above,\n \t\t\t\t   because while our buffer API has a way to\n \t\t\t\t   return flags for position corresponding to\n \t\t\t\t   start-of-text, there is currently no position\n \t\t\t\t   corresponding to end-of-text.  This limitation\n \t\t\t\t   can be alleviated by shaping more text than needed\n \t\t\t\t   and looking for unsafe-to-concat flag within text\n \t\t\t\t   clusters.\n \t\t\t\t   The #HB_GLYPH_FLAG_UNSAFE_TO_BREAK flag will\n \t\t\t\t   always imply this flag.\n\t\t\t\t   To use this flag, you must enable the buffer flag\n\t\t\t\t   @HB_BUFFER_FLAG_PRODUCE_UNSAFE_TO_CONCAT during\n\t\t\t\t   shaping, otherwise the buffer flag will not be\n\t\t\t\t   reliably produced.\n \t\t\t\t   Since: 4.0.0\n @HB_GLYPH_FLAG_SAFE_TO_INSERT_TATWEEL: In scripts that use elongation (Arabic,\nMongolian, Syriac, etc.), this flag signifies\nthat it is safe to insert a U+0640 TATWEEL\ncharacter before this cluster for elongation.\nThis flag does not determine the\nscript-specific elongation places, but only\nwhen it is safe to do the elongation without\ninterrupting text shaping.\nSince: 5.1.0\n @HB_GLYPH_FLAG_DEFINED: All the currently defined flags.\n\n Flags for #hb_glyph_info_t.\n\n Since: 1.5.0"]
pub type hb_glyph_flags_t = ::std::os::raw::c_uint;
extern "C" {
    pub fn hb_glyph_info_get_glyph_flags(info: *const hb_glyph_info_t) -> hb_glyph_flags_t;
}
#[doc = " hb_glyph_position_t:\n @x_advance: how much the line advances after drawing this glyph when setting\n             text in horizontal direction.\n @y_advance: how much the line advances after drawing this glyph when setting\n             text in vertical direction.\n @x_offset: how much the glyph moves on the X-axis before drawing it, this\n            should not affect how much the line advances.\n @y_offset: how much the glyph moves on the Y-axis before drawing it, this\n            should not affect how much the line advances.\n\n The #hb_glyph_position_t is the structure that holds the positions of the\n glyph in both horizontal and vertical directions. All positions in\n #hb_glyph_position_t are relative to the current point.\n"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct hb_glyph_position_t {
    pub x_advance: hb_position_t,
    pub y_advance: hb_position_t,
    pub x_offset: hb_position_t,
    pub y_offset: hb_position_t,
    pub var: hb_var_int_t,
}
#[test]
fn bindgen_test_layout_hb_glyph_position_t() {
    const UNINIT: ::std::mem::MaybeUninit<hb_glyph_position_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<hb_glyph_position_t>(),
        20usize,
        concat!("Size of: ", stringify!(hb_glyph_position_t))
    );
    assert_eq!(
        ::std::mem::align_of::<hb_glyph_position_t>(),
        4usize,
        concat!("Alignment of ", stringify!(hb_glyph_position_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).x_advance) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(hb_glyph_position_t),
            "::",
            stringify!(x_advance)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).y_advance) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(hb_glyph_position_t),
            "::",
            stringify!(y_advance)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).x_offset) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(hb_glyph_position_t),
            "::",
            stringify!(x_offset)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).y_offset) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(hb_glyph_position_t),
            "::",
            stringify!(y_offset)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).var) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(hb_glyph_position_t),
            "::",
            stringify!(var)
        )
    );
}
#[doc = " hb_segment_properties_t:\n @direction: the #hb_direction_t of the buffer, see hb_buffer_set_direction().\n @script: the #hb_script_t of the buffer, see hb_buffer_set_script().\n @language: the #hb_language_t of the buffer, see hb_buffer_set_language().\n\n The structure that holds various text properties of an #hb_buffer_t. Can be\n set and retrieved using hb_buffer_set_segment_properties() and\n hb_buffer_get_segment_properties(), respectively."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct hb_segment_properties_t {
    pub direction: hb_direction_t,
    pub script: hb_script_t,
    pub language: hb_language_t,
    pub reserved1: *mut ::std::os::raw::c_void,
    pub reserved2: *mut ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout_hb_segment_properties_t() {
    const UNINIT: ::std::mem::MaybeUninit<hb_segment_properties_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<hb_segment_properties_t>(),
        32usize,
        concat!("Size of: ", stringify!(hb_segment_properties_t))
    );
    assert_eq!(
        ::std::mem::align_of::<hb_segment_properties_t>(),
        8usize,
        concat!("Alignment of ", stringify!(hb_segment_properties_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).direction) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(hb_segment_properties_t),
            "::",
            stringify!(direction)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).script) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(hb_segment_properties_t),
            "::",
            stringify!(script)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).language) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(hb_segment_properties_t),
            "::",
            stringify!(language)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).reserved1) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(hb_segment_properties_t),
            "::",
            stringify!(reserved1)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).reserved2) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(hb_segment_properties_t),
            "::",
            stringify!(reserved2)
        )
    );
}
extern "C" {
    pub fn hb_segment_properties_equal(
        a: *const hb_segment_properties_t,
        b: *const hb_segment_properties_t,
    ) -> hb_bool_t;
}
extern "C" {
    pub fn hb_segment_properties_hash(p: *const hb_segment_properties_t) -> ::std::os::raw::c_uint;
}
extern "C" {
    pub fn hb_segment_properties_overlay(
        p: *mut hb_segment_properties_t,
        src: *const hb_segment_properties_t,
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct hb_buffer_t {
    _unused: [u8; 0],
}
extern "C" {
    pub fn hb_buffer_create() -> *mut hb_buffer_t;
}
extern "C" {
    pub fn hb_buffer_create_similar(src: *const hb_buffer_t) -> *mut hb_buffer_t;
}
extern "C" {
    pub fn hb_buffer_reset(buffer: *mut hb_buffer_t);
}
extern "C" {
    pub fn hb_buffer_get_empty() -> *mut hb_buffer_t;
}
extern "C" {
    pub fn hb_buffer_reference(buffer: *mut hb_buffer_t) -> *mut hb_buffer_t;
}
extern "C" {
    pub fn hb_buffer_destroy(buffer: *mut hb_buffer_t);
}
extern "C" {
    pub fn hb_buffer_set_user_data(
        buffer: *mut hb_buffer_t,
        key: *mut hb_user_data_key_t,
        data: *mut ::std::os::raw::c_void,
        destroy: hb_destroy_func_t,
        replace: hb_bool_t,
    ) -> hb_bool_t;
}
extern "C" {
    pub fn hb_buffer_get_user_data(
        buffer: *const hb_buffer_t,
        key: *mut hb_user_data_key_t,
    ) -> *mut ::std::os::raw::c_void;
}
pub const hb_buffer_content_type_t_HB_BUFFER_CONTENT_TYPE_INVALID: hb_buffer_content_type_t = 0;
pub const hb_buffer_content_type_t_HB_BUFFER_CONTENT_TYPE_UNICODE: hb_buffer_content_type_t = 1;
pub const hb_buffer_content_type_t_HB_BUFFER_CONTENT_TYPE_GLYPHS: hb_buffer_content_type_t = 2;
#[doc = " hb_buffer_content_type_t:\n @HB_BUFFER_CONTENT_TYPE_INVALID: Initial value for new buffer.\n @HB_BUFFER_CONTENT_TYPE_UNICODE: The buffer contains input characters (before shaping).\n @HB_BUFFER_CONTENT_TYPE_GLYPHS: The buffer contains output glyphs (after shaping).\n\n The type of #hb_buffer_t contents."]
pub type hb_buffer_content_type_t = ::std::os::raw::c_uint;
extern "C" {
    pub fn hb_buffer_set_content_type(
        buffer: *mut hb_buffer_t,
        content_type: hb_buffer_content_type_t,
    );
}
extern "C" {
    pub fn hb_buffer_get_content_type(buffer: *const hb_buffer_t) -> hb_buffer_content_type_t;
}
extern "C" {
    pub fn hb_buffer_set_unicode_funcs(
        buffer: *mut hb_buffer_t,
        unicode_funcs: *mut hb_unicode_funcs_t,
    );
}
extern "C" {
    pub fn hb_buffer_get_unicode_funcs(buffer: *const hb_buffer_t) -> *mut hb_unicode_funcs_t;
}
extern "C" {
    pub fn hb_buffer_set_direction(buffer: *mut hb_buffer_t, direction: hb_direction_t);
}
extern "C" {
    pub fn hb_buffer_get_direction(buffer: *const hb_buffer_t) -> hb_direction_t;
}
extern "C" {
    pub fn hb_buffer_set_script(buffer: *mut hb_buffer_t, script: hb_script_t);
}
extern "C" {
    pub fn hb_buffer_get_script(buffer: *const hb_buffer_t) -> hb_script_t;
}
extern "C" {
    pub fn hb_buffer_set_language(buffer: *mut hb_buffer_t, language: hb_language_t);
}
extern "C" {
    pub fn hb_buffer_get_language(buffer: *const hb_buffer_t) -> hb_language_t;
}
extern "C" {
    pub fn hb_buffer_set_segment_properties(
        buffer: *mut hb_buffer_t,
        props: *const hb_segment_properties_t,
    );
}
extern "C" {
    pub fn hb_buffer_get_segment_properties(
        buffer: *const hb_buffer_t,
        props: *mut hb_segment_properties_t,
    );
}
extern "C" {
    pub fn hb_buffer_guess_segment_properties(buffer: *mut hb_buffer_t);
}
pub const hb_buffer_flags_t_HB_BUFFER_FLAG_DEFAULT: hb_buffer_flags_t = 0;
pub const hb_buffer_flags_t_HB_BUFFER_FLAG_BOT: hb_buffer_flags_t = 1;
pub const hb_buffer_flags_t_HB_BUFFER_FLAG_EOT: hb_buffer_flags_t = 2;
pub const hb_buffer_flags_t_HB_BUFFER_FLAG_PRESERVE_DEFAULT_IGNORABLES: hb_buffer_flags_t = 4;
pub const hb_buffer_flags_t_HB_BUFFER_FLAG_REMOVE_DEFAULT_IGNORABLES: hb_buffer_flags_t = 8;
pub const hb_buffer_flags_t_HB_BUFFER_FLAG_DO_NOT_INSERT_DOTTED_CIRCLE: hb_buffer_flags_t = 16;
pub const hb_buffer_flags_t_HB_BUFFER_FLAG_VERIFY: hb_buffer_flags_t = 32;
pub const hb_buffer_flags_t_HB_BUFFER_FLAG_PRODUCE_UNSAFE_TO_CONCAT: hb_buffer_flags_t = 64;
pub const hb_buffer_flags_t_HB_BUFFER_FLAG_PRODUCE_SAFE_TO_INSERT_TATWEEL: hb_buffer_flags_t = 128;
pub const hb_buffer_flags_t_HB_BUFFER_FLAG_DEFINED: hb_buffer_flags_t = 255;
#[doc = " hb_buffer_flags_t:\n @HB_BUFFER_FLAG_DEFAULT: the default buffer flag.\n @HB_BUFFER_FLAG_BOT: flag indicating that special handling of the beginning\n                      of text paragraph can be applied to this buffer. Should usually\n                      be set, unless you are passing to the buffer only part\n                      of the text without the full context.\n @HB_BUFFER_FLAG_EOT: flag indicating that special handling of the end of text\n                      paragraph can be applied to this buffer, similar to\n                      @HB_BUFFER_FLAG_BOT.\n @HB_BUFFER_FLAG_PRESERVE_DEFAULT_IGNORABLES:\n                      flag indication that character with Default_Ignorable\n                      Unicode property should use the corresponding glyph\n                      from the font, instead of hiding them (done by\n                      replacing them with the space glyph and zeroing the\n                      advance width.)  This flag takes precedence over\n                      @HB_BUFFER_FLAG_REMOVE_DEFAULT_IGNORABLES.\n @HB_BUFFER_FLAG_REMOVE_DEFAULT_IGNORABLES:\n                      flag indication that character with Default_Ignorable\n                      Unicode property should be removed from glyph string\n                      instead of hiding them (done by replacing them with the\n                      space glyph and zeroing the advance width.)\n                      @HB_BUFFER_FLAG_PRESERVE_DEFAULT_IGNORABLES takes\n                      precedence over this flag. Since: 1.8.0\n @HB_BUFFER_FLAG_DO_NOT_INSERT_DOTTED_CIRCLE:\n                      flag indicating that a dotted circle should\n                      not be inserted in the rendering of incorrect\n                      character sequences (such at <0905 093E>). Since: 2.4.0\n @HB_BUFFER_FLAG_VERIFY:\n                      flag indicating that the hb_shape() call and its variants\n                      should perform various verification processes on the results\n                      of the shaping operation on the buffer.  If the verification\n                      fails, then either a buffer message is sent, if a message\n                      handler is installed on the buffer, or a message is written\n                      to standard error.  In either case, the shaping result might\n                      be modified to show the failed output. Since: 3.4.0\n @HB_BUFFER_FLAG_PRODUCE_UNSAFE_TO_CONCAT:\n                      flag indicating that the @HB_GLYPH_FLAG_UNSAFE_TO_CONCAT\n                      glyph-flag should be produced by the shaper. By default\n                      it will not be produced since it incurs a cost. Since: 4.0.0\n @HB_BUFFER_FLAG_PRODUCE_SAFE_TO_INSERT_TATWEEL:\n                      flag indicating that the @HB_GLYPH_FLAG_SAFE_TO_INSERT_TATWEEL\n                      glyph-flag should be produced by the shaper. By default\n                      it will not be produced. Since: 5.1.0\n @HB_BUFFER_FLAG_DEFINED: All currently defined flags: Since: 4.4.0\n\n Flags for #hb_buffer_t.\n\n Since: 0.9.20"]
pub type hb_buffer_flags_t = ::std::os::raw::c_uint;
extern "C" {
    pub fn hb_buffer_set_flags(buffer: *mut hb_buffer_t, flags: hb_buffer_flags_t);
}
extern "C" {
    pub fn hb_buffer_get_flags(buffer: *const hb_buffer_t) -> hb_buffer_flags_t;
}
pub const hb_buffer_cluster_level_t_HB_BUFFER_CLUSTER_LEVEL_MONOTONE_GRAPHEMES:
    hb_buffer_cluster_level_t = 0;
pub const hb_buffer_cluster_level_t_HB_BUFFER_CLUSTER_LEVEL_MONOTONE_CHARACTERS:
    hb_buffer_cluster_level_t = 1;
pub const hb_buffer_cluster_level_t_HB_BUFFER_CLUSTER_LEVEL_CHARACTERS: hb_buffer_cluster_level_t =
    2;
pub const hb_buffer_cluster_level_t_HB_BUFFER_CLUSTER_LEVEL_DEFAULT: hb_buffer_cluster_level_t = 0;
#[doc = " hb_buffer_cluster_level_t:\n @HB_BUFFER_CLUSTER_LEVEL_MONOTONE_GRAPHEMES: Return cluster values grouped by graphemes into\n   monotone order.\n @HB_BUFFER_CLUSTER_LEVEL_MONOTONE_CHARACTERS: Return cluster values grouped into monotone order.\n @HB_BUFFER_CLUSTER_LEVEL_CHARACTERS: Don't group cluster values.\n @HB_BUFFER_CLUSTER_LEVEL_DEFAULT: Default cluster level,\n   equal to @HB_BUFFER_CLUSTER_LEVEL_MONOTONE_GRAPHEMES.\n\n Data type for holding HarfBuzz's clustering behavior options. The cluster level\n dictates one aspect of how HarfBuzz will treat non-base characters\n during shaping.\n\n In @HB_BUFFER_CLUSTER_LEVEL_MONOTONE_GRAPHEMES, non-base\n characters are merged into the cluster of the base character that precedes them.\n\n In @HB_BUFFER_CLUSTER_LEVEL_MONOTONE_CHARACTERS, non-base characters are initially\n assigned their own cluster values, which are not merged into preceding base\n clusters. This allows HarfBuzz to perform additional operations like reorder\n sequences of adjacent marks.\n\n @HB_BUFFER_CLUSTER_LEVEL_MONOTONE_GRAPHEMES is the default, because it maintains\n backward compatibility with older versions of HarfBuzz. New client programs that\n do not need to maintain such backward compatibility are recommended to use\n @HB_BUFFER_CLUSTER_LEVEL_MONOTONE_CHARACTERS instead of the default.\n\n Since: 0.9.42"]
pub type hb_buffer_cluster_level_t = ::std::os::raw::c_uint;
extern "C" {
    pub fn hb_buffer_set_cluster_level(
        buffer: *mut hb_buffer_t,
        cluster_level: hb_buffer_cluster_level_t,
    );
}
extern "C" {
    pub fn hb_buffer_get_cluster_level(buffer: *const hb_buffer_t) -> hb_buffer_cluster_level_t;
}
extern "C" {
    pub fn hb_buffer_set_replacement_codepoint(
        buffer: *mut hb_buffer_t,
        replacement: hb_codepoint_t,
    );
}
extern "C" {
    pub fn hb_buffer_get_replacement_codepoint(buffer: *const hb_buffer_t) -> hb_codepoint_t;
}
extern "C" {
    pub fn hb_buffer_set_invisible_glyph(buffer: *mut hb_buffer_t, invisible: hb_codepoint_t);
}
extern "C" {
    pub fn hb_buffer_get_invisible_glyph(buffer: *const hb_buffer_t) -> hb_codepoint_t;
}
extern "C" {
    pub fn hb_buffer_set_not_found_glyph(buffer: *mut hb_buffer_t, not_found: hb_codepoint_t);
}
extern "C" {
    pub fn hb_buffer_get_not_found_glyph(buffer: *const hb_buffer_t) -> hb_codepoint_t;
}
extern "C" {
    pub fn hb_buffer_set_random_state(buffer: *mut hb_buffer_t, state: ::std::os::raw::c_uint);
}
extern "C" {
    pub fn hb_buffer_get_random_state(buffer: *const hb_buffer_t) -> ::std::os::raw::c_uint;
}
extern "C" {
    pub fn hb_buffer_clear_contents(buffer: *mut hb_buffer_t);
}
extern "C" {
    pub fn hb_buffer_pre_allocate(
        buffer: *mut hb_buffer_t,
        size: ::std::os::raw::c_uint,
    ) -> hb_bool_t;
}
extern "C" {
    pub fn hb_buffer_allocation_successful(buffer: *mut hb_buffer_t) -> hb_bool_t;
}
extern "C" {
    pub fn hb_buffer_reverse(buffer: *mut hb_buffer_t);
}
extern "C" {
    pub fn hb_buffer_reverse_range(
        buffer: *mut hb_buffer_t,
        start: ::std::os::raw::c_uint,
        end: ::std::os::raw::c_uint,
    );
}
extern "C" {
    pub fn hb_buffer_reverse_clusters(buffer: *mut hb_buffer_t);
}
extern "C" {
    pub fn hb_buffer_add(
        buffer: *mut hb_buffer_t,
        codepoint: hb_codepoint_t,
        cluster: ::std::os::raw::c_uint,
    );
}
extern "C" {
    pub fn hb_buffer_add_utf8(
        buffer: *mut hb_buffer_t,
        text: *const ::std::os::raw::c_char,
        text_length: ::std::os::raw::c_int,
        item_offset: ::std::os::raw::c_uint,
        item_length: ::std::os::raw::c_int,
    );
}
extern "C" {
    pub fn hb_buffer_add_utf16(
        buffer: *mut hb_buffer_t,
        text: *const u16,
        text_length: ::std::os::raw::c_int,
        item_offset: ::std::os::raw::c_uint,
        item_length: ::std::os::raw::c_int,
    );
}
extern "C" {
    pub fn hb_buffer_add_utf32(
        buffer: *mut hb_buffer_t,
        text: *const u32,
        text_length: ::std::os::raw::c_int,
        item_offset: ::std::os::raw::c_uint,
        item_length: ::std::os::raw::c_int,
    );
}
extern "C" {
    pub fn hb_buffer_add_latin1(
        buffer: *mut hb_buffer_t,
        text: *const u8,
        text_length: ::std::os::raw::c_int,
        item_offset: ::std::os::raw::c_uint,
        item_length: ::std::os::raw::c_int,
    );
}
extern "C" {
    pub fn hb_buffer_add_codepoints(
        buffer: *mut hb_buffer_t,
        text: *const hb_codepoint_t,
        text_length: ::std::os::raw::c_int,
        item_offset: ::std::os::raw::c_uint,
        item_length: ::std::os::raw::c_int,
    );
}
extern "C" {
    pub fn hb_buffer_append(
        buffer: *mut hb_buffer_t,
        source: *const hb_buffer_t,
        start: ::std::os::raw::c_uint,
        end: ::std::os::raw::c_uint,
    );
}
extern "C" {
    pub fn hb_buffer_set_length(
        buffer: *mut hb_buffer_t,
        length: ::std::os::raw::c_uint,
    ) -> hb_bool_t;
}
extern "C" {
    pub fn hb_buffer_get_length(buffer: *const hb_buffer_t) -> ::std::os::raw::c_uint;
}
extern "C" {
    pub fn hb_buffer_get_glyph_infos(
        buffer: *mut hb_buffer_t,
        length: *mut ::std::os::raw::c_uint,
    ) -> *mut hb_glyph_info_t;
}
extern "C" {
    pub fn hb_buffer_get_glyph_positions(
        buffer: *mut hb_buffer_t,
        length: *mut ::std::os::raw::c_uint,
    ) -> *mut hb_glyph_position_t;
}
extern "C" {
    pub fn hb_buffer_has_positions(buffer: *mut hb_buffer_t) -> hb_bool_t;
}
extern "C" {
    pub fn hb_buffer_normalize_glyphs(buffer: *mut hb_buffer_t);
}
pub const hb_buffer_serialize_flags_t_HB_BUFFER_SERIALIZE_FLAG_DEFAULT:
    hb_buffer_serialize_flags_t = 0;
pub const hb_buffer_serialize_flags_t_HB_BUFFER_SERIALIZE_FLAG_NO_CLUSTERS:
    hb_buffer_serialize_flags_t = 1;
pub const hb_buffer_serialize_flags_t_HB_BUFFER_SERIALIZE_FLAG_NO_POSITIONS:
    hb_buffer_serialize_flags_t = 2;
pub const hb_buffer_serialize_flags_t_HB_BUFFER_SERIALIZE_FLAG_NO_GLYPH_NAMES:
    hb_buffer_serialize_flags_t = 4;
pub const hb_buffer_serialize_flags_t_HB_BUFFER_SERIALIZE_FLAG_GLYPH_EXTENTS:
    hb_buffer_serialize_flags_t = 8;
pub const hb_buffer_serialize_flags_t_HB_BUFFER_SERIALIZE_FLAG_GLYPH_FLAGS:
    hb_buffer_serialize_flags_t = 16;
pub const hb_buffer_serialize_flags_t_HB_BUFFER_SERIALIZE_FLAG_NO_ADVANCES:
    hb_buffer_serialize_flags_t = 32;
pub const hb_buffer_serialize_flags_t_HB_BUFFER_SERIALIZE_FLAG_DEFINED:
    hb_buffer_serialize_flags_t = 63;
#[doc = " hb_buffer_serialize_flags_t:\n @HB_BUFFER_SERIALIZE_FLAG_DEFAULT: serialize glyph names, clusters and positions.\n @HB_BUFFER_SERIALIZE_FLAG_NO_CLUSTERS: do not serialize glyph cluster.\n @HB_BUFFER_SERIALIZE_FLAG_NO_POSITIONS: do not serialize glyph position information.\n @HB_BUFFER_SERIALIZE_FLAG_NO_GLYPH_NAMES: do no serialize glyph name.\n @HB_BUFFER_SERIALIZE_FLAG_GLYPH_EXTENTS: serialize glyph extents.\n @HB_BUFFER_SERIALIZE_FLAG_GLYPH_FLAGS: serialize glyph flags. Since: 1.5.0\n @HB_BUFFER_SERIALIZE_FLAG_NO_ADVANCES: do not serialize glyph advances,\n  glyph offsets will reflect absolute glyph positions. Since: 1.8.0\n @HB_BUFFER_SERIALIZE_FLAG_DEFINED: All currently defined flags. Since: 4.4.0\n\n Flags that control what glyph information are serialized in hb_buffer_serialize_glyphs().\n\n Since: 0.9.20"]
pub type hb_buffer_serialize_flags_t = ::std::os::raw::c_uint;
pub const hb_buffer_serialize_format_t_HB_BUFFER_SERIALIZE_FORMAT_TEXT:
    hb_buffer_serialize_format_t = 1413830740;
pub const hb_buffer_serialize_format_t_HB_BUFFER_SERIALIZE_FORMAT_JSON:
    hb_buffer_serialize_format_t = 1246973774;
pub const hb_buffer_serialize_format_t_HB_BUFFER_SERIALIZE_FORMAT_INVALID:
    hb_buffer_serialize_format_t = 0;
#[doc = " hb_buffer_serialize_format_t:\n @HB_BUFFER_SERIALIZE_FORMAT_TEXT: a human-readable, plain text format.\n @HB_BUFFER_SERIALIZE_FORMAT_JSON: a machine-readable JSON format.\n @HB_BUFFER_SERIALIZE_FORMAT_INVALID: invalid format.\n\n The buffer serialization and de-serialization format used in\n hb_buffer_serialize_glyphs() and hb_buffer_deserialize_glyphs().\n\n Since: 0.9.2"]
pub type hb_buffer_serialize_format_t = ::std::os::raw::c_uint;
extern "C" {
    pub fn hb_buffer_serialize_format_from_string(
        str_: *const ::std::os::raw::c_char,
        len: ::std::os::raw::c_int,
    ) -> hb_buffer_serialize_format_t;
}
extern "C" {
    pub fn hb_buffer_serialize_format_to_string(
        format: hb_buffer_serialize_format_t,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn hb_buffer_serialize_list_formats() -> *mut *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn hb_buffer_serialize_glyphs(
        buffer: *mut hb_buffer_t,
        start: ::std::os::raw::c_uint,
        end: ::std::os::raw::c_uint,
        buf: *mut ::std::os::raw::c_char,
        buf_size: ::std::os::raw::c_uint,
        buf_consumed: *mut ::std::os::raw::c_uint,
        font: *mut hb_font_t,
        format: hb_buffer_serialize_format_t,
        flags: hb_buffer_serialize_flags_t,
    ) -> ::std::os::raw::c_uint;
}
extern "C" {
    pub fn hb_buffer_serialize_unicode(
        buffer: *mut hb_buffer_t,
        start: ::std::os::raw::c_uint,
        end: ::std::os::raw::c_uint,
        buf: *mut ::std::os::raw::c_char,
        buf_size: ::std::os::raw::c_uint,
        buf_consumed: *mut ::std::os::raw::c_uint,
        format: hb_buffer_serialize_format_t,
        flags: hb_buffer_serialize_flags_t,
    ) -> ::std::os::raw::c_uint;
}
extern "C" {
    pub fn hb_buffer_serialize(
        buffer: *mut hb_buffer_t,
        start: ::std::os::raw::c_uint,
        end: ::std::os::raw::c_uint,
        buf: *mut ::std::os::raw::c_char,
        buf_size: ::std::os::raw::c_uint,
        buf_consumed: *mut ::std::os::raw::c_uint,
        font: *mut hb_font_t,
        format: hb_buffer_serialize_format_t,
        flags: hb_buffer_serialize_flags_t,
    ) -> ::std::os::raw::c_uint;
}
extern "C" {
    pub fn hb_buffer_deserialize_glyphs(
        buffer: *mut hb_buffer_t,
        buf: *const ::std::os::raw::c_char,
        buf_len: ::std::os::raw::c_int,
        end_ptr: *mut *const ::std::os::raw::c_char,
        font: *mut hb_font_t,
        format: hb_buffer_serialize_format_t,
    ) -> hb_bool_t;
}
extern "C" {
    pub fn hb_buffer_deserialize_unicode(
        buffer: *mut hb_buffer_t,
        buf: *const ::std::os::raw::c_char,
        buf_len: ::std::os::raw::c_int,
        end_ptr: *mut *const ::std::os::raw::c_char,
        format: hb_buffer_serialize_format_t,
    ) -> hb_bool_t;
}
pub const hb_buffer_diff_flags_t_HB_BUFFER_DIFF_FLAG_EQUAL: hb_buffer_diff_flags_t = 0;
pub const hb_buffer_diff_flags_t_HB_BUFFER_DIFF_FLAG_CONTENT_TYPE_MISMATCH: hb_buffer_diff_flags_t =
    1;
pub const hb_buffer_diff_flags_t_HB_BUFFER_DIFF_FLAG_LENGTH_MISMATCH: hb_buffer_diff_flags_t = 2;
pub const hb_buffer_diff_flags_t_HB_BUFFER_DIFF_FLAG_NOTDEF_PRESENT: hb_buffer_diff_flags_t = 4;
pub const hb_buffer_diff_flags_t_HB_BUFFER_DIFF_FLAG_DOTTED_CIRCLE_PRESENT: hb_buffer_diff_flags_t =
    8;
pub const hb_buffer_diff_flags_t_HB_BUFFER_DIFF_FLAG_CODEPOINT_MISMATCH: hb_buffer_diff_flags_t =
    16;
pub const hb_buffer_diff_flags_t_HB_BUFFER_DIFF_FLAG_CLUSTER_MISMATCH: hb_buffer_diff_flags_t = 32;
pub const hb_buffer_diff_flags_t_HB_BUFFER_DIFF_FLAG_GLYPH_FLAGS_MISMATCH: hb_buffer_diff_flags_t =
    64;
pub const hb_buffer_diff_flags_t_HB_BUFFER_DIFF_FLAG_POSITION_MISMATCH: hb_buffer_diff_flags_t =
    128;
#[doc = " hb_buffer_diff_flags_t:\n @HB_BUFFER_DIFF_FLAG_EQUAL: equal buffers.\n @HB_BUFFER_DIFF_FLAG_CONTENT_TYPE_MISMATCH: buffers with different\n     #hb_buffer_content_type_t.\n @HB_BUFFER_DIFF_FLAG_LENGTH_MISMATCH: buffers with differing length.\n @HB_BUFFER_DIFF_FLAG_NOTDEF_PRESENT: `.notdef` glyph is present in the\n     reference buffer.\n @HB_BUFFER_DIFF_FLAG_DOTTED_CIRCLE_PRESENT: dotted circle glyph is present\n     in the reference buffer.\n @HB_BUFFER_DIFF_FLAG_CODEPOINT_MISMATCH: difference in #hb_glyph_info_t.codepoint\n @HB_BUFFER_DIFF_FLAG_CLUSTER_MISMATCH: difference in #hb_glyph_info_t.cluster\n @HB_BUFFER_DIFF_FLAG_GLYPH_FLAGS_MISMATCH: difference in #hb_glyph_flags_t.\n @HB_BUFFER_DIFF_FLAG_POSITION_MISMATCH: difference in #hb_glyph_position_t.\n\n Flags from comparing two #hb_buffer_t's.\n\n Buffer with different #hb_buffer_content_type_t cannot be meaningfully\n compared in any further detail.\n\n For buffers with differing length, the per-glyph comparison is not\n attempted, though we do still scan reference buffer for dotted circle and\n `.notdef` glyphs.\n\n If the buffers have the same length, we compare them glyph-by-glyph and\n report which aspect(s) of the glyph info/position are different.\n\n Since: 1.5.0"]
pub type hb_buffer_diff_flags_t = ::std::os::raw::c_uint;
extern "C" {
    pub fn hb_buffer_diff(
        buffer: *mut hb_buffer_t,
        reference: *mut hb_buffer_t,
        dottedcircle_glyph: hb_codepoint_t,
        position_fuzz: ::std::os::raw::c_uint,
    ) -> hb_buffer_diff_flags_t;
}
#[doc = " hb_buffer_message_func_t:\n @buffer: An #hb_buffer_t to work upon\n @font: The #hb_font_t the @buffer is shaped with\n @message: `NULL`-terminated message passed to the function\n @user_data: User data pointer passed by the caller\n\n A callback method for #hb_buffer_t. The method gets called with the\n #hb_buffer_t it was set on, the #hb_font_t the buffer is shaped with and a\n message describing what step of the shaping process will be performed.\n Returning `false` from this method will skip this shaping step and move to\n the next one.\n\n Return value: `true` to perform the shaping step, `false` to skip it.\n\n Since: 1.1.3"]
pub type hb_buffer_message_func_t = ::std::option::Option<
    unsafe extern "C" fn(
        buffer: *mut hb_buffer_t,
        font: *mut hb_font_t,
        message: *const ::std::os::raw::c_char,
        user_data: *mut ::std::os::raw::c_void,
    ) -> hb_bool_t,
>;
extern "C" {
    pub fn hb_buffer_set_message_func(
        buffer: *mut hb_buffer_t,
        func: hb_buffer_message_func_t,
        user_data: *mut ::std::os::raw::c_void,
        destroy: hb_destroy_func_t,
    );
}
#[doc = " hb_font_get_glyph_func_t:\n @font: #hb_font_t to work upon\n @font_data: @font user data pointer\n @unicode: The Unicode code point to query\n @variation_selector: The  variation-selector code point to query\n @glyph: (out): The glyph ID retrieved\n @user_data: User data pointer passed by the caller\n\n A virtual method for the #hb_font_funcs_t of an #hb_font_t object.\n\n This method should retrieve the glyph ID for a specified Unicode code point\n font, with an optional variation selector.\n\n Return value: `true` if data found, `false` otherwise\n Deprecated: 1.2.3\n"]
pub type hb_font_get_glyph_func_t = ::std::option::Option<
    unsafe extern "C" fn(
        font: *mut hb_font_t,
        font_data: *mut ::std::os::raw::c_void,
        unicode: hb_codepoint_t,
        variation_selector: hb_codepoint_t,
        glyph: *mut hb_codepoint_t,
        user_data: *mut ::std::os::raw::c_void,
    ) -> hb_bool_t,
>;
extern "C" {
    pub fn hb_font_funcs_set_glyph_func(
        ffuncs: *mut hb_font_funcs_t,
        func: hb_font_get_glyph_func_t,
        user_data: *mut ::std::os::raw::c_void,
        destroy: hb_destroy_func_t,
    );
}
#[doc = " hb_unicode_eastasian_width_func_t:\n @ufuncs: A Unicode-functions structure\n @unicode: The code point to query\n @user_data: User data pointer passed by the caller\n\n A virtual method for the #hb_unicode_funcs_t structure.\n\n Deprecated: 2.0.0"]
pub type hb_unicode_eastasian_width_func_t = ::std::option::Option<
    unsafe extern "C" fn(
        ufuncs: *mut hb_unicode_funcs_t,
        unicode: hb_codepoint_t,
        user_data: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_uint,
>;
extern "C" {
    #[doc = " hb_unicode_funcs_set_eastasian_width_func:\n @ufuncs: a Unicode-function structure\n @func: (closure user_data) (destroy destroy) (scope notified): The callback function to assign\n @user_data: Data to pass to @func\n @destroy: (nullable): The function to call when @user_data is not needed anymore\n\n Sets the implementation function for #hb_unicode_eastasian_width_func_t.\n\n Since: 0.9.2\n Deprecated: 2.0.0"]
    pub fn hb_unicode_funcs_set_eastasian_width_func(
        ufuncs: *mut hb_unicode_funcs_t,
        func: hb_unicode_eastasian_width_func_t,
        user_data: *mut ::std::os::raw::c_void,
        destroy: hb_destroy_func_t,
    );
}
extern "C" {
    #[doc = " hb_unicode_eastasian_width:\n @ufuncs: a Unicode-function structure\n @unicode: The code point to query\n\n Don't use. Not used by HarfBuzz.\n\n Since: 0.9.2\n Deprecated: 2.0.0"]
    pub fn hb_unicode_eastasian_width(
        ufuncs: *mut hb_unicode_funcs_t,
        unicode: hb_codepoint_t,
    ) -> ::std::os::raw::c_uint;
}
#[doc = " hb_unicode_decompose_compatibility_func_t:\n @ufuncs: a Unicode function structure\n @u: codepoint to decompose\n @decomposed: address of codepoint array (of length #HB_UNICODE_MAX_DECOMPOSITION_LEN) to write decomposition into\n @user_data: user data pointer as passed to hb_unicode_funcs_set_decompose_compatibility_func()\n\n Fully decompose @u to its Unicode compatibility decomposition. The codepoints of the decomposition will be written to @decomposed.\n The complete length of the decomposition will be returned.\n\n If @u has no compatibility decomposition, zero should be returned.\n\n The Unicode standard guarantees that a buffer of length #HB_UNICODE_MAX_DECOMPOSITION_LEN codepoints will always be sufficient for any\n compatibility decomposition plus an terminating value of 0.  Consequently, @decompose must be allocated by the caller to be at least this length.  Implementations\n of this function type must ensure that they do not write past the provided array.\n\n Return value: number of codepoints in the full compatibility decomposition of @u, or 0 if no decomposition available.\n\n Deprecated: 2.0.0"]
pub type hb_unicode_decompose_compatibility_func_t = ::std::option::Option<
    unsafe extern "C" fn(
        ufuncs: *mut hb_unicode_funcs_t,
        u: hb_codepoint_t,
        decomposed: *mut hb_codepoint_t,
        user_data: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_uint,
>;
extern "C" {
    #[doc = " hb_unicode_funcs_set_decompose_compatibility_func:\n @ufuncs: A Unicode-functions structure\n @func: (closure user_data) (destroy destroy) (scope notified): The callback function to assign\n @user_data: Data to pass to @func\n @destroy: (nullable): The function to call when @user_data is not needed anymore\n\n Sets the implementation function for #hb_unicode_decompose_compatibility_func_t.\n\n\n\n Since: 0.9.2\n Deprecated: 2.0.0"]
    pub fn hb_unicode_funcs_set_decompose_compatibility_func(
        ufuncs: *mut hb_unicode_funcs_t,
        func: hb_unicode_decompose_compatibility_func_t,
        user_data: *mut ::std::os::raw::c_void,
        destroy: hb_destroy_func_t,
    );
}
extern "C" {
    pub fn hb_unicode_decompose_compatibility(
        ufuncs: *mut hb_unicode_funcs_t,
        u: hb_codepoint_t,
        decomposed: *mut hb_codepoint_t,
    ) -> ::std::os::raw::c_uint;
}
#[doc = " hb_font_get_glyph_v_kerning_func_t:\n\n A virtual method for the #hb_font_funcs_t of an #hb_font_t object.\n\n This method should retrieve the kerning-adjustment value for a glyph-pair in\n the specified font, for vertical text segments.\n"]
pub type hb_font_get_glyph_v_kerning_func_t = hb_font_get_glyph_kerning_func_t;
extern "C" {
    #[doc = " hb_font_funcs_set_glyph_v_kerning_func:\n @ffuncs: A font-function structure\n @func: (closure user_data) (destroy destroy) (scope notified): The callback function to assign\n @user_data: Data to pass to @func\n @destroy: (nullable): The function to call when @user_data is not needed anymore\n\n Sets the implementation function for #hb_font_get_glyph_v_kerning_func_t.\n\n Since: 0.9.2\n Deprecated: 2.0.0"]
    pub fn hb_font_funcs_set_glyph_v_kerning_func(
        ffuncs: *mut hb_font_funcs_t,
        func: hb_font_get_glyph_v_kerning_func_t,
        user_data: *mut ::std::os::raw::c_void,
        destroy: hb_destroy_func_t,
    );
}
extern "C" {
    pub fn hb_font_get_glyph_v_kerning(
        font: *mut hb_font_t,
        top_glyph: hb_codepoint_t,
        bottom_glyph: hb_codepoint_t,
    ) -> hb_position_t;
}
#[doc = " hb_font_get_glyph_shape_func_t:\n @font: #hb_font_t to work upon\n @font_data: @font user data pointer\n @glyph: The glyph ID to query\n @draw_funcs: The draw functions to send the shape data to\n @draw_data: The data accompanying the draw functions\n @user_data: User data pointer passed by the caller\n\n A virtual method for the #hb_font_funcs_t of an #hb_font_t object.\n\n Since: 4.0.0\n Deprecated: 7.0.0: Use #hb_font_draw_glyph_func_t instead"]
pub type hb_font_get_glyph_shape_func_t = ::std::option::Option<
    unsafe extern "C" fn(
        font: *mut hb_font_t,
        font_data: *mut ::std::os::raw::c_void,
        glyph: hb_codepoint_t,
        draw_funcs: *mut hb_draw_funcs_t,
        draw_data: *mut ::std::os::raw::c_void,
        user_data: *mut ::std::os::raw::c_void,
    ),
>;
extern "C" {
    #[doc = " hb_font_funcs_set_glyph_shape_func:\n @ffuncs: A font-function structure\n @func: (closure user_data) (destroy destroy) (scope notified): The callback function to assign\n @user_data: Data to pass to @func\n @destroy: (nullable): The function to call when @user_data is not needed anymore\n\n Sets the implementation function for #hb_font_get_glyph_shape_func_t,\n which is the same as #hb_font_draw_glyph_func_t.\n\n Since: 4.0.0\n Deprecated: 7.0.0: Use hb_font_funcs_set_draw_glyph_func() instead"]
    pub fn hb_font_funcs_set_glyph_shape_func(
        ffuncs: *mut hb_font_funcs_t,
        func: hb_font_get_glyph_shape_func_t,
        user_data: *mut ::std::os::raw::c_void,
        destroy: hb_destroy_func_t,
    );
}
extern "C" {
    pub fn hb_font_get_glyph_shape(
        font: *mut hb_font_t,
        glyph: hb_codepoint_t,
        dfuncs: *mut hb_draw_funcs_t,
        draw_data: *mut ::std::os::raw::c_void,
    );
}
extern "C" {
    pub fn hb_shape(
        font: *mut hb_font_t,
        buffer: *mut hb_buffer_t,
        features: *const hb_feature_t,
        num_features: ::std::os::raw::c_uint,
    );
}
extern "C" {
    pub fn hb_shape_full(
        font: *mut hb_font_t,
        buffer: *mut hb_buffer_t,
        features: *const hb_feature_t,
        num_features: ::std::os::raw::c_uint,
        shaper_list: *const *const ::std::os::raw::c_char,
    ) -> hb_bool_t;
}
extern "C" {
    pub fn hb_shape_justify(
        font: *mut hb_font_t,
        buffer: *mut hb_buffer_t,
        features: *const hb_feature_t,
        num_features: ::std::os::raw::c_uint,
        shaper_list: *const *const ::std::os::raw::c_char,
        min_target_advance: f32,
        max_target_advance: f32,
        advance: *mut f32,
        var_tag: *mut hb_tag_t,
        var_value: *mut f32,
    ) -> hb_bool_t;
}
extern "C" {
    pub fn hb_shape_list_shapers() -> *mut *const ::std::os::raw::c_char;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct hb_shape_plan_t {
    _unused: [u8; 0],
}
extern "C" {
    pub fn hb_shape_plan_create(
        face: *mut hb_face_t,
        props: *const hb_segment_properties_t,
        user_features: *const hb_feature_t,
        num_user_features: ::std::os::raw::c_uint,
        shaper_list: *const *const ::std::os::raw::c_char,
    ) -> *mut hb_shape_plan_t;
}
extern "C" {
    pub fn hb_shape_plan_create_cached(
        face: *mut hb_face_t,
        props: *const hb_segment_properties_t,
        user_features: *const hb_feature_t,
        num_user_features: ::std::os::raw::c_uint,
        shaper_list: *const *const ::std::os::raw::c_char,
    ) -> *mut hb_shape_plan_t;
}
extern "C" {
    pub fn hb_shape_plan_create2(
        face: *mut hb_face_t,
        props: *const hb_segment_properties_t,
        user_features: *const hb_feature_t,
        num_user_features: ::std::os::raw::c_uint,
        coords: *const ::std::os::raw::c_int,
        num_coords: ::std::os::raw::c_uint,
        shaper_list: *const *const ::std::os::raw::c_char,
    ) -> *mut hb_shape_plan_t;
}
extern "C" {
    pub fn hb_shape_plan_create_cached2(
        face: *mut hb_face_t,
        props: *const hb_segment_properties_t,
        user_features: *const hb_feature_t,
        num_user_features: ::std::os::raw::c_uint,
        coords: *const ::std::os::raw::c_int,
        num_coords: ::std::os::raw::c_uint,
        shaper_list: *const *const ::std::os::raw::c_char,
    ) -> *mut hb_shape_plan_t;
}
extern "C" {
    pub fn hb_shape_plan_get_empty() -> *mut hb_shape_plan_t;
}
extern "C" {
    pub fn hb_shape_plan_reference(shape_plan: *mut hb_shape_plan_t) -> *mut hb_shape_plan_t;
}
extern "C" {
    pub fn hb_shape_plan_destroy(shape_plan: *mut hb_shape_plan_t);
}
extern "C" {
    pub fn hb_shape_plan_set_user_data(
        shape_plan: *mut hb_shape_plan_t,
        key: *mut hb_user_data_key_t,
        data: *mut ::std::os::raw::c_void,
        destroy: hb_destroy_func_t,
        replace: hb_bool_t,
    ) -> hb_bool_t;
}
extern "C" {
    pub fn hb_shape_plan_get_user_data(
        shape_plan: *const hb_shape_plan_t,
        key: *mut hb_user_data_key_t,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn hb_shape_plan_execute(
        shape_plan: *mut hb_shape_plan_t,
        font: *mut hb_font_t,
        buffer: *mut hb_buffer_t,
        features: *const hb_feature_t,
        num_features: ::std::os::raw::c_uint,
    ) -> hb_bool_t;
}
extern "C" {
    pub fn hb_shape_plan_get_shaper(
        shape_plan: *mut hb_shape_plan_t,
    ) -> *const ::std::os::raw::c_char;
}
pub const hb_style_tag_t_HB_STYLE_TAG_ITALIC: hb_style_tag_t = 1769234796;
pub const hb_style_tag_t_HB_STYLE_TAG_OPTICAL_SIZE: hb_style_tag_t = 1869640570;
pub const hb_style_tag_t_HB_STYLE_TAG_SLANT_ANGLE: hb_style_tag_t = 1936486004;
pub const hb_style_tag_t_HB_STYLE_TAG_SLANT_RATIO: hb_style_tag_t = 1399615092;
pub const hb_style_tag_t_HB_STYLE_TAG_WIDTH: hb_style_tag_t = 2003072104;
pub const hb_style_tag_t_HB_STYLE_TAG_WEIGHT: hb_style_tag_t = 2003265652;
pub const hb_style_tag_t__HB_STYLE_TAG_MAX_VALUE: hb_style_tag_t = 2147483647;
#[doc = " hb_style_tag_t:\n @HB_STYLE_TAG_ITALIC: Used to vary between non-italic and italic.\n A value of 0 can be interpreted as \"Roman\" (non-italic); a value of 1 can\n be interpreted as (fully) italic.\n @HB_STYLE_TAG_OPTICAL_SIZE: Used to vary design to suit different text sizes.\n Non-zero. Values can be interpreted as text size, in points.\n @HB_STYLE_TAG_SLANT_ANGLE: Used to vary between upright and slanted text. Values\n must be greater than -90 and less than +90. Values can be interpreted as\n the angle, in counter-clockwise degrees, of oblique slant from whatever the\n designer considers to be upright for that font design. Typical right-leaning\n Italic fonts have a negative slant angle (typically around -12)\n @HB_STYLE_TAG_SLANT_RATIO: same as @HB_STYLE_TAG_SLANT_ANGLE expression as ratio.\n Typical right-leaning Italic fonts have a positive slant ratio (typically around 0.2)\n @HB_STYLE_TAG_WIDTH: Used to vary width of text from narrower to wider.\n Non-zero. Values can be interpreted as a percentage of whatever the font\n designer considers “normal width” for that font design.\n @HB_STYLE_TAG_WEIGHT: Used to vary stroke thicknesses or other design details\n to give variation from lighter to blacker. Values can be interpreted in direct\n comparison to values for usWeightClass in the OS/2 table,\n or the CSS font-weight property.\n\n Defined by [OpenType Design-Variation Axis Tag Registry](https://docs.microsoft.com/en-us/typography/opentype/spec/dvaraxisreg).\n\n Since: 3.0.0"]
pub type hb_style_tag_t = ::std::os::raw::c_uint;
extern "C" {
    pub fn hb_style_get_value(font: *mut hb_font_t, style_tag: hb_style_tag_t) -> f32;
}
extern "C" {
    pub fn hb_version(
        major: *mut ::std::os::raw::c_uint,
        minor: *mut ::std::os::raw::c_uint,
        micro: *mut ::std::os::raw::c_uint,
    );
}
extern "C" {
    pub fn hb_version_string() -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn hb_version_atleast(
        major: ::std::os::raw::c_uint,
        minor: ::std::os::raw::c_uint,
        micro: ::std::os::raw::c_uint,
    ) -> hb_bool_t;
}
pub type __builtin_va_list = *mut ::std::os::raw::c_char;
